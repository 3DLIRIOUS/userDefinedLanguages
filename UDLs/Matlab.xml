<?xml version="1.0" encoding="Windows-1252" ?>
<NotepadPlus>
    <AutoComplete>
        <KeyWord name="abs" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  abs (Z)
     Compute the magnitude of Z, defined as |Z| = 'sqrt (x^2 + y^2)'.

     For example:

          abs (3 + 4i)
              => 5

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="accumarray" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  accumarray (SUBS, VALS, SZ, FUNC, FILLVAL, ISSPARSE)
 -- Function File:  accumarray (SUBS, VALS, ...)
     Create an array by accumulating the elements of a vector into the
     positions defined by their subscripts.  The subscripts are defined
     by the rows of the matrix SUBS and the values by VALS.  Each row
     of SUBS corresponds to one of the values in VALS.  If VALS is a
     scalar, it will be used for each of the row of SUBS.  If SUBS is a
     cell array of vectors, all vectors must be of the same length, and
     the subscripts in the Kth vector must correspond to the Kth
     dimension of the result.

     The size of the matrix will be determined by the subscripts
     themselves.  However, if SZ is defined it determines the matrix
     size.  The length of SZ must correspond to the number of columns
     in SUBS.  An exception is if SUBS has only one column, in which
     case SZ may be the dimensions of a vector and the subscripts of
     SUBS are ...

     USE help accumarray FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="accumdim" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  accumdim (SUBS, VALS, DIM, N, FUNC, FILLVAL)
     Create an array by accumulating the slices of an array into the
     positions defined by their subscripts along a specified dimension.
     The subscripts are defined by the index vector SUBS.  The
     dimension is specified by DIM.  If not given, it defaults to the
     first non-singleton dimension.  The length of SUBS must be equal
     to 'size (VALS, DIM)'.

     The extent of the result matrix in the working dimension will be
     determined by the subscripts themselves.  However, if N is defined
     it determines this extent.

     The default action of 'accumdim' is to sum the subarrays with the
     same subscripts.  This behavior can be modified by defining the
     FUNC function.  This should be a function or function handle that
     accepts an array and a dimension, and reduces the array along this
     dimension.  As a special exception, the built-in 'min' and 'max'
     functions can be used directl...

     USE help accumdim FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="acos" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  acos (X)
     Compute the inverse cosine in radians for each element of X.

     See also: cos, acosd


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="acosd" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  acosd (X)
     Compute the inverse cosine in degrees for each element of X.

     See also: cosd, acos


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="acosh" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  acosh (X)
     Compute the inverse hyperbolic cosine for each element of X.

     See also: cosh


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="acot" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  acot (X)
     Compute the inverse cotangent in radians for each element of X.

     See also: cot, acotd


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="acotd" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  acotd (X)
     Compute the inverse cotangent in degrees for each element of X.

     See also: cotd, acot


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="acoth" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  acoth (X)
     Compute the inverse hyperbolic cotangent of each element of X.

     See also: coth


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="acsc" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  acsc (X)
     Compute the inverse cosecant in radians for each element of X.

     See also: csc, acscd


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="acscd" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  acscd (X)
     Compute the inverse cosecant in degrees for each element of X.

     See also: cscd, acsc


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="acsch" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  acsch (X)
     Compute the inverse hyperbolic cosecant of each element of X.

     See also: csch


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="add_input_event_hook" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  add_input_event_hook (FCN)
 -- Built-in Function:  add_input_event_hook (FCN, DATA)
     Add the named function FCN to the list of functions to call
     periodically when Octave is waiting for input.  The function should
     have the form

          FCN (DATA)

     If DATA is omitted, Octave calls the function without any
     arguments.

     See also: remove_input_event_hook


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="addlistener" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  addlistener (H, PROP, FCN)
     Register FCN as listener for the property PROP of the graphics
     object H.  Property listeners are executed (in order of
     registration) when the property is set.  The new value is already
     available when the listeners are executed.

     PROP must be a string naming a valid property in H.

     FCN can be a function handle, a string or a cell array whose first
     element is a function handle.  If FCN is a function handle, the
     corresponding function should accept at least 2 arguments, that
     will be set to the object handle and the empty matrix
     respectively.  If FCN is a string, it must be any valid octave
     expression.  If FCN is a cell array, the first element must be a
     function handle with the same signature as described above.  The
     next elements of the cell array are passed as additional arguments
     to the function.

     Example:

          function my_listener (h, dummy, p1)
         ...

     USE help addlistener FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="addpath" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  addpath (DIR1, ...)
 -- Built-in Function:  addpath (DIR1, ..., OPTION)
     Add DIR1, ... to the current function search path.  If OPTION is
     '-begin' or 0 (the default), prepend the directory name to the
     current path.  If OPTION is '-end' or 1, append the directory name
     to the current path.  Directories added to the path must exist.

     In addition to accepting individual directory arguments, lists of
     directory names separated by 'pathsep' are also accepted.  For
     example:

          addpath ('dir1:/dir2:~/dir3');

     See also: path, rmpath, genpath, pathdef, savepath, pathsep


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="addpref" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  addpref (GROUP, PREF, VAL)
     Add a preference PREF and associated value VAL to the named
     preference group GROUP.

     The named preference group must be a character string.

     The preference PREF may be a character string or a cell array of
     character strings.  The corresponding value VAL may be any value,
     or, if PREF is a cell array of strings, VAL must be a cell array
     of values with the same size as PREF.

     See also: setpref, getpref, ispref, rmpref


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="addproperty" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  addproperty (NAME, H, TYPE)
 -- Built-in Function:  addproperty (NAME, H, TYPE, ARG, ...)
     Create a new property named NAME in graphics object H.  TYPE
     determines the type of the property to create.  ARGS usually
     contains the default value of the property, but additional
     arguments might be given, depending on the type of the property.

     The supported property types are:

    'string'
          A string property.  ARG contains the default string value.

    'any'
          An un-typed property.  This kind of property can hold any
          octave value.  ARGS contains the default value.

    'radio'
          A string property with a limited set of accepted values.  The
          first argument must be a string with all accepted values
          separated by a vertical bar ('|').  The default value can be
          marked by enclosing it with a '{' '}' pair.  The default
          value may also be given as an optional second string argumen...

     USE help addproperty FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="addtodate" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: D = addtodate (D, Q, F)
     Add Q amount of time (with units F) to the serial datenum, D.

     F must be one of 'year', 'month', 'day', 'hour', 'minute',
     'second', or 'millisecond'.

     See also: datenum, datevec, etime


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="airy" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: [A, IERR] = airy (K, Z, OPT)
     Compute Airy functions of the first and second kind, and their
     derivatives.

          K   Function   Scale factor (if 'opt' is supplied)
          ---  --------   ---------------------------------------
          0   Ai (Z)     exp ((2/3) * Z * sqrt (Z))
          1   dAi(Z)/dZ  exp ((2/3) * Z * sqrt (Z))
          2   Bi (Z)     exp (-abs (real ((2/3) * Z *sqrt (Z))))
          3   dBi(Z)/dZ  exp (-abs (real ((2/3) * Z *sqrt (Z))))

     The function call 'airy (Z)' is equivalent to 'airy (0, Z)'.

     The result is the same size as Z.

     If requested, IERR contains the following status information and
     is the same size as the result.

       0. Normal return.

       1. Input error, return 'NaN'.

       2. Overflow, return 'Inf'.

       3. Loss of significance by argument reduction results in less
          than half of machine accuracy.

       4. Complete loss of significance by argument reduction, return
    ...

     USE help airy FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="all" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  all (X)
 -- Built-in Function:  all (X, DIM)
     For a vector argument, return true (logical 1) if all elements of
     the vector are nonzero.

     For a matrix argument, return a row vector of logical ones and
     zeros with each element indicating whether all of the elements of
     the corresponding column of the matrix are nonzero.  For example:

          all ([2, 3; 1, 0]))
              => [ 1, 0 ]

     If the optional argument DIM is supplied, work along dimension DIM.

     See also: any


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="allchild" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: H = allchild (HANDLES)
     Find all children, including hidden children, of a graphics object.

     This function is similar to 'get (h, 'children')', but also
     returns hidden objects.  If HANDLES is a scalar, H will be a
     vector.  Otherwise, H will be a cell matrix of the same size as
     HANDLES and each cell will contain a vector of handles.

     See also: get, set, findall, findobj


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="allow_noninteger_range_as_index" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: VAL = allow_noninteger_range_as_index ()
 -- Built-in Function: OLD_VAL = allow_noninteger_range_as_index
          (NEW_VAL)
 -- Built-in Function:  allow_noninteger_range_as_index (NEW_VAL,
          'local')
     Query or set the internal variable that controls whether
     non-integer ranges are allowed as indices.  This might be useful
     for MATLAB compatibility; however, it is still not entirely
     compatible because MATLAB treats the range expression differently
     in different contexts.

     When called from inside a function with the 'local' option, the
     variable is changed locally for the function and any subroutines
     it calls.  The original variable value is restored when exiting
     the function.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="amd" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: P = amd (S)
 -- Loadable Function: P = amd (S, OPTS)
     Return the approximate minimum degree permutation of a matrix.
     This permutation such that the Cholesky factorization of 'S (P,
     P)' tends to be sparser than the Cholesky factorization of S
     itself.  'amd' is typically faster than 'symamd' but serves a
     similar purpose.

     The optional parameter OPTS is a structure that controls the
     behavior of 'amd'.  The fields of the structure are

    OPTS.dense
          Determines what 'amd' considers to be a dense row or column
          of the input matrix.  Rows or columns with more than 'max(16,
          (dense * sqrt (N)' entries, where N is the order of the
          matrix S, are ignored by 'amd' during the calculation of the
          permutation The value of dense must be a positive scalar and
          its default value is 10.0

    OPTS.aggressive
          If this value is a non zero scalar, then 'amd' performs
          aggressiv...

     USE help amd FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="ancestor" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: PARENT = ancestor (H, TYPE)
 -- Function File: PARENT = ancestor (H, TYPE, 'toplevel')
     Return the first ancestor of handle object H whose type matches
     TYPE, where TYPE is a character string.  If TYPE is a cell array
     of strings, return the first parent whose type matches any of the
     given type strings.

     If the handle object H is of type TYPE, return H.

     If &quot;toplevel&quot; is given as a 3rd argument, return the highest
     parent in the object hierarchy that matches the condition, instead
     of the first (nearest) one.

     See also: get, set


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="and" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  and (X, Y)
 -- Built-in Function:  and (X1, X2, ...)
     Return the logical AND of X and Y.  This function is equivalent to
     ' x &amp; y '.  If more arguments are given, the logical and is applied
     cumulatively from left to right:

           (...((x1 &amp; x2) &amp; x3) &amp; ...)

     At least one argument is required.

     See also: or, not, xor


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="Anderson" func="yes">
            <Overload retVal="">
                <Param name="
Frequency-weighted coprime factorization controller reduction.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="anova" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [PVAL, F, DF_B, DF_W] = anova (Y, G)
     Perform a one-way analysis of variance (ANOVA).  The goal is to
     test whether the population means of data taken from K different
     groups are all equal.

     Data may be given in a single vector Y with groups specified by a
     corresponding vector of group labels G (e.g., numbers from 1 to
     K).  This is the general form which does not impose any
     restriction on the number of data in each group or the group
     labels.

     If Y is a matrix and G is omitted, each column of Y is treated as
     a group.  This form is only appropriate for balanced ANOVA in
     which the numbers of samples from each group are all equal.

     Under the null of constant means, the statistic F follows an F
     distribution with DF_B and DF_W degrees of freedom.

     The p-value (1 minus the CDF of this distribution at F) is
     returned in PVAL.

     If no output argument is given, the standard one-way ANOVA table is
     ...

     USE help anova FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="ans" func="yes">
            <Overload retVal="">
                <Param name="
 -- Automatic Variable: ans
     The most recently computed result that was not explicitly assigned
     to a variable.  For example, after the expression

          3^2 + 4^2

     is evaluated, the value returned by 'ans' is 25.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="any" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  any (X)
 -- Built-in Function:  any (X, DIM)
     For a vector argument, return true (logical 1) if any element of
     the vector is nonzero.

     For a matrix argument, return a row vector of logical ones and
     zeros with each element indicating whether any of the elements of
     the corresponding column of the matrix are nonzero.  For example:

          any (eye (2, 4))
              => [ 1, 1, 0, 0 ]

     If the optional argument DIM is supplied, work along dimension
     DIM.  For example:

          any (eye (2, 4), 2)
              => [ 1; 1 ]

     See also: all


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="arch_fit" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [A, B] = arch_fit (Y, X, P, ITER, GAMMA, A0, B0)
     Fit an ARCH regression model to the time series Y using the
     scoring algorithm in Engle's original ARCH paper.  The model is

          y(t) = b(1) * x(t,1) + ... + b(k) * x(t,k) + e(t),
          h(t) = a(1) + a(2) * e(t-1)^2 + ... + a(p+1) * e(t-p)^2

     in which e(t) is N(0, h(t)), given a time-series vector Y up to
     time t-1 and a matrix of (ordinary) regressors X up to t.  The
     order of the regression of the residual variance is specified by P.

     If invoked as 'arch_fit (Y, K, P)' with a positive integer K, fit
     an ARCH(K, P) process, i.e., do the above with the t-th row of X
     given by

          [1, y(t-1), ..., y(t-k)]

     Optionally, one can specify the number of iterations ITER, the
     updating factor GAMMA, and initial values a0 and b0 for the
     scoring algorithm.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="arch_rnd" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  arch_rnd (A, B, T)
     Simulate an ARCH sequence of length T with AR coefficients B and
     CH coefficients A.  I.e., the result y(t) follows the model

          y(t) = b(1) + b(2) * y(t-1) + ... + b(lb) * y(t-lb+1) + e(t),

     where e(t), given Y up to time t-1, is N(0, h(t)), with

          h(t) = a(1) + a(2) * e(t-1)^2 + ... + a(la) * e(t-la+1)^2

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="arch_test" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [PVAL, LM] = arch_test (Y, X, P)
     For a linear regression model

          y = x * b + e

     perform a Lagrange Multiplier (LM) test of the null hypothesis of
     no conditional heteroscedascity against the alternative of CH(P).

     I.e., the model is

          y(t) = b(1) * x(t,1) + ... + b(k) * x(t,k) + e(t),

     given Y up to t-1 and X up to t, e(t) is N(0, h(t)) with

          h(t) = v + a(1) * e(t-1)^2 + ... + a(p) * e(t-p)^2,

     and the null is a(1) == ... == a(p) == 0.

     If the second argument is a scalar integer, k, perform the same
     test in a linear autoregression model of order k, i.e., with

          [1, y(t-1), ..., y(t-K)]

     as the t-th row of X.

     Under the null, LM approximately has a chisquare distribution with
     P degrees of freedom and PVAL is the p-value (1 minus the CDF of
     this distribution at LM) of the test.

     If no output argument is given, the p-value is displayed.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="area" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  area (X, Y)
 -- Function File:  area (X, Y, LVL)
 -- Function File:  area (..., PROP, VAL, ...)
 -- Function File:  area (Y, ...)
 -- Function File:  area (H, ...)
 -- Function File: H = area (...)
     Area plot of cumulative sum of the columns of Y.  This shows the
     contributions of a value to a sum, and is functionally similar to
     'plot (X, cumsum (Y, 2))', except that the area under the curve is
     shaded.

     If the X argument is omitted it is assumed to be given by '1 :
     rows (Y)'.  A value LVL can be defined that determines where the
     base level of the shading under the curve should be defined.

     Additional arguments to the 'area' function are passed to 'patch'.

     The optional return value H is a graphics handle to the hggroup
     object representing the area patch objects.

     See also: plot, patch


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="arg" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  arg (Z)
 -- Mapping Function:  angle (Z)
     Compute the argument of Z, defined as, THETA = 'atan2 (Y, X)', in
     radians.

     For example:

          arg (3 + 4i)
              => 0.92730

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="argnames" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  argnames (FUN)
     Return a cell array of character strings containing the names of
     the arguments of the inline function FUN.

     See also: inline, formula, vectorize


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="argv" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  argv ()
     Return the command line arguments passed to Octave.  For example,
     if you invoked Octave using the command

          octave --no-line-editing --silent

     'argv' would return a cell array of strings with the elements
     '--no-line-editing' and '--silent'.

     If you write an executable Octave script, 'argv' will return the
     list of arguments passed to the script.  *Note Executable Octave
     Programs::, for an example of how to create an executable Octave
     script.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="arma_rnd" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  arma_rnd (A, B, V, T, N)
     Return a simulation of the ARMA model

          x(n) = a(1) * x(n-1) + ... + a(k) * x(n-k)
               + e(n) + b(1) * e(n-1) + ... + b(l) * e(n-l)

     in which K is the length of vector A, L is the length of vector B
     and E is Gaussian white noise with variance V.  The function
     returns a vector of length T.

     The optional parameter N gives the number of dummy X(I) used for
     initialization, i.e., a sequence of length T+N is generated and
     X(N+1:T+N) is returned.  If N is omitted, N = 100 is used.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="arrayfun" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  arrayfun (FUNC, A)
 -- Function File: X = arrayfun (FUNC, A)
 -- Function File: X = arrayfun (FUNC, A, B, ...)
 -- Function File: [X, Y, ...] = arrayfun (FUNC, A, ...)
 -- Function File:  arrayfun (..., 'UniformOutput', VAL)
 -- Function File:  arrayfun (..., 'ErrorHandler', ERRFUNC)
     Execute a function on each element of an array.  This is useful for
     functions that do not accept array arguments.  If the function does
     accept array arguments it is better to call the function directly.

     The first input argument FUNC can be a string, a function handle,
     an inline function, or an anonymous function.  The input argument
     A can be a logic array, a numeric array, a string array, a
     structure array, or a cell array.  By a call of the function
     'arrayfun' all elements of A are passed on to the named function
     FUNC individually.

     The named function can also take more than two input arguments,
     with the input arguments given as t...

     USE help arrayfun FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="asctime" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  asctime (TM_STRUCT)
     Convert a time structure to a string using the following format:
     'ddd mmm mm HH:MM:SS yyyy'.  For example:

          asctime (localtime (time ()))
               => 'Mon Feb 17 01:15:06 1997'

     This is equivalent to 'ctime (time ())'.

     See also: ctime, localtime, time


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="asec" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  asec (X)
     Compute the inverse secant in radians for each element of X.

     See also: sec, asecd


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="asecd" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  asecd (X)
     Compute the inverse secant in degrees for each element of X.

     See also: secd, asec


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="asech" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  asech (X)
     Compute the inverse hyperbolic secant of each element of X.

     See also: sech


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="asin" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  asin (X)
     Compute the inverse sine in radians for each element of X.

     See also: sin, asind


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="asind" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  asind (X)
     Compute the inverse sine in degrees for each element of X.

     See also: sind, asin


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="asinh" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  asinh (X)
     Compute the inverse hyperbolic sine for each element of X.

     See also: sinh


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="assert" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  assert (COND)
 -- Function File:  assert (COND, ERRMSG, ...)
 -- Function File:  assert (COND, MSG_ID, ERRMSG, ...)
 -- Function File:  assert (OBSERVED, EXPECTED)
 -- Function File:  assert (OBSERVED, EXPECTED, TOL)
     Produce an error if the specified condition is not met.  'assert'
     can be called in three different ways.

    'assert (COND)'
    'assert (COND, ERRMSG, ...)'
    'assert (COND, MSG_ID, ERRMSG, ...)'
          Called with a single argument COND, 'assert' produces an
          error if COND is zero.  When called with more than one
          argument the additional arguments are passed to the 'error'
          function.

    'assert (OBSERVED, EXPECTED)'
          Produce an error if observed is not the same as expected.
          Note that OBSERVED and EXPECTED can be scalars, vectors,
          matrices, strings, cell arrays, or structures.

    'assert (OBSERVED, EXPECTED, TOL)'
          Produce an error if observed is not the same as expect...

     USE help assert FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="assignin" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  assignin (CONTEXT, VARNAME, VALUE)
     Assign VALUE to VARNAME in context CONTEXT, which may be either
     &quot;base&quot; or &quot;caller&quot;.

     See also: evalin


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="atan" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  atan (X)
     Compute the inverse tangent in radians for each element of X.

     See also: tan, atand


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="atan2" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  atan2 (Y, X)
     Compute atan (Y / X) for corresponding elements of Y and X.
     Signal an error if Y and X do not match in size and orientation.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="atand" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  atand (X)
     Compute the inverse tangent in degrees for each element of X.

     See also: tand, atan


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="atanh" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  atanh (X)
     Compute the inverse hyperbolic tangent for each element of X.

     See also: tanh


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="atexit" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  atexit (FCN)
 -- Built-in Function:  atexit (FCN, FLAG)
     Register a function to be called when Octave exits.  For example,

          function last_words ()
           disp ('Bye bye');
          endfunction
          atexit ('last_words');

     will print the message 'Bye bye' when Octave exits.

     The additional argument FLAG will register or unregister FCN from
     the list of functions to be called when Octave exits.  If FLAG is
     true, the function is registered, and if FLAG is false, it is
     unregistered.  For example, after registering the function
     'last_words' above,

          atexit ('last_words', false);

     will remove the function from the list and Octave will not call
     'last_words' when it exits.

     Note that 'atexit' only removes the first occurrence of a function
     from the list, so if a function was placed in the list multiple
     times with 'atexit', it must also be removed from the list
     multiple times.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="augw" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: P = augw (G, W1, W2, W3)
     Extend plant for stacked S/KS/T problem.  Subsequently, the robust
     control problem can be solved by h2syn or hinfsyn.

     *Inputs*
    G
          LTI model of plant.

    W1
          LTI model of performance weight.  Bounds the largest singular
          values of sensitivity S.  Model must be empty '[]', SISO or
          of appropriate size.

    W2
          LTI model to penalize large control inputs.  Bounds the
          largest singular values of KS.  Model must be empty '[]',
          SISO or of appropriate size.

    W3
          LTI model of robustness and noise sensitivity weight.  Bounds
          the largest singular values of complementary sensitivity T.
          Model must be empty '[]', SISO or of appropriate size.

     All inputs must be proper/realizable.  Scalars, vectors and
     matrices are possible instead of LTI models.

     *Outputs*
    P
          State-space model of augmented plant.

     *Block D...

     USE help augw FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="autoload" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  autoload (FUNCTION, FILE)
     Define FUNCTION to autoload from FILE.

     The second argument, FILE, should be an absolute file name or a
     file name in the same directory as the function or script from
     which the autoload command was run.  FILE should not depend on the
     Octave load path.

     Normally, calls to 'autoload' appear in PKG_ADD script files that
     are evaluated when a directory is added to the Octave's load path.
     To avoid having to hardcode directory names in FILE, if FILE is in
     the same directory as the PKG_ADD script then

          autoload ('foo', 'bar.oct');

     will load the function 'foo' from the file 'bar.oct'.  The above
     when 'bar.oct' is not in the same directory or uses like

          autoload ('foo', file_in_loadpath ('bar.oct'))

     are strongly discouraged, as their behavior might be unpredictable.

     With no arguments, return a structure containing the current
     autoload map.

     See also:...

     USE help autoload FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="autoreg_matrix" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  autoreg_matrix (Y, K)
     Given a time series (vector) Y, return a matrix with ones in the
     first column and the first K lagged values of Y in the other
     columns.  I.e., for T &gt; K, '[1, Y(T-1), ..., Y(T-K)]' is the t-th
     row of the result.  The resulting matrix may be used as a
     regressor matrix in autoregressions.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="autumn" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: MAP = autumn ()
 -- Function File: MAP = autumn (N)
     Create color colormap.  This colormap ranges from red through
     orange to yellow.  The argument N must be a scalar.  If
     unspecified, the length of the current colormap, or 64, is used.

     See also: colormap


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="available_graphics_toolkits" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  available_graphics_toolkits ()
     Return a cell array of registered graphics toolkits.

     See also: graphics_toolkit, register_graphics_toolkit


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="axes" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  axes ()
 -- Function File:  axes (PROPERTY, VALUE, ...)
 -- Function File:  axes (H)
     Create an axes object and return a handle to it.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="axis" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  axis ()
 -- Function File:  axis ([X_lo X_hi])
 -- Function File:  axis ([X_lo X_hi Y_lo Y_hi])
 -- Function File:  axis ([X_lo X_hi Y_lo Y_hi Z_lo Z_hi])
 -- Function File:  axis (OPTION)
 -- Function File:  axis (..., OPTION)
 -- Function File:  axis (H, ...)
 -- Function File: LIMITS = axis ()
     Set axis limits for plots.

     The argument LIMITS should be a 2-, 4-, or 6-element vector.  The
     first and second elements specify the lower and upper limits for
     the x-axis.  The third and fourth specify the limits for the
     y-axis, and the fifth and sixth specify the limits for the z-axis.

     Without any arguments, 'axis' turns autoscaling on.

     With one output argument, 'x = axis' returns the current axes.

     The vector argument specifying limits is optional, and additional
     string arguments may be used to specify various axis properties.
     For example,

          axis ([1, 2, 3, 4], 'square');

     forces a square aspect ratio, and

...

     USE help axis FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="balance" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: AA = balance (A)
 -- Loadable Function: AA = balance (A, OPT)
 -- Loadable Function: [DD, AA] = balance (A, OPT)
 -- Loadable Function: [D, P, AA] = balance (A, OPT)
 -- Loadable Function: [CC, DD, AA, BB] = balance (A, B, OPT)
     Compute 'AA = DD \ A * DD' in which AA is a matrix whose row and
     column norms are roughly equal in magnitude, and 'DD = P * D', in
     which P is a permutation matrix and D is a diagonal matrix of
     powers of two.  This allows the equilibration to be computed
     without round-off.  Results of eigenvalue calculation are
     typically improved by balancing first.

     If two output values are requested, 'balance' returns the diagonal
     D and the permutation P separately as vectors.  In this case, 'DD
     = eye(n)(:,P) * diag (D)', where n is the matrix size.

     If four output values are requested, compute 'AA = CC*A*DD' and
     'BB = CC*B*DD', in which AA and BB have non-zero elements of
     approximately the same ...

     USE help balance FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="bar" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  bar (X, Y)
 -- Function File:  bar (Y)
 -- Function File:  bar (X, Y, W)
 -- Function File:  bar (X, Y, W, STYLE)
 -- Function File: H = bar (..., PROP, VAL)
 -- Function File:  bar (H, ...)
     Produce a bar graph from two vectors of x-y data.

     If only one argument is given, Y, it is taken as a vector of
     y-values and the x coordinates are taken to be the indices of the
     elements.

     The default width of 0.8 for the bars can be changed using W.

     If Y is a matrix, then each column of Y is taken to be a separate
     bar graph plotted on the same graph.  By default the columns are
     plotted side-by-side.  This behavior can be changed by the STYLE
     argument, which can take the values &quot;grouped&quot; (the default), or
     &quot;stacked&quot;.

     The optional return value H is a handle to the created 'bar series'
     object with one handle per column of the variable Y.  This series
     allows common elements of the group of bar series objects to b...

     USE help bar FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="barh" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  barh (X, Y)
 -- Function File:  barh (Y)
 -- Function File:  barh (X, Y, W)
 -- Function File:  barh (X, Y, W, STYLE)
 -- Function File: H = barh (..., PROP, VAL)
 -- Function File:  barh (H, ...)
     Produce a horizontal bar graph from two vectors of x-y data.

     If only one argument is given, it is taken as a vector of y-values
     and the x coordinates are taken to be the indices of the elements.

     The default width of 0.8 for the bars can be changed using W.

     If Y is a matrix, then each column of Y is taken to be a separate
     bar graph plotted on the same graph.  By default the columns are
     plotted side-by-side.  This behavior can be changed by the STYLE
     argument, which can take the values &quot;grouped&quot; (the default), or
     &quot;stacked&quot;.

     The optional input handle H allows an axis handle to be passed.
     Properties of the patch graphics object can be changed using PROP,
     VAL pairs.

     The optional return value H is a graphi...

     USE help barh FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="bartlett" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  bartlett (M)
     Return the filter coefficients of a Bartlett (triangular) window of
     length M.

     For a definition of the Bartlett window, see e.g., A. V. Oppenheim
     &amp; R. W. Schafer, 'Discrete-Time Signal Processing'.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="bartlett_test" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [PVAL, CHISQ, DF] = bartlett_test (X1, ...)
     Perform a Bartlett test for the homogeneity of variances in the
     data vectors X1, X2, ..., XK, where K &gt; 1.

     Under the null of equal variances, the test statistic CHISQ
     approximately follows a chi-square distribution with DF degrees of
     freedom.

     The p-value (1 minus the CDF of this distribution at CHISQ) is
     returned in PVAL.

     If no output argument is given, the p-value is displayed.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="base2dec" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  base2dec (S, BASE)
     Convert S from a string of digits in base BASE to a decimal
     integer (base 10).

          base2dec ('11120', 3)
             => 123

     If S is a string matrix, return a column vector with one value per
     row of S.  If a row contains invalid symbols then the
     corresponding value will be NaN.

     If S is a cell array of strings, return a column vector with one
     value per cell element in S.

     If BASE is a string, the characters of BASE are used as the
     symbols for the digits of S.  Space (' ') may not be used as a
     symbol.

          base2dec ('yyyzx', 'xyz')
             => 123

     See also: dec2base, bin2dec, hex2dec


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="beep" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  beep ()
     Produce a beep from the speaker (or visual bell).

     See also: puts, fputs, printf, fprintf


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="beep_on_error" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: VAL = beep_on_error ()
 -- Built-in Function: OLD_VAL = beep_on_error (NEW_VAL)
 -- Built-in Function:  beep_on_error (NEW_VAL, 'local')
     Query or set the internal variable that controls whether Octave
     will try to ring the terminal bell before printing an error
     message.

     When called from inside a function with the 'local' option, the
     variable is changed locally for the function and any subroutines
     it calls.  The original variable value is restored when exiting
     the function.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="besselj" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: [J, IERR] = besselj (ALPHA, X, OPT)
 -- Loadable Function: [Y, IERR] = bessely (ALPHA, X, OPT)
 -- Loadable Function: [I, IERR] = besseli (ALPHA, X, OPT)
 -- Loadable Function: [K, IERR] = besselk (ALPHA, X, OPT)
 -- Loadable Function: [H, IERR] = besselh (ALPHA, K, X, OPT)
     Compute Bessel or Hankel functions of various kinds:

    'besselj'
          Bessel functions of the first kind.  If the argument OPT is
          supplied, the result is multiplied by 'exp(-abs(imag(X)))'.

    'bessely'
          Bessel functions of the second kind.  If the argument OPT is
          supplied, the result is multiplied by 'exp(-abs(imag(X)))'.

    'besseli'
          Modified Bessel functions of the first kind.  If the argument
          OPT is supplied, the result is multiplied by
          'exp(-abs(real(X)))'.

    'besselk'
          Modified Bessel functions of the second kind.  If the
          argument OPT is supplied, the result is multiplied by
          'exp(X...

     USE help besselj FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="beta" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  beta (A, B)
     For real inputs, return the Beta function,

          beta (a, b) = gamma (a) * gamma (b) / gamma (a + b).


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="betacdf" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  betacdf (X, A, B)
     For each element of X, compute the cumulative distribution function
     (CDF) at X of the Beta distribution with parameters A and B.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="betainc" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  betainc (X, A, B)
     Return the regularized incomplete Beta function,

                                              x
                                   1         /
          betainc (x, a, b) = -----------    | t^(a-1) (1-t)^(b-1) dt.
                              beta (a, b)    /
                                          t=0

     If X has more than one component, both A and B must be scalars.
     If X is a scalar, A and B must be of compatible dimensions.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="betainv" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  betainv (X, A, B)
     For each element of X, compute the quantile (the inverse of the
     CDF) at X of the Beta distribution with parameters A and B.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="betaln" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  betaln (A, B)
     Return the natural logarithm of the Beta function,

          betaln (a, b) = log (beta (a, b))

     calculated in a way to reduce the occurrence of underflow.

     See also: beta, betainc, gammaln


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="betapdf" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  betapdf (X, A, B)
     For each element of X, compute the probability density function
     (PDF) at X of the Beta distribution with parameters A and B.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="betarnd" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  betarnd (A, B)
 -- Function File:  betarnd (A, B, R)
 -- Function File:  betarnd (A, B, R, C, ...)
 -- Function File:  betarnd (A, B, [SZ])
     Return a matrix of random samples from the Beta distribution with
     parameters A and B.

     When called with a single size argument, return a square matrix
     with the dimension specified.  When called with more than one
     scalar argument the first two arguments are taken as the number of
     rows and columns and any further arguments specify additional
     matrix dimensions.  The size may also be specified with a vector
     of dimensions SZ.

     If no size arguments are given then the result matrix is the
     common size of A and B.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="bicg" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: X = bicg (A, B, RTOL, MAXIT, M1, M2, X0)
 -- Function File: X = bicg (A, B, RTOL, MAXIT, P)
 -- Function File: [X, FLAG, RELRES, ITER, RESVEC] = bicg (A, B, ...)
     Solve 'A x = b' using the Bi-conjugate gradient iterative method.

        - RTOL is the relative tolerance, if not given or set to [] the
          default value 1e-6 is used.

        - MAXIT the maximum number of outer iterations, if not given or
          set to [] the default value 'min (20, numel (b))' is used.

        - X0 the initial guess, if not given or set to [] the default
          value 'zeros (size (b))' is used.

     A can be passed as a matrix or as a function handle or inline
     function 'f' such that 'f(x, 'notransp') = A*x' and 'f(x,
     'transp') = A'*x'.

     The preconditioner P is given as 'P = M1 * M2'.  Both M1 and M2
     can be passed as a matrix or as a function handle or inline
     function 'g' such that 'g(x, 'notransp') = M1 \ x' or 'g(x,
     'notransp') = M2 \ x...

     USE help bicg FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="bicgstab" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: X = bicgstab (A, B, RTOL, MAXIT, M1, M2, X0)
 -- Function File: X = bicgstab (A, B, RTOL, MAXIT, P)
 -- Function File: [X, FLAG, RELRES, ITER, RESVEC] = bicgstab (A, B,
          ...)
     Solve 'A x = b' using the stabilizied Bi-conjugate gradient
     iterative method.

        - RTOL is the relative tolerance, if not given or set to [] the
          default value 1e-6 is used.

        - MAXIT the maximum number of outer iterations, if not given or
          set to [] the default value 'min (20, numel (b))' is used.

        - X0 the initial guess, if not given or set to [] the default
          value 'zeros (size (b))' is used.

     A can be passed as a matrix or as a function handle or inline
     function 'f' such that 'f(x) = A*x'.

     The preconditioner P is given as 'P = M1 * M2'.  Both M1 and M2
     can be passed as a matrix or as a function handle or inline
     function 'g' such that 'g(x) = M1 \ x' or 'g(x) = M2 \ x'.

     If called with more than o...

     USE help bicgstab FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="bicubic" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: ZI = bicubic (X, Y, Z, XI, YI, EXTRAPVAL)
     Return a matrix ZI corresponding to the bicubic interpolations at
     XI and YI of the data supplied as X, Y and Z.  Points outside the
     grid are set to EXTRAPVAL.

     See 'http://wiki.woodpecker.org.cn/moin/Octave/Bicubic' for
     further information.

     See also: interp2


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="bin2dec" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  bin2dec (S)
     Return the decimal number corresponding to the binary number
     represented by the string S.  For example:

          bin2dec ('1110')
               => 14

     Spaces are ignored during conversion and may be used to make the
     binary number more readable.

          bin2dec ('1000 0001')
               => 129

     If S is a string matrix, return a column vector with one converted
     number per row of S; Invalid rows evaluate to NaN.

     If S is a cell array of strings, return a column vector with one
     converted number per cell element in S.

     See also: dec2bin, base2dec, hex2dec


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="bincoeff" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  bincoeff (N, K)
     Return the binomial coefficient of N and K, defined as

           /   \
           | n |    n (n-1) (n-2) ... (n-k+1)
           |   |  = -------------------------
           | k |               k!
           \   /

     For example:

          bincoeff (5, 2)
             => 10

     In most cases, the 'nchoosek' function is faster for small scalar
     integer arguments.  It also warns about loss of precision for big
     arguments.

     See also: nchoosek


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="binocdf" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  binocdf (X, N, P)
     For each element of X, compute the cumulative distribution function
     (CDF) at X of the binomial distribution with parameters N and P,
     where N is the number of trials and P is the probability of
     success.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="binoinv" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  binoinv (X, N, P)
     For each element of X, compute the quantile (the inverse of the
     CDF) at X of the binomial distribution with parameters N and P,
     where N is the number of trials and P is the probability of
     success.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="binopdf" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  binopdf (X, N, P)
     For each element of X, compute the probability density function
     (PDF) at X of the binomial distribution with parameters N and P,
     where N is the number of trials and P is the probability of
     success.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="binornd" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  binornd (N, P)
 -- Function File:  binornd (N, P, R)
 -- Function File:  binornd (N, P, R, C, ...)
 -- Function File:  binornd (N, P, [SZ])
     Return a matrix of random samples from the binomial distribution
     with parameters N and P, where N is the number of trials and P is
     the probability of success.

     When called with a single size argument, return a square matrix
     with the dimension specified.  When called with more than one
     scalar argument the first two arguments are taken as the number of
     rows and columns and any further arguments specify additional
     matrix dimensions.  The size may also be specified with a vector
     of dimensions SZ.

     If no size arguments are given then the result matrix is the
     common size of N and P.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="bitand" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  bitand (X, Y)
     Return the bitwise AND of non-negative integers.  X, Y must be in
     the range [0,bitmax]

     See also: bitor, bitxor, bitset, bitget, bitcmp, bitshift, bitmax


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="bitcmp" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  bitcmp (A, K)
     Return the K-bit complement of integers in A.  If K is omitted 'k
     = log2 (bitmax) + 1' is assumed.

          bitcmp (7,4)
            => 8
          dec2bin (11)
            => 1011
          dec2bin (bitcmp (11, 6))
            => 110100

     See also: bitand, bitor, bitxor, bitset, bitget, bitcmp, bitshift,
     bitmax


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="bitget" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: C = bitget (A, N)
     Return the status of bit(s) N of unsigned integers in A the lowest
     significant bit is N = 1.

          bitget (100, 8:-1:1)
          => 0  1  1  0  0  1  0  0

     See also: bitand, bitor, bitxor, bitset, bitcmp, bitshift, bitmax


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="bitmax" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  bitmax ()
 -- Built-in Function:  bitmax ('double')
 -- Built-in Function:  bitmax ('single')
     Return the largest integer that can be represented within a
     floating point value.  The default class is 'double', but 'single'
     is a valid option.  On IEEE-754 compatible systems, 'bitmax' is
     2^53 - 1.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="bitor" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  bitor (X, Y)
     Return the bitwise OR of non-negative integers.  X, Y must be in
     the range [0,bitmax]

     See also: bitor, bitxor, bitset, bitget, bitcmp, bitshift, bitmax


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="bitpack" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: Y = bitpack (X, CLASS)
     Return a new array Y resulting from interpreting an array X as raw
     bit patterns for data of the numeric class CLASS.  CLASS must be
     one of the built-in numeric classes:

           'char'
           'int8'
           'int16'
           'int32'
           'int64'
           'uint8'
           'uint16'
           'uint32'
           'uint64'
           'double'
           'single'

     The number of elements of X should be divisible by the bit length
     of CLASS.  If it is not, excess bits are discarded.  Bits come in
     increasing order of significance, i.e., 'x(1)' is bit 0, 'x(2)' is
     bit 1, etc.  The result is a row vector if X is a row vector,
     otherwise it is a column vector.

     See also: bitunpack, typecast


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="bitset" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: C = bitset (A, N)
 -- Function File: C = bitset (A, N, VAL)
     Set or reset bit(s) N of unsigned integers in A.  VAL = 0 resets
     and VAL = 1 sets the bits.  The lowest significant bit is: N = 1

          dec2bin (bitset (10, 1))
            => 1011

     See also: bitand, bitor, bitxor, bitget, bitcmp, bitshift, bitmax


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="bitshift" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  bitshift (A, K)
 -- Built-in Function:  bitshift (A, K, N)
     Return a K bit shift of N-digit unsigned integers in A.  A
     positive K leads to a left shift; A negative value to a right
     shift.  If N is omitted it defaults to log2(bitmax)+1.  N must be
     in the range [1,log2(bitmax)+1] usually [1,33].

          bitshift (eye (3), 1)
          =>
          2 0 0
          0 2 0
          0 0 2

          bitshift (10, [-2, -1, 0, 1, 2])
          => 2   5  10  20  40

     See also: bitand, bitor, bitxor, bitset, bitget, bitcmp, bitmax


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="bitunpack" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: Y = bitunpack (X)
     Return an array Y corresponding to the raw bit patterns of X.  X
     must belong to one of the built-in numeric classes:

           'char'
           'int8'
           'int16'
           'int32'
           'int64'
           'uint8'
           'uint16'
           'uint32'
           'uint64'
           'double'
           'single'

     The result is a row vector if X is a row vector; otherwise, it is a
     column vector.

     See also: bitpack, typecast


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="bitxor" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  bitxor (X, Y)
     Return the bitwise XOR of non-negative integers.  X, Y must be in
     the range [0,bitmax]

     See also: bitand, bitor, bitset, bitget, bitcmp, bitshift, bitmax


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="blackman" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  blackman (M)
     Return the filter coefficients of a Blackman window of length M.

     For a definition of the Blackman window, see e.g., A. V. Oppenheim
     &amp; R. W. Schafer, 'Discrete-Time Signal Processing'.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="blanks" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  blanks (N)
     Return a string of N blanks, for example:

          blanks (10);
          whos ans;
               =>
                Attr Name        Size                     Bytes  Class
                ==== ====        ====                     =====  =====
                     ans         1x10                        10  char

     See also: repmat


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="blkdiag" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  blkdiag (A, B, C, ...)
     Build a block diagonal matrix from A, B, C, ...  All the arguments
     must be numeric and are two-dimensional matrices or scalars.  If
     any argument is of type sparse, the output will also be sparse.

     See also: diag, horzcat, vertcat, sparse


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="blkmm" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function:  blkmm (A, B)
     Compute products of matrix blocks.  The blocks are given as
     2-dimensional subarrays of the arrays A, B.  The size of A must
     have the form '[m,k,...]' and size of B must be '[k,n,...]'.  The
     result is then of size '[m,n,...]' and is computed as follows:

           for i = 1:prod (size (A)(3:end))
             C(:,:,i) = A(:,:,i) * B(:,:,i)
           endfor

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="BMWengine" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: SYS = BMWengine ()
 -- Function File: SYS = BMWengine ('SCALED')
 -- Function File: SYS = BMWengine ('UNSCALED')
     Model of the BMW 4-cylinder engine at ETH Zurich's control
     laboratory.
          OPERATING POINT
          Drosselklappenstellung     alpha_DK = 10.3 Grad
          Saugrohrdruck              p_s = 0.48 bar
          Motordrehzahl              n = 860 U/min
          Lambda-Messwert            lambda = 1.000
          Relativer Wandfilminhalt   nu = 1

          INPUTS
          U_1 Sollsignal Drosselklappenstellung   [Grad]
          U_2 Relative Einspritzmenge             [-]
          U_3 Zuendzeitpunkt                      [Grad KW]
          M_L Lastdrehmoment                      [Nm]

          STATES
          X_1 Drosselklappenstellung     [Grad]
          X_2 Saugrohrdruck              [bar]
          X_3 Motordrehzahl              [U/min]
          X_4 Messwert Lamba-Sonde       [-]
          X_5 Relativer Wandfilminhalt   [-]

       ...

     USE help BMWengine FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="bode" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [MAG, PHA, W] = bode (SYS)
 -- Function File: [MAG, PHA, W] = bode (SYS, W)
     Bode diagram of frequency response.  If no output arguments are
     given, the response is printed on the screen.

     *Inputs*
    SYS
          LTI system.  Must be a single-input and single-output (SISO)
          system.

    W
          Optional vector of frequency values.  If W is not specified,
          it is calculated by the zeros and poles of the system.
          Alternatively, the cell '{wmin, wmax}' specifies a frequency
          range, where WMIN and WMAX denote minimum and maximum
          frequencies in rad/s.

     *Outputs*
    MAG
          Vector of magnitude.  Has length of frequency vector W.

    PHA
          Vector of phase.  Has length of frequency vector W.

    W
          Vector of frequency values used.

     See also: nichols, nyquist, sigma


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="bodemag" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [MAG, W] = bodemag (SYS)
 -- Function File: [MAG, W] = bodemag (SYS, W)
     Bode magnitude diagram of frequency response.  If no output
     arguments are given, the response is printed on the screen.

     *Inputs*
    SYS
          LTI system.  Must be a single-input and single-output (SISO)
          system.

    W
          Optional vector of frequency values.  If W is not specified,
          it is calculated by the zeros and poles of the system.
          Alternatively, the cell '{wmin, wmax}' specifies a frequency
          range, where WMIN and WMAX denote minimum and maximum
          frequencies in rad/s.

     *Outputs*
    MAG
          Vector of magnitude.  Has length of frequency vector W.

    W
          Vector of frequency values used.

     See also: bode, nichols, nyquist, sigma


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="Boeing707" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: SYS = Boeing707 ()
     Creates a linearized state-space model of a Boeing 707-321 aircraft
     at V=80 m/s (M = 0.26, GA0 = -3 deg, ALPHA0 = 4 deg, KAPPA = 50
     deg).

     System inputs: (1) thrust and (2) elevator angle.

     System outputs:  (1) airspeed and (2) pitch angle.

     *Reference*: R. Brockhaus: 'Flugregelung' (Flight Control),
     Springer, 1994.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="bone" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: MAP = bone ()
 -- Function File: MAP = bone (N)
     Create color colormap.  This colormap varies from black to white
     with gray-blue shades.  The argument N must be a scalar.  If
     unspecified, the length of the current colormap, or 64, is used.

     See also: colormap


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="box" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  box (ARG)
 -- Function File:  box (H, ...)
     Control the display of a border around the plot.  The argument may
     be either &quot;on&quot; or &quot;off&quot;.  If it is omitted, the current box
     state is toggled.

     See also: grid


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="brighten" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: MAP_OUT = brighten (MAP, BETA)
 -- Function File: MAP_OUT = brighten (H, BETA)
 -- Function File: MAP_OUT = brighten (BETA)
     Darken or brighten the given colormap.  If the MAP argument is
     omitted, the function is applied to the current colormap.  The
     first argument can also be a valid graphics handle H, in which case
     'brighten' is applied to the colormap associated with this handle.

     Should the resulting colormap MAP_OUT not be assigned, it will be
     written to the current colormap.

     The argument BETA should be a scalar between -1 and 1, where a
     negative value darkens and a positive value brightens the colormap.

     See also: colormap


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="bstmodred" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [GR, INFO] = bstmodred (G, ...)
 -- Function File: [GR, INFO] = bstmodred (G, NR, ...)
 -- Function File: [GR, INFO] = bstmodred (G, OPT, ...)
 -- Function File: [GR, INFO] = bstmodred (G, NR, OPT, ...)
     Model order reduction by Balanced Stochastic Truncation (BST)
     method.  The aim of model reduction is to find an LTI system GR of
     order NR (nr &lt; n) such that the input-output behaviour of GR
     approximates the one from original system G.

     BST is a relative error method which tries to minimize
             -1
          ||G  (G-Gr)||    = min
                       inf

     *Inputs*
    G
          LTI model to be reduced.

    NR
          The desired order of the resulting reduced order system GR.
          If not specified, NR is chosen automatically according to the
          description of key 'ORDER'.

    ...
          Optional pairs of keys and values.  &quot;key1', value1, 'key2',
          value2'.

    OPT
          Optional struct with key...

     USE help bstmodred FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="bsxfun" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function:  bsxfun (F, A, B)
     The binary singleton expansion function applier performs
     broadcasting, that is, applies a binary function F
     element-by-element to two array arguments A and B, and expands as
     necessary singleton dimensions in either input argument.  F is a
     function handle, inline function, or string containing the name of
     the function to evaluate.  The function F must be capable of
     accepting two column-vector arguments of equal length, or one
     column vector argument and a scalar.

     The dimensions of A and B must be equal or singleton.  The
     singleton dimensions of the arrays will be expanded to the same
     dimensionality as the other array.

     See also: arrayfun, cellfun


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="btaconred" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [KR, INFO] = btaconred (G, K, ...)
 -- Function File: [KR, INFO] = btaconred (G, K, NCR, ...)
 -- Function File: [KR, INFO] = btaconred (G, K, OPT, ...)
 -- Function File: [KR, INFO] = btaconred (G, K, NCR, OPT, ...)
     Controller reduction by frequency-weighted Balanced Truncation
     Approximation (BTA).  Given a plant G and a stabilizing controller
     K, determine a reduced order controller KR such that the
     closed-loop system is stable and closed-loop performance is
     retained.

     The algorithm tries to minimize the frequency-weighted error
          ||V (K-Kr) W||    = min
                        inf
     where V and W denote output and input weightings.

     *Inputs*
    G
          LTI model of the plant.  It has m inputs, p outputs and n
          states.

    K
          LTI model of the controller.  It has p inputs, m outputs and
          nc states.

    NCR
          The desired order of the resulting reduced order controller
          KR....

     USE help btaconred FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="btamodred" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [GR, INFO] = btamodred (G, ...)
 -- Function File: [GR, INFO] = btamodred (G, NR, ...)
 -- Function File: [GR, INFO] = btamodred (G, OPT, ...)
 -- Function File: [GR, INFO] = btamodred (G, NR, OPT, ...)
     Model order reduction by frequency weighted Balanced Truncation
     Approximation (BTA) method.  The aim of model reduction is to find
     an LTI system GR of order NR (nr &lt; n) such that the input-output
     behaviour of GR approximates the one from original system G.

     BTA is an absolute error method which tries to minimize
          ||G-Gr||    = min
                  inf

          ||V (G-Gr) W||    = min
                        inf
     where V and W denote output and input weightings.

     *Inputs*
    G
          LTI model to be reduced.

    NR
          The desired order of the resulting reduced order system GR.
          If not specified, NR is chosen automatically according to the
          description of key 'ORDER'.

    ...
          Optional...

     USE help btamodred FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="builtin" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: [...] builtin (F, ...)
     Call the base function F even if F is overloaded to another
     function for the given type signature.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="bunzip2" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  bunzip2 (BZFILE)
 -- Function File:  bunzip2 (BZFILE, DIR)
     Unpack the bzip2 archive BZFILE to the directory DIR.  If DIR is
     not specified, it defaults to the current directory.

     See also: bzip2, unpack, gunzip, unzip, untar


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="bzip2" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: ENTRIES = bzip2 (FILES)
 -- Function File: ENTRIES = bzip2 (FILES, OUTDIR)
     Compress the list of files specified in FILES.  Each file is
     compressed separately and a new file with a '.bz2' extension is
     created.  The original files are not modified.  Existing
     compressed files are silently overwritten.  If OUTDIR is defined
     the compressed files are placed in this directory.

     See also: bunzip2, gzip, zip, tar


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="calendar" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: C = calendar ()
 -- Function File: C = calendar (D)
 -- Function File: C = calendar (Y, M)
 -- Function File:  calendar (...)
     Return the current monthly calendar in a 6x7 matrix.

     If D is specified, return the calendar for the month containing
     the date D, which must be a serial date number or a date string.

     If Y and M are specified, return the calendar for year Y and month
     M.

     If no output arguments are specified, print the calendar on the
     screen instead of returning a matrix.

     See also: datenum, datestr


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="canonicalize_file_name" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: [CNAME, STATUS, MSG] canonicalize_file_name
          (NAME)
     Return the canonical name of file NAME.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="care" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [X, L, G] = care (A, B, Q, R)
 -- Function File: [X, L, G] = care (A, B, Q, R, S)
 -- Function File: [X, L, G] = care (A, B, Q, R, [], E)
 -- Function File: [X, L, G] = care (A, B, Q, R, S, E)
     Solve continuous-time algebraic Riccati equation (ARE).

     *Inputs*
    A
          Real matrix (n-by-n).

    B
          Real matrix (n-by-m).

    Q
          Real matrix (n-by-n).

    R
          Real matrix (m-by-m).

    S
          Optional real matrix (n-by-m).  If S is not specified, a zero
          matrix is assumed.

    E
          Optional descriptor matrix (n-by-n).  If E is not specified,
          an identity matrix is assumed.

     *Outputs*
    X
          Unique stabilizing solution of the continuous-time Riccati
          equation (n-by-n).

    L
          Closed-loop poles (n-by-1).

    G
          Corresponding gain matrix (m-by-n).

     *Equations*
                         -1
          A'X + XA - XB R  B'X + Q = 0

                          ...

     USE help care FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="cart2pol" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [THETA, R] = cart2pol (X, Y)
 -- Function File: [THETA, R, Z] = cart2pol (X, Y, Z)
 -- Function File: [THETA, R] = cart2pol (C)
 -- Function File: [THETA, R, Z] = cart2pol (C)
 -- Function File: P = cart2pol (...)
     Transform Cartesian to polar or cylindrical coordinates.

     THETA describes the angle relative to the positive x-axis.  R is
     the distance to the z-axis (0, 0, z).  X, Y (and Z) must be the
     same shape, or scalar.  If called with a single matrix argument
     then each row of C represents the Cartesian coordinate (X, Y (,
     Z)).

     If only a single return argument is requested then return a matrix
     P where each row represents one polar/(cylindrical) coordinate
     (THETA, PHI (, Z)).

     See also: pol2cart, cart2sph, sph2cart


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="cart2sph" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [THETA, PHI, R] = cart2sph (X, Y, Z)
 -- Function File: [THETA, PHI, R] = cart2sph (C)
 -- Function File: S = cart2sph (...)
     Transform Cartesian to spherical coordinates.

     THETA describes the angle relative to the positive x-axis.  PHI is
     the angle relative to the xy-plane.  R is the distance to the
     origin (0, 0, 0).  X, Y, and Z must be the same shape, or scalar.
     If called with a single matrix argument then each row of C
     represents the Cartesian coordinate (X, Y, Z).

     If only a single return argument is requested then return a matrix
     S where each row represents one spherical coordinate (THETA, PHI,
     R).

     See also: sph2cart, cart2pol, pol2cart


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="cast" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  cast (VAL, TYPE)
     Convert VAL to data type TYPE.

     See also: int8, uint8, int16, uint16, int32, uint32, int64,
     uint64, double


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="cat" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  cat (DIM, ARRAY1, ARRAY2, ..., ARRAYN)
     Return the concatenation of N-D array objects, ARRAY1, ARRAY2,
     ..., ARRAYN along dimension DIM.

          A = ones (2, 2);
          B = zeros (2, 2);
          cat (2, A, B)
             => 1 1 0 0
                1 1 0 0

     Alternatively, we can concatenate A and B along the second
     dimension the following way:

          [A, B].

     DIM can be larger than the dimensions of the N-D array objects and
     the result will thus have DIM dimensions as the following example
     shows:

          cat (4, ones (2, 2), zeros (2, 2))
             => ans =

                ans(:,:,1,1) =

                  1 1
                  1 1

                ans(:,:,1,2) =
                  0 0
                  0 0

     See also: horzcat, vertcat


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="cauchy_cdf" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  cauchy_cdf (X)
 -- Function File:  cauchy_cdf (X, LOCATION, SCALE)
     For each element of X, compute the cumulative distribution
     function (CDF) at X of the Cauchy distribution with location
     parameter LOCATION and scale parameter SCALE.  Default values are
     LOCATION = 0, SCALE = 1.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="cauchy_inv" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  cauchy_inv (X)
 -- Function File:  cauchy_inv (X, LOCATION, SCALE)
     For each element of X, compute the quantile (the inverse of the
     CDF) at X of the Cauchy distribution with location parameter
     LOCATION and scale parameter SCALE.  Default values are LOCATION =
     0, SCALE = 1.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="cauchy_pdf" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  cauchy_pdf (X)
 -- Function File:  cauchy_pdf (X, LOCATION, SCALE)
     For each element of X, compute the probability density function
     (PDF) at X of the Cauchy distribution with location parameter
     LOCATION and scale parameter SCALE &gt; 0.  Default values are
     LOCATION = 0, SCALE = 1.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="cauchy_rnd" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  cauchy_rnd (LOCATION, SCALE)
 -- Function File:  cauchy_rnd (LOCATION, SCALE, R)
 -- Function File:  cauchy_rnd (LOCATION, SCALE, R, C, ...)
 -- Function File:  cauchy_rnd (LOCATION, SCALE, [SZ])
     Return a matrix of random samples from the Cauchy distribution with
     parameters LOCATION and SCALE.

     When called with a single size argument, return a square matrix
     with the dimension specified.  When called with more than one
     scalar argument the first two arguments are taken as the number of
     rows and columns and any further arguments specify additional
     matrix dimensions.  The size may also be specified with a vector
     of dimensions SZ.

     If no size arguments are given then the result matrix is the
     common size of LOCATION and SCALE.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="caxis" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  caxis (LIMITS)
 -- Function File:  caxis (H, ...)
     Set color axis limits for plots.

     The argument LIMITS should be a 2-element vector specifying the
     lower and upper limits to assign to the first and last value in the
     colormap.  Values outside this range are clamped to the first and
     last colormap entries.

     If LIMITS is 'auto', then automatic colormap scaling is applied,
     whereas if LIMITS is 'manual' the colormap scaling is set to
     manual.

     Called without any arguments to current color axis limits are
     returned.

     If an axes handle is passed as the first argument, then operate on
     this axes rather than the current axes.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="cbrt" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  cbrt (X)
     Compute the real cube root of each element of X.  Unlike
     'X^(1/3)', the result will be negative if X is negative.

     See also: nthroot


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="ccolamd" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: P = ccolamd (S)
 -- Loadable Function: P = ccolamd (S, KNOBS)
 -- Loadable Function: P = ccolamd (S, KNOBS, CMEMBER)
 -- Loadable Function: [P, STATS] = ccolamd (...)
     Constrained column approximate minimum degree permutation.  'P =
     ccolamd (S)' returns the column approximate minimum degree
     permutation vector for the sparse matrix S.  For a non-symmetric
     matrix S, 'S(:, P)' tends to have sparser LU factors than S.
     'chol (S(:, P)' * S(:, P))' also tends to be sparser than 'chol
     (S' * S)'.  'P = ccolamd (S, 1)' optimizes the ordering for 'lu
     (S(:, P))'.  The ordering is followed by a column elimination tree
     post-ordering.

     KNOBS is an optional 1-element to 5-element input vector, with a
     default value of '[0 10 10 1 0]' if not present or empty.  Entries
     not present are set to their defaults.

    'KNOBS(1)'
          if nonzero, the ordering is optimized for 'lu (S(:, p))'.  It
          will be a poor ordering f...

     USE help ccolamd FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="cd" func="yes">
            <Overload retVal="">
                <Param name="
 -- Command:  cd dir
 -- Command:  chdir dir
     Change the current working directory to DIR.  If DIR is omitted,
     the current directory is changed to the user's home directory.
     For example,

          cd ~/octave

     changes the current working directory to '~/octave'.  If the
     directory does not exist, an error message is printed and the
     working directory is not changed.

     See also: mkdir, rmdir, dir


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="ceil" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  ceil (X)
     Return the smallest integer not less than X.  This is equivalent to
     rounding towards positive infinity.  If X is complex, return 'ceil
     (real (X)) + ceil (imag (X)) * I'.

          ceil ([-2.7, 2.7])
            =>  -2   3

     See also: floor, round, fix


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="cell" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  cell (N)
 -- Built-in Function:  cell (M, N)
 -- Built-in Function:  cell (M, N, K, ...)
 -- Built-in Function:  cell ([M N ...])
     Create a new cell array object.  If invoked with a single scalar
     integer argument, return a square NxN cell array.  If invoked with
     two or more scalar integer arguments, or a vector of integer
     values, return an array with the given dimensions.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="cell2mat" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: M = cell2mat (C)
     Convert the cell array C into a matrix by concatenating all
     elements of C into a hyperrectangle.  Elements of C must be
     numeric, logical or char matrices, or cell arrays, and 'cat' must
     be able to concatenate them together.

     See also: mat2cell, num2cell


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="cell2struct" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  cell2struct (CELL, FIELDS, DIM)
     Convert CELL to a structure.  The number of fields in FIELDS must
     match the number of elements in CELL along dimension DIM, that is
     'numel (FIELDS) == size (CELL, DIM)'.  If DIM is omitted, a value
     of 1 is assumed.

          A = cell2struct ({'Peter', 'Hannah', 'Robert';
                            185, 170, 168},
                          {'Name','Height'}, 1);
          A(1)
              => ans =
                 {
                   Name   = Peter
                   Height = 185
                 }

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="celldisp" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  celldisp (C, NAME)
     Recursively display the contents of a cell array.  By default the
     values are displayed with the name of the variable C.  However,
     this name can be replaced with the variable NAME.  For example:

          c = {1, 2, {31, 32}};
          celldisp (c, 'b')
             =>
                b{1} =
                 1
                b{2} =
                 2
                b{3}{1} =
                 31
                b{3}{2} =
                 32

     See also: disp


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="cellfun" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function:  cellfun (NAME, C)
 -- Loadable Function:  cellfun ('size', C, K)
 -- Loadable Function:  cellfun ('isclass', C, CLASS)
 -- Loadable Function:  cellfun (FUNC, C)
 -- Loadable Function:  cellfun (FUNC, C, D)
 -- Loadable Function: [A, ...] = cellfun (...)
 -- Loadable Function:  cellfun (..., 'ErrorHandler', ERRFUNC)
 -- Loadable Function:  cellfun (..., 'UniformOutput', VAL)
     Evaluate the function named NAME on the elements of the cell array
     C.  Elements in C are passed on to the named function
     individually.  The function NAME can be one of the functions

    'isempty'
          Return 1 for empty elements.

    'islogical'
          Return 1 for logical elements.

    'isreal'
          Return 1 for real elements.

    'length'
          Return a vector of the lengths of cell elements.

    'ndims'
          Return the number of dimensions of each element.

    'numel'
    'prodofsize'
          Return the number of elements contained within each c...

     USE help cellfun FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="cellindexmat" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: Y = cellindexmat (X, VARARGIN)
     Given a cell array of matrices X, this function computes

           Y = cell (size (X));
           for i = 1:numel (X)
             Y{i} = X{i}(varargin{:});
           endfor

     See also: cellslices, cellfun


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="cellslices" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: SL = cellslices (X, LB, UB, DIM)
     Given an array X, this function produces a cell array of slices
     from the array determined by the index vectors LB, UB, for lower
     and upper bounds, respectively.  In other words, it is equivalent
     to the following code:

          n = length (lb);
          sl = cell (1, n);
          for i = 1:length (lb)
           sl{i} = x(:,...,lb(i):ub(i),...,:);
          endfor

     The position of the index is determined by DIM.  If not specified,
     slicing is done along the first non-singleton dimension.

     See also: cell2mat, cellindexmat, cellfun


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="cellstr" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  cellstr (STRING)
     Create a new cell array object from the elements of the string
     array STRING.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="center" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  center (X)
 -- Function File:  center (X, DIM)
     If X is a vector, subtract its mean.  If X is a matrix, do the
     above for each column.  If the optional argument DIM is given,
     operate along this dimension.

     See also: zscore


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="cfconred" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [KR, INFO] = cfconred (G, F, L, ...)
 -- Function File: [KR, INFO] = cfconred (G, F, L, NCR, ...)
 -- Function File: [KR, INFO] = cfconred (G, F, L, OPT, ...)
 -- Function File: [KR, INFO] = cfconred (G, F, L, NCR, OPT, ...)
     Reduction of state-feedback-observer based controller by coprime
     factorization (CF).  Given a plant G, state feedback gain F and
     full observer gain L, determine a reduced order controller KR.

     *Inputs*
    G
          LTI model of the open-loop plant (A,B,C,D).  It has m inputs,
          p outputs and n states.

    F
          Stabilizing state feedback matrix (m-by-n).

    L
          Stabilizing observer gain matrix (n-by-p).

    NCR
          The desired order of the resulting reduced order controller
          KR.  If not specified, NCR is chosen automatically according
          to the description of key 'ORDER'.

    ...
          Optional pairs of keys and values.  &quot;key1', value1, 'key2',
          value2'.

    OP...

     USE help cfconred FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="cgs" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: X = cgs (A, B, RTOL, MAXIT, M1, M2, X0)
 -- Function File: X = cgs (A, B, RTOL, MAXIT, P)
 -- Function File: [X, FLAG, RELRES, ITER, RESVEC] = cgs (A, B, ...)
     Solve 'A x = b', where A is a square matrix, using the Conjugate
     Gradients Squared method.

        - RTOL is the relative tolerance, if not given or set to [] the
          default value 1e-6 is used.

        - MAXIT the maximum number of outer iterations, if not given or
          set to [] the default value 'min (20, numel (b))' is used.

        - X0 the initial guess, if not given or set to [] the default
          value 'zeros (size (b))' is used.

     A can be passed as a matrix or as a function handle or inline
     function 'f' such that 'f(x) = A*x'.

     The preconditioner P is given as 'P = M1 * M2'.  Both M1 and M2
     can be passed as a matrix or as a function handle or inline
     function 'g' such that 'g(x) = M1 \ x' or 'g(x) = M2 \ x'.

     If called with more than one output pa...

     USE help cgs FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="char" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  char (X)
 -- Built-in Function:  char (X, ...)
 -- Built-in Function:  char (S1, S2, ...)
 -- Built-in Function:  char (CELL_ARRAY)
     Create a string array from one or more numeric matrices, character
     matrices, or cell arrays.  Arguments are concatenated vertically.
     The returned values are padded with blanks as needed to make each
     row of the string array have the same length.  Empty input strings
     are significant and will concatenated in the output.

     For numerical input, each element is converted to the
     corresponding ASCII character.  A range error results if an input
     is outside the ASCII range (0-255).

     For cell arrays, each element is concatenated separately.  Cell
     arrays converted through 'char' can mostly be converted back with
     'cellstr'.  For example:

          char ([97, 98, 99], &quot;, {'98', '99', 100}, 'str1', ['ha', 'lf'])
              => ['abc    '
                  '       '
                  '98    ...

     USE help char FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="chi2cdf" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  chi2cdf (X, N)
     For each element of X, compute the cumulative distribution
     function (CDF) at X of the chi-square distribution with N degrees
     of freedom.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="chi2inv" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  chi2inv (X, N)
     For each element of X, compute the quantile (the inverse of the
     CDF) at X of the chi-square distribution with N degrees of freedom.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="chi2pdf" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  chi2pdf (X, N)
     For each element of X, compute the probability density function
     (PDF) at X of the chi-square distribution with N degrees of
     freedom.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="chi2rnd" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  chi2rnd (N)
 -- Function File:  chi2rnd (N, R)
 -- Function File:  chi2rnd (N, R, C, ...)
 -- Function File:  chi2rnd (N, [SZ])
     Return a matrix of random samples from the chi-square distribution
     with N degrees of freedom.

     When called with a single size argument, return a square matrix
     with the dimension specified.  When called with more than one
     scalar argument the first two arguments are taken as the number of
     rows and columns and any further arguments specify additional
     matrix dimensions.  The size may also be specified with a vector
     of dimensions SZ.

     If no size arguments are given then the result matrix is the size
     of N.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="chisquare_test_homogeneity" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [PVAL, CHISQ, DF] = chisquare_test_homogeneity (X,
          Y, C)
     Given two samples X and Y, perform a chisquare test for
     homogeneity of the null hypothesis that X and Y come from the same
     distribution, based on the partition induced by the (strictly
     increasing) entries of C.

     For large samples, the test statistic CHISQ approximately follows a
     chisquare distribution with DF = 'length (C)' degrees of freedom.

     The p-value (1 minus the CDF of this distribution at CHISQ) is
     returned in PVAL.

     If no output argument is given, the p-value is displayed.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="chisquare_test_independence" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [PVAL, CHISQ, DF] = chisquare_test_independence (X)
     Perform a chi-square test for independence based on the contingency
     table X.  Under the null hypothesis of independence, CHISQ
     approximately has a chi-square distribution with DF degrees of
     freedom.

     The p-value (1 minus the CDF of this distribution at chisq) of the
     test is returned in PVAL.

     If no output argument is given, the p-value is displayed.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="chol" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: R = chol (A)
 -- Loadable Function: [R, P] = chol (A)
 -- Loadable Function: [R, P, Q] = chol (S)
 -- Loadable Function: [R, P, Q] = chol (S, 'vector')
 -- Loadable Function: [L, ...] = chol (..., 'lower')
 -- Loadable Function: [L, ...] = chol (..., 'upper')
     Compute the Cholesky factor, R, of the symmetric positive definite
     matrix A, where

          R' * R = A.

     Called with one output argument 'chol' fails if A or S is not
     positive definite.  With two or more output arguments P flags
     whether the matrix was positive definite and 'chol' does not fail.
     A zero value indicated that the matrix was positive definite and
     the R gives the factorization, and P will have a positive value
     otherwise.

     If called with 3 outputs then a sparsity preserving row/column
     permutation is applied to A prior to the factorization.  That is R
     is the factorization of 'A(Q,Q)' such that

          R' * R = Q' * A * Q.

     The sparsity...

     USE help chol FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="chol2inv" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function:  chol2inv (U)
     Invert a symmetric, positive definite square matrix from its
     Cholesky decomposition, U.  Note that U should be an
     upper-triangular matrix with positive diagonal elements.
     'chol2inv (U)' provides 'inv (U'*U)' but it is much faster than
     using 'inv'.

     See also: chol, cholinv, inv


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="choldelete" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: R1 = choldelete (R, J)
     Given a Cholesky factorization of a real symmetric or complex
     Hermitian positive definite matrix A = R'*R, R upper triangular,
     return the Cholesky factorization of A(p,p), where
     p = [1:j-1,j+1:n+1].

     See also: chol, cholupdate, cholinsert


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="cholinsert" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: R1 = cholinsert (R, J, U)
 -- Loadable Function: [R1, INFO] = cholinsert (R, J, U)
     Given a Cholesky factorization of a real symmetric or complex
     Hermitian positive definite matrix A = R'*R, R upper triangular,
     return the Cholesky factorization of A1, where A1(p,p) = A,
     A1(:,j) = A1(j,:)' = u and p = [1:j-1,j+1:n+1].  u(j) should be
     positive.  On return, INFO is set to
        * 0 if the insertion was successful,

        * 1 if A1 is not positive definite,

        * 2 if R is singular.

     If INFO is not present, an error message is printed in cases 1 and
     2.

     See also: chol, cholupdate, choldelete


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="cholinv" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function:  cholinv (A)
     Use the Cholesky factorization to compute the inverse of the
     symmetric positive definite matrix A.

     See also: chol, chol2inv, inv


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="cholshift" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: R1 = cholshift (R, I, J)
     Given a Cholesky factorization of a real symmetric or complex
     Hermitian positive definite matrix A = R'*R, R upper triangular,
     return the Cholesky factorization of A(p,p), where p is the
     permutation
     'p = [1:i-1, shift(i:j, 1), j+1:n]' if I &lt; J
     or
     'p = [1:j-1, shift(j:i,-1), i+1:n]' if J %lt I.
     See also: chol, cholinsert, choldelete


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="cholupdate" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: [R1, INFO] = cholupdate (R, U, OP)
     Update or downdate a Cholesky factorization.  Given an upper
     triangular matrix R and a column vector U, attempt to determine
     another upper triangular matrix R1 such that
        * R1'*R1 = R'*R + U*U' if OP is '+'

        * R1'*R1 = R'*R - U*U' if OP is '-'

     If OP is '-', INFO is set to
        * 0 if the downdate was successful,

        * 1 if R'*R - U*U' is not positive definite,

        * 2 if R is singular.

     If INFO is not present, an error message is printed in cases 1 and
     2.

     See also: chol, qrupdate


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="chop" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  chop (X, NDIGITS, BASE)
     Truncate elements of X to a length of NDIGITS such that the
     resulting numbers are exactly divisible by BASE.  If BASE is not
     specified it defaults to 10.

          chop (-pi, 5, 10)
             => -3.14200000000000
          chop (-pi, 5, 5)
             => -3.14150000000000

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="circshift" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: Y = circshift (X, N)
     Circularly shift the values of the array X.  N must be a vector of
     integers no longer than the number of dimensions in X.  The values
     of N can be either positive or negative, which determines the
     direction in which the values or X are shifted.  If an element of
     N is zero, then the corresponding dimension of X will not be
     shifted.  For example:

          x = [1, 2, 3; 4, 5, 6; 7, 8, 9];
          circshift (x, 1)
          =>  7, 8, 9
              1, 2, 3
              4, 5, 6
          circshift (x, -2)
          =>  7, 8, 9
              1, 2, 3
              4, 5, 6
          circshift (x, [0,1])
          =>  3, 1, 2
              6, 4, 5
              9, 7, 8

     See also: permute, ipermute, shiftdim


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="cla" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  cla ()
 -- Function File:  cla ('reset')
 -- Function File:  cla (HAX)
 -- Function File:  cla (HAX, 'reset')
     Delete the children of the current axes with visible handles.  If
     HAX is specified and is an axes object handle, operate on it
     instead of the current axes.  If the optional argument &quot;reset&quot;
     is specified, also delete the children with hidden handles.

     See also: clf


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="clabel" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  clabel (C, H)
 -- Function File:  clabel (C, H, V)
 -- Function File:  clabel (C, H, 'manual')
 -- Function File:  clabel (C)
 -- Function File:  clabel (C, H)
 -- Function File:  clabel (..., PROP, VAL, ...)
 -- Function File: H = clabel (...)
     Add labels to the contours of a contour plot.  The contour plot is
     specified by the contour matrix C and optionally the contourgroup
     object H that are returned by 'contour', 'contourf' and 'contour3'.
     The contour labels are rotated and placed in the contour itself.

     By default, all contours are labeled.  However, the contours to
     label can be specified by the vector V.  If the 'manual' argument
     is given then the contours to label can be selected with the mouse.

     Additional property/value pairs that are valid properties of text
     objects can be given and are passed to the underlying text
     objects.  Additionally, the property 'LabelSpacing' is available
     allowing the spacing bet...

     USE help clabel FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="class" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  class (EXPR)
 -- Built-in Function:  class (S, ID)
 -- Built-in Function:  class (S, ID, P, ...)
     Return the class of the expression EXPR or create a class with
     fields from structure S and name (string) ID.  Additional
     arguments name a list of parent classes from which the new class is
     derived.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="clc" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  clc ()
 -- Built-in Function:  home ()
     Clear the terminal screen and move the cursor to the upper left
     corner.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="clear" func="yes">
            <Overload retVal="">
                <Param name="
 -- Command:  clear [options] pattern ...
     Delete the names matching the given patterns from the symbol
     table.  The pattern may contain the following special characters:

    '?'
          Match any single character.

    '*'
          Match zero or more characters.

    '[ LIST ]'
          Match the list of characters specified by LIST.  If the first
          character is '!' or '^', match all characters except those
          specified by LIST.  For example, the pattern '[a-zA-Z]' will
          match all lowercase and uppercase alphabetic characters.

     For example, the command

          clear foo b*r

     clears the name 'foo' and all names that begin with the letter 'b'
     and end with the letter 'r'.

     If 'clear' is called without any arguments, all user-defined
     variables (local and global) are cleared from the symbol table.  If
     'clear' is called with at least one argument, only the visible
     names matching the arguments are cleared.  For exampl...

     USE help clear FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="clf" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  clf ()
 -- Function File:  clf ('reset')
 -- Function File:  clf (HFIG)
 -- Function File:  clf (HFIG, 'reset')
 -- Function File: H = clf (...)
     Clear the current figure window.  'clf' operates by deleting child
     graphics objects with visible handles ('handlevisibility' = on).
     If HFIG is specified operate on it instead of the current figure.
     If the optional argument &quot;reset&quot; is specified, all objects
     including those with hidden handles are deleted.

     The optional return value H is the graphics handle of the figure
     window that was cleared.

     See also: cla, close, delete


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="clock" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  clock ()
     Return the current local date and time as a date vector.  The date
     vector contains the following fields: current year, month (1-12),
     day (1-31), hour (0-23), minute (0-59), and second (0-61).  The
     seconds field has a fractional part after the decimal point for
     extended accuracy.

     For example:

          fix (clock ())
               => [ 1993, 8, 20, 4, 56, 1 ]

     The function clock is more accurate on systems that have the
     'gettimeofday' function.

     See also: now, date, datevec


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="cloglog" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  cloglog (X)
     Return the complementary log-log function of X, defined as

          cloglog (x) = - log (- log (X))


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="close" func="yes">
            <Overload retVal="">
                <Param name="
 -- Command:  close
 -- Command:  close (N)
 -- Command:  close all
 -- Command:  close all hidden
     Close figure window(s) by calling the function specified by the
     &quot;closerequestfcn&quot; property for each figure.  By default, the
     function 'closereq' is used.

     See also: closereq


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="closereq" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  closereq ()
     Close the current figure and delete all graphics objects associated
     with it.

     See also: close, delete


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="colamd" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: P = colamd (S)
 -- Loadable Function: P = colamd (S, KNOBS)
 -- Loadable Function: [P, STATS] = colamd (S)
 -- Loadable Function: [P, STATS] = colamd (S, KNOBS)
     Column approximate minimum degree permutation.  'P = colamd (S)'
     returns the column approximate minimum degree permutation vector
     for the sparse matrix S.  For a non-symmetric matrix S, 'S(:,P)'
     tends to have sparser LU factors than S.  The
     Cholesky factorization of 'S(:,P)' * S(:,P)' also tends to be
     sparser than that of 'S' * S'.

     KNOBS is an optional one- to three-element input vector.  If S is
     m-by-n, then rows with more than 'max(16,KNOBS(1)*sqrt(n))'
     entries are ignored.  Columns with more than
     'max(16,KNOBS(2)*sqrt(min(m,n)))' entries are removed prior to
     ordering, and ordered last in the output permutation P.  Only
     completely dense rows or columns are removed if 'KNOBS(1)' and
     'KNOBS(2)' are &lt; 0, respectively.  If 'KNOBS(3)' is nonze...

     USE help colamd FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="colloc" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: [R, AMAT, BMAT, Q] = colloc (N, 'left', 'right')
     Compute derivative and integral weight matrices for orthogonal
     collocation using the subroutines given in J. Villadsen and M. L.
     Michelsen, 'Solution of Differential Equation Models by Polynomial
     Approximation'.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="colon" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: R = colon (A, B)
 -- Function File: R = colon (A, B, C)
     Method of a class to construct a range with the ':' operator.  For
     example:

          a = myclass (...);
          b = myclass (...);
          c = a : b

     See also: class, subsref, subsasgn


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="colorbar" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  colorbar (S)
 -- Function File:  colorbar ('peer', H, ...)
     Add a colorbar to the current axes.  Valid values for S are

    'EastOutside'
          Place the colorbar outside the plot to the right.  This is
          the default.

    'East'
          Place the colorbar inside the plot to the right.

    'WestOutside'
          Place the colorbar outside the plot to the left.

    'West'
          Place the colorbar inside the plot to the left.

    'NorthOutside'
          Place the colorbar above the plot.

    'North'
          Place the colorbar at the top of the plot.

    'SouthOutside'
          Place the colorbar under the plot.

    'South'
          Place the colorbar at the bottom of the plot.

    'Off', 'None'
          Remove any existing colorbar from the plot.

     If the argument 'peer' is given, then the following argument is
     treated as the axes handle on which to add the colorbar.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="colormap" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  colormap (MAP)
 -- Function File:  colormap ('default')
     Set the current colormap.

     'colormap (MAP)' sets the current colormap to MAP.  The color map
     should be an N row by 3 column matrix.  The columns contain red,
     green, and blue intensities respectively.  All entries should be
     between 0 and 1 inclusive.  The new colormap is returned.

     'colormap ('default')' restores the default colormap (the 'jet'
     map with 64 entries).  The default colormap is returned.

     With no arguments, 'colormap' returns the current color map.

     See also: jet


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="colperm" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: P = colperm (S)
     Return the column permutations such that the columns of 'S (:, P)'
     are ordered in terms of increase number of non-zero elements.  If
     S is symmetric, then P is chosen such that 'S (P, P)' orders the
     rows and columns with increasing number of non zeros elements.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="colstyle" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [STYLE, COLOR, MARKER, MSG] = colstyle (LINESPEC)
     Parse LINESPEC and return the line style, color, and markers given.
     In the case of an error, the string MSG will return the text of the
     error.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="columns" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  columns (A)
     Return the number of columns of A.

     See also: rows, size, length, numel, isscalar, isvector, ismatrix


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="comet" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  comet (Y)
 -- Function File:  comet (X, Y)
 -- Function File:  comet (X, Y, P)
 -- Function File:  comet (AX, ...)
     Produce a simple comet style animation along the trajectory
     provided by the input coordinate vectors (X, Y), where X will
     default to the indices of Y.

     The speed of the comet may be controlled by P, which represents the
     time which passes as the animation passes from one point to the
     next.  The default for P is 0.1 seconds.

     If AX is specified the animation is produced in that axis rather
     than the 'gca'.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="comet3" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  comet3 (Z)
 -- Function File:  comet3 (X, Y, Z, P)
 -- Function File:  comet3 (AX, ...)
     Produce a simple comet style animation along the trajectory
     provided by the input coordinate vectors (X, Y), where X will
     default to the indices of Y.

     The speed of the comet may be controlled by P, which represents the
     time which passes as the animation passes from one point to the
     next.  The default for P is 0.1 seconds.

     If AX is specified the animation is produced in that axis rather
     than the 'gca'.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="command_line_path" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  command_line_path (...)
     Return the command line path variable.

     See also: path, addpath, rmpath, genpath, pathdef, savepath,
     pathsep


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="common_size" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [ERR, Y1, ...] = common_size (X1, ...)
     Determine if all input arguments are either scalar or of common
     size.  If so, ERR is zero, and YI is a matrix of the common size
     with all entries equal to XI if this is a scalar or XI otherwise.
     If the inputs cannot be brought to a common size, ERR is 1, and YI
     is XI.  For example:

          [errorcode, a, b] = common_size ([1 2; 3 4], 5)
               => errorcode = 0
               => a = [ 1, 2; 3, 4 ]
               => b = [ 5, 5; 5, 5 ]

     This is useful for implementing functions where arguments can
     either be scalars or of common size.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="commutation_matrix" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  commutation_matrix (M, N)
     Return the commutation matrix  K(m,n)  which is the unique  M*N by
     M*N  matrix such that  K(m,n) * vec(A) = vec(A')  for all  m by n
     matrices  A.

     If only one argument M is given,  K(m,m)  is returned.

     See Magnus and Neudecker (1988), 'Matrix Differential Calculus with
     Applications in Statistics and Econometrics.'

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="compan" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  compan (C)
     Compute the companion matrix corresponding to polynomial
     coefficient vector C.

     The companion matrix is

               _                                                        _
              |  -c(2)/c(1)   -c(3)/c(1)  ...  -c(N)/c(1)  -c(N+1)/c(1)  |
              |       1            0      ...       0             0      |
              |       0            1      ...       0             0      |
          A = |       .            .      .         .             .      |
              |       .            .       .        .             .      |
              |       .            .        .       .             .      |
              |_      0            0      ...       1             0     _|

     The eigenvalues of the companion matrix are equal to the roots of
     the polynomial.

     See also: roots, poly, eig


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="compare_versions" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  compare_versions (V1, V2, OPERATOR)
     Compare two version strings using the given OPERATOR.

     This function assumes that versions V1 and V2 are arbitrarily long
     strings made of numeric and period characters possibly followed by
     an arbitrary string (e.g., '1.2.3', '0.3', '0.1.2+', or
     '1.2.3.4-test1').

     The version is first split into numeric and character portions and
     then the parts are padded to be the same length (i.e., '1.1' would
     be padded to be '1.1.0' when being compared with '1.1.1', and
     separately, the character parts of the strings are padded with
     nulls).

     The operator can be any logical operator from the set

        * '==' equal

        * '&lt;' less than

        * '&lt;=' less than or equal to

        * '&gt;' greater than

        * '&gt;=' greater than or equal to

        * '!=' not equal

        * '~=' not equal

     Note that version '1.1-test2' will compare as greater than
     '1.1-test10'.  Also, since ...

     USE help compare_versions FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="compass" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  compass (U, V)
 -- Function File:  compass (Z)
 -- Function File:  compass (..., STYLE)
 -- Function File:  compass (H, ...)
 -- Function File: H = compass (...)
     Plot the '(U, V)' components of a vector field emanating from the
     origin of a polar plot.  If a single complex argument Z is given,
     then 'U = real (Z)' and 'V = imag (Z)'.

     The style to use for the plot can be defined with a line style
     STYLE in a similar manner to the line styles used with the 'plot'
     command.

     The optional return value H is a vector of graphics handles to the
     line objects representing the drawn vectors.

          a = toeplitz ([1;randn(9,1)], [1,randn(1,9)]);
          compass (eig (a));

     See also: polar, quiver, feather, plot


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="completion_append_char" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: VAL = completion_append_char ()
 -- Built-in Function: OLD_VAL = completion_append_char (NEW_VAL)
 -- Built-in Function:  completion_append_char (NEW_VAL, 'local')
     Query or set the internal character variable that is appended to
     successful command-line completion attempts.  The default value is
     &quot; &quot; (a single space).

     When called from inside a function with the 'local' option, the
     variable is changed locally for the function and any subroutines
     it calls.  The original variable value is restored when exiting
     the function.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="completion_matches" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  completion_matches (HINT)
     Generate possible completions given HINT.

     This function is provided for the benefit of programs like Emacs
     which might be controlling Octave and handling user input.  The
     current command number is not incremented when this function is
     called.  This is a feature, not a bug.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="complex" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  complex (X)
 -- Built-in Function:  complex (RE, IM)
     Return a complex result from real arguments.  With 1 real argument
     X, return the complex result 'X + 0i'.  With 2 real arguments,
     return the complex result 'RE + IM'.  'complex' can often be more
     convenient than expressions such as 'a + i*b'.  For example:

          complex ([1, 2], [3, 4])
          =>
            1 + 3i   2 + 4i

     See also: real, imag, iscomplex


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="computer" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [C, MAXSIZE, ENDIAN] = computer ()
 -- Function File: ARCH = computer ('arch')
     Print or return a string of the form CPU-VENDOR-OS that identifies
     the kind of computer Octave is running on.  If invoked with an
     output argument, the value is returned instead of printed.  For
     example:

          computer ()
             -| i586-pc-linux-gnu

          x = computer ()
             => x = 'i586-pc-linux-gnu'

     If two output arguments are requested, also return the maximum
     number of elements for an array.

     If three output arguments are requested, also return the byte order
     of the current system as a character (&quot;B&quot; for big-endian or
     &quot;L&quot; for little-endian).

     If the argument &quot;arch&quot; is specified, return a string indicating
     the architecture of the computer on which Octave is running.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="cond" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  cond (A)
 -- Function File:  cond (A, P)
     Compute the P-norm condition number of a matrix.

     'cond (A)' is ## defined as 'norm (A, P) * norm (inv (A), P)'.

     By default 'P = 2' is used which implies a (relatively slow)
     singular value decomposition.  Other possible selections are 'P =
     1, Inf, 'fro&quot; which are generally faster.  See 'norm' for a full
     discussion of possible P values.

     See also: condest, rcond, norm, svd


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="condest" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  condest (A)
 -- Function File:  condest (A, T)
 -- Function File: [EST, V] = condest (...)
 -- Function File: [EST, V] = condest (A, SOLVE, SOLVE_T, T)
 -- Function File: [EST, V] = condest (APPLY, APPLY_T, SOLVE, SOLVE_T,
          N, T)
     Estimate the 1-norm condition number of a matrix A using T test
     vectors using a randomized 1-norm estimator.  If T exceeds 5, then
     only 5 test vectors are used.

     If the matrix is not explicit, e.g., when estimating the condition
     number of A given an LU factorization, 'condest' uses the
     following functions:

    APPLY
          'A*x' for a matrix 'x' of size N by T.

    APPLY_T
          'A'*x' for a matrix 'x' of size N by T.

    SOLVE
          'A \ b' for a matrix 'b' of size N by T.

    SOLVE_T
          'A' \ b' for a matrix 'b' of size N by T.

     The implicit version requires an explicit dimension N.

     'condest' uses a randomized algorithm to approximate the 1-norms.

     'condest' retu...

     USE help condest FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="confirm_recursive_rmdir" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: VAL = confirm_recursive_rmdir ()
 -- Built-in Function: OLD_VAL = confirm_recursive_rmdir (NEW_VAL)
 -- Built-in Function:  confirm_recursive_rmdir (NEW_VAL, 'local')
     Query or set the internal variable that controls whether Octave
     will ask for confirmation before recursively removing a directory
     tree.

     When called from inside a function with the 'local' option, the
     variable is changed locally for the function and any subroutines
     it calls.  The original variable value is restored when exiting
     the function.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="conj" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  conj (Z)
     Return the complex conjugate of Z, defined as 'conj (Z)' = X - IY.

     See also: real, imag


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="contour" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  contour (Z)
 -- Function File:  contour (Z, VN)
 -- Function File:  contour (X, Y, Z)
 -- Function File:  contour (X, Y, Z, VN)
 -- Function File:  contour (..., STYLE)
 -- Function File:  contour (H, ...)
 -- Function File: [C, H] = contour (...)
     Plot level curves (contour lines) of the matrix Z, using the
     contour matrix C computed by 'contourc' from the same arguments;
     see the latter for their interpretation.  The set of contour
     levels, C, is only returned if requested.  For example:

          x = 0:2;
          y = x;
          z = x' * y;
          contour (x, y, z, 2:3)

     The style to use for the plot can be defined with a line style
     STYLE in a similar manner to the line styles used with the 'plot'
     command.  Any markers defined by STYLE are ignored.

     The optional input and output argument H allows an axis handle to
     be passed to 'contour' and the handles to the contour objects to be
     returned.

     See also: cont...

     USE help contour FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="contour3" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  contour3 (Z)
 -- Function File:  contour3 (Z, VN)
 -- Function File:  contour3 (X, Y, Z)
 -- Function File:  contour3 (X, Y, Z, VN)
 -- Function File:  contour3 (..., STYLE)
 -- Function File:  contour3 (H, ...)
 -- Function File: [C, H] = contour3 (...)
     Plot level curves (contour lines) of the matrix Z, using the
     contour matrix C computed by 'contourc' from the same arguments;
     see the latter for their interpretation.  The contours are plotted
     at the Z level corresponding to their contour.  The set of contour
     levels, C, is only returned if requested.  For example:

          contour3 (peaks (19));
          hold on
          surface (peaks (19), 'facecolor', 'none', 'EdgeColor', 'black');
          colormap hot;

     The style to use for the plot can be defined with a line style
     STYLE in a similar manner to the line styles used with the 'plot'
     command.  Any markers defined by STYLE are ignored.

     The optional input and output ...

     USE help contour3 FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="contourc" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [C, LEV] = contourc (X, Y, Z, VN)
     Compute isolines (contour lines) of the matrix Z.  Parameters X, Y
     and VN are optional.

     The return value LEV is a vector of the contour levels.  The
     return value C is a 2 by N matrix containing the contour lines in
     the following format

          C = [lev1, x1, x2, ..., levn, x1, x2, ...
               len1, y1, y2, ..., lenn, y1, y2, ...]

     in which contour line N has a level (height) of LEVN and length of
     LENN.

     If X and Y are omitted they are taken as the row/column index of
     Z.  VN is either a scalar denoting the number of lines to compute
     or a vector containing the values of the lines.  If only one value
     is wanted, set 'VN = [val, val]'; If VN is omitted it defaults to
     10.

     For example:

          x = 0:2;
          y = x;
          z = x' * y;
          contourc (x, y, z, 2:3)
             =>   2.0000   2.0000   1.0000   3.0000   1.5000   2.0000
                  2...

     USE help contourc FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="contourf" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [C, H] = contourf (X, Y, Z, LVL)
 -- Function File: [C, H] = contourf (X, Y, Z, N)
 -- Function File: [C, H] = contourf (X, Y, Z)
 -- Function File: [C, H] = contourf (Z, N)
 -- Function File: [C, H] = contourf (Z, LVL)
 -- Function File: [C, H] = contourf (Z)
 -- Function File: [C, H] = contourf (AX, ...)
 -- Function File: [C, H] = contourf (..., 'PROPERTY', VAL)
     Compute and plot filled contours of the matrix Z.  Parameters X, Y
     and N or LVL are optional.

     The return value C is a 2xn matrix containing the contour lines as
     described in the help to the contourc function.

     The return value H is handle-vector to the patch objects creating
     the filled contours.

     If X and Y are omitted they are taken as the row/column index of
     Z.  N is a scalar denoting the number of lines to compute.
     Alternatively LVL is a vector containing the contour levels.  If
     only one value (e.g., lvl0) is wanted, set LVL to [lvl0, lvl0].
     If bot...

     USE help contourf FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="contrast" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  contrast (X, N)
     Return a gray colormap that maximizes the contrast in an image.
     The returned colormap will have N rows.  If N is not defined then
     the size of the current colormap is used instead.

     See also: colormap


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="conv" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  conv (A, B)
 -- Function File:  conv (A, B, SHAPE)
     Convolve two vectors A and B.

     The output convolution is a vector with length equal to 'length
     (A) + length (B) - 1'.  When A and B are the coefficient vectors
     of two polynomials, the convolution represents the coefficient
     vector of the product polynomial.

     The optional SHAPE argument may be

    SHAPE = 'full'
          Return the full convolution.  (default)

    SHAPE = 'same'
          Return the central part of the convolution with the same size
          as A.

     See also: deconv, conv2, convn, fftconv


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="conv2" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function:  conv2 (A, B)
 -- Loadable Function:  conv2 (V1, V2, M)
 -- Loadable Function:  conv2 (..., SHAPE)
     Return the 2-D convolution of A and B.  The size of the result is
     determined by the optional SHAPE argument which takes the following
     values

    SHAPE = 'full'
          Return the full convolution.  (default)

    SHAPE = 'same'
          Return the central part of the convolution with the same size
          as A.  The central part of the convolution begins at the
          indices 'floor ([size(B)/2] + 1)'.

    SHAPE = 'valid'
          Return only the parts which do not include zero-padded edges.
          The size of the result is 'max (size (A) - size (B) + 1, 0)'.

     When the third argument is a matrix, return the convolution of the
     matrix M by the vector V1 in the column direction and by the vector
     V2 in the row direction.

     See also: conv, convn


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="convhull" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: H = convhull (X, Y)
 -- Function File: H = convhull (X, Y, OPTIONS)
     Compute the convex hull of the set of points defined by the
     vectors X and Y.  The hull H is an index vector into the set of
     points and specifies which points form the enclosing hull.

     An optional third argument, which must be a string or cell array
     of strings, contains options passed to the underlying qhull
     command.  See the documentation for the Qhull library for details
     'http://www.qhull.org/html/qh-quick.htm#options'.  The default
     option is '{'Qt'}'.

     If OPTIONS is not present or '[]' then the default arguments are
     used.  Otherwise, OPTIONS replaces the default argument list.  To
     append user options to the defaults it is necessary to repeat the
     default arguments in OPTIONS.  Use a null string to pass no
     arguments.

     See also: convhulln, delaunay, voronoi


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="convhulln" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: H = convhulln (PTS)
 -- Loadable Function: H = convhulln (PTS, OPTIONS)
 -- Loadable Function: [H, V] = convhulln (...)
     Compute the convex hull of the set of points PTS which is a matrix
     of size [n, dim] containing n points in a space of dimension dim.
     The hull H is an index vector into the set of points and specifies
     which points form the enclosing hull.

     An optional second argument, which must be a string or cell array
     of strings, contains options passed to the underlying qhull
     command.  See the documentation for the Qhull library for details
     'http://www.qhull.org/html/qh-quick.htm#options'.  The default
     options depend on the dimension of the input:

        * 2D, 3D, 4D: OPTIONS = '{'Qt'}'

        * 5D and higher: OPTIONS = '{'Qt', 'Qx'}'

     If OPTIONS is not present or '[]' then the default arguments are
     used.  Otherwise, OPTIONS replaces the default argument list.  To
     append user options to the defau...

     USE help convhulln FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="convn" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: C = convn (A, B)
 -- Loadable Function: C = convn (A, B, SHAPE)
     Return the n-D convolution of A and B.  The size of the result is
     determined by the optional SHAPE argument which takes the following
     values

    SHAPE = 'full'
          Return the full convolution.  (default)

    SHAPE = 'same'
          Return central part of the convolution with the same size as
          A.  The central part of the convolution begins at the indices
          'floor ([size(B)/2] + 1)'.

    SHAPE = 'valid'
          Return only the parts which do not include zero-padded edges.
          The size of the result is 'max (size (A) - size (B) + 1, 0)'.

     See also: conv2, conv


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="cool" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: MAP = cool ()
 -- Function File: MAP = cool (N)
     Create color colormap.  The colormap varies from cyan to magenta.
     The argument N must be a scalar.  If unspecified, the length of
     the current colormap, or 64, is used.

     See also: colormap


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="copper" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: MAP = copper ()
 -- Function File: MAP = copper (N)
     Create color colormap.  This colormap varies from black to a light
     copper tone.  The argument N must be a scalar.  If unspecified,
     the length of the current colormap, or 64, is used.

     See also: colormap


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="copyfile" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [STATUS, MSG, MSGID] = copyfile (F1, F2)
 -- Function File: [STATUS, MSG, MSGID] = copyfile (F1, F2, 'f')
     Copy the file F1 to the new name F2.  The name F1 may contain
     globbing patterns.  If F1 expands to multiple file names, F2 must
     be a directory.  If the force flag 'f' is given then existing
     destination files will be overwritten without prompting.

     If successful, STATUS is 1, with MSG and MSGID empty character
     strings.  Otherwise, STATUS is 0, MSG contains a system-dependent
     error message, and MSGID contains a unique message identifier.

     See also: movefile


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="cor_test" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  cor_test (X, Y, ALT, METHOD)
     Test whether two samples X and Y come from uncorrelated
     populations.

     The optional argument string ALT describes the alternative
     hypothesis, and can be &quot;!=&quot; or &quot;&lt;%gt;&quot; (non-zero), &quot;&gt;&quot; (greater
     than 0), or &quot;&lt;&quot; (less than 0).  The default is the two-sided
     case.

     The optional argument string METHOD specifies which correlation
     coefficient to use for testing.  If METHOD is &quot;pearson&quot;
     (default), the (usual) Pearson's product moment correlation
     coefficient is used.  In this case, the data should come from a
     bivariate normal distribution.  Otherwise, the other two methods
     offer nonparametric alternatives.  If METHOD is &quot;kendall&quot;, then
     Kendall's rank correlation tau is used.  If METHOD is
     &quot;spearman&quot;, then Spearman's rank correlation rho is used.  Only
     the first character is necessary.

     The output is a structure with the following elements:

    PVAL
        ...

     USE help cor_test FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="corr" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  corr (X)
 -- Function File:  corr (X, Y)
     Compute matrix of correlation coefficients.

     If each row of X and Y is an observation and each column is a
     variable, then the (I, J)-th entry of 'corr (X, Y)' is the
     correlation between the I-th variable in X and the J-th variable
     in Y.

          corr (x,y) = cov (x,y) / (std (x) * std (y))

     If called with one argument, compute 'corr (X, X)', the
     correlation between the columns of X.

     See also: cov


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="cos" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  cos (X)
     Compute the cosine for each element of X in radians.

     See also: acos, cosd, cosh


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="cosd" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  cosd (X)
     Compute the cosine for each element of X in degrees.  Returns zero
     for elements where '(X-90)/180' is an integer.

     See also: acosd, cos


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="cosh" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  cosh (X)
     Compute the hyperbolic cosine for each element of X.

     See also: acosh, sinh, tanh


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="cot" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  cot (X)
     Compute the cotangent for each element of X in radians.

     See also: acot, cotd, coth


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="cotd" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  cotd (X)
     Compute the cotangent for each element of X in degrees.

     See also: acotd, cot


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="coth" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  coth (X)
     Compute the hyperbolic cotangent of each element of X.

     See also: acoth


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="cov" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  cov (X)
 -- Function File:  cov (X, OPT)
 -- Function File:  cov (X, Y)
 -- Function File:  cov (X, Y, OPT)
     Compute the covariance matrix.

     If each row of X and Y is an observation, and each column is a
     variable, then the (I, J)-th entry of 'cov (X, Y)' is the
     covariance between the I-th variable in X and the J-th variable in
     Y.

          cov (x) = 1/N-1 * SUM_i (x(i) - mean(x)) * (y(i) - mean(y))

     If called with one argument, compute 'cov (X, X)', the covariance
     between the columns of X.

     The argument OPT determines the type of normalization to use.
     Valid values are

    0:
          normalize with N-1, provides the best unbiased estimator of
          the covariance [default]

    1:
          normalize with N, this provides the second moment around the
          mean

     See also: corr


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="covar" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [P, Q] = covar (SYS, W)
     Return the steady-state covariance.

     *Inputs*
    SYS
          LTI model.

    W
          Intensity of white noise inputs which drive SYS.

     *Outputs*
    P
          Output covariance.

    Q
          State covariance.

     See also: lyap, dlyap


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="cplxpair" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  cplxpair (Z)
 -- Function File:  cplxpair (Z, TOL)
 -- Function File:  cplxpair (Z, TOL, DIM)
     Sort the numbers Z into complex conjugate pairs ordered by
     increasing real part.  Place the negative imaginary complex number
     first within each pair.  Place all the real numbers (those with
     'abs (imag (Z) / Z) &lt; TOL)') after the complex pairs.

     If TOL is unspecified the default value is 100*'eps'.

     By default the complex pairs are sorted along the first
     non-singleton dimension of Z.  If DIM is specified, then the
     complex pairs are sorted along this dimension.

     Signal an error if some complex numbers could not be paired.
     Signal an error if all complex numbers are not exact conjugates
     (to within TOL).  Note that there is no defined order for pairs
     with identical real parts but differing imaginary parts.

          cplxpair (exp(2i*pi*[0:4]'/5)) == exp(2i*pi*[3; 2; 4; 1; 0]/5)

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="cputime" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: [TOTAL, USER, SYSTEM] = cputime ();
     Return the CPU time used by your Octave session.  The first output
     is the total time spent executing your process and is equal to the
     sum of second and third outputs, which are the number of CPU
     seconds spent executing in user mode and the number of CPU seconds
     spent executing in system mode, respectively.  If your system does
     not have a way to report CPU time usage, 'cputime' returns 0 for
     each of its output values.  Note that because Octave used some CPU
     time to start, it is reasonable to check to see if 'cputime' works
     by checking to see if the total CPU time used is nonzero.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="crash_dumps_octave_core" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: VAL = crash_dumps_octave_core ()
 -- Built-in Function: OLD_VAL = crash_dumps_octave_core (NEW_VAL)
 -- Built-in Function:  crash_dumps_octave_core (NEW_VAL, 'local')
     Query or set the internal variable that controls whether Octave
     tries to save all current variables to the file 'octave-core' if it
     crashes or receives a hangup, terminate or similar signal.

     When called from inside a function with the 'local' option, the
     variable is changed locally for the function and any subroutines
     it calls.  The original variable value is restored when exiting
     the function.

     See also: octave_core_file_limit, octave_core_file_name,
     octave_core_file_options


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="cross" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  cross (X, Y)
 -- Function File:  cross (X, Y, DIM)
     Compute the vector cross product of two 3-dimensional vectors X
     and Y.

          cross ([1,1,0], [0,1,1])
               => [ 1; -1; 1 ]

     If X and Y are matrices, the cross product is applied along the
     first dimension with 3 elements.  The optional argument DIM forces
     the cross product to be calculated along the specified dimension.

     See also: dot, curl, divergence


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="csc" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  csc (X)
     Compute the cosecant for each element of X in radians.

     See also: acsc, cscd, csch


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="cscd" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  cscd (X)
     Compute the cosecant for each element of X in degrees.

     See also: acscd, csc


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="csch" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  csch (X)
     Compute the hyperbolic cosecant of each element of X.

     See also: acsch


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="cstrcat" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  cstrcat (S1, S2, ...)
     Return a string containing all the arguments concatenated
     horizontally.  Trailing white space is preserved.  For example:

          cstrcat ('ab   ', 'cd')
                => 'ab   cd'

          s = [ 'ab'; 'cde' ];
          cstrcat (s, s, s)
               => 'ab ab ab '
                  'cdecdecde'

     See also: strcat, char, strvcat


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="csvread" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: X = csvread (FILENAME)
 -- Function File: X = csvread (FILENAME, DLM_OPTS)
     Read the comma-separated-value file FILENAME into the matrix X.

     This function is equivalent to

          X = dlmread (FILENAME, ',' , ...)

     See also: csvwrite, dlmread, dlmwrite


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="csvwrite" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  csvwrite (FILENAME, X)
 -- Function File:  csvwrite (FILENAME, X, DLM_OPTS)
     Write the matrix X to the file FILENAME in comma-separated-value
     format.

     This function is equivalent to

          dlmwrite (FILENAME, X, ',', ...)

     See also: csvread, dlmwrite, dlmread


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="csymamd" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: P = csymamd (S)
 -- Loadable Function: P = csymamd (S, KNOBS)
 -- Loadable Function: P = csymamd (S, KNOBS, CMEMBER)
 -- Loadable Function: [P, STATS] = csymamd (...)
     For a symmetric positive definite matrix S, returns the permutation
     vector P such that 'S(P,P)' tends to have a sparser
     Cholesky factor than S.  Sometimes 'csymamd' works well for
     symmetric indefinite matrices too.  The matrix S is assumed to be
     symmetric; only the strictly lower triangular part is referenced.
     S must be square.  The ordering is followed by an elimination tree
     post-ordering.

     KNOBS is an optional 1-element to 3-element input vector, with a
     default value of '[10 1 0]' if present or empty.  Entries not
     present are set to their defaults.

    'KNOBS(1)'
          If S is n-by-n, then rows and columns with more than
          'max(16,KNOBS(1)*sqrt(n))' entries are ignored, and ordered
          last in the output permutation (subject to t...

     USE help csymamd FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="ctime" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  ctime (T)
     Convert a value returned from 'time' (or any other non-negative
     integer), to the local time and return a string of the same form as
     'asctime'.  The function 'ctime (time)' is equivalent to 'asctime
     (localtime (time))'.  For example:

          ctime (time ())
             => 'Mon Feb 17 01:15:06 1997'

     See also: asctime, time, localtime


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="ctranspose" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  ctranspose (X)
     Return the complex conjugate transpose of X.  This function and x'
     are equivalent.

     See also: transpose


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="ctrb" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: CO = ctrb (SYS)
 -- Function File: CO = ctrb (A, B)
     Return controllability matrix.

     *Inputs*
    SYS
          LTI model.

    A
          State transition matrix (n-by-n).

    B
          Input matrix (n-by-m).

     *Outputs*
    CO
          Controllability matrix.

     *Equation*
                       2       n-1
          Co = [ B AB A B ... A   B ]

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="ctrbf" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [SYSBAR, T, K] = ctrbf (SYS)
 -- Function File: [SYSBAR, T, K] = ctrbf (SYS, TOL)
 -- Function File: [ABAR, BBAR, CBAR, T, K] = ctrbf (A, B, C)
 -- Function File: [ABAR, BBAR, CBAR, T, K] = ctrbf (A, B, C, TOL)
     If Co=ctrb(A,B) has rank r &lt;= n = SIZE(A,1), then there is a
     similarity transformation Tc such that Tc = [t1 t2] where t1 is
     the controllable subspace and t2 is orthogonal to t1

          Abar = Tc \ A * Tc ,  Bbar = Tc \ B ,  Cbar = C * Tc

     and the transformed system has the form

                 | Ac    A12|           | Bc |
          Abar = |----------|,   Bbar = | ---|,  Cbar = [Cc | Cnc].
                 | 0     Anc|           |  0 |

     where (Ac,Bc) is controllable, and Cc(sI-Ac)^(-1)Bc =
     C(sI-A)^(-1)B.  and the system is stabilizable if Anc has no
     eigenvalues in the right half plane. The last output K is a vector
     of length n containing the number of controllable states.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="cummax" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function:  cummax (X)
 -- Loadable Function:  cummax (X, DIM)
 -- Loadable Function: [W, IW] = cummax (X)
     Return the cumulative maximum values along dimension DIM.  If DIM
     is unspecified it defaults to column-wise operation.  For example:

          cummax ([1 3 2 6 4 5])
             =>  1  3  3  6  6  6

     The call

          [w, iw] = cummax (x, dim)

     with 'x' a vector, is equivalent to the following code:

          w = iw = zeros (size (x));
          for i = 1:length (x)
           [w(i), iw(i)] = max (x(1:i));
          endfor

     but computed in a much faster manner.

     See also: cummin, max, min


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="cummin" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function:  cummin (X)
 -- Loadable Function:  cummin (X, DIM)
 -- Loadable Function: [W, IW] = cummin (X)
     Return the cumulative minimum values along dimension DIM.  If DIM
     is unspecified it defaults to column-wise operation.  For example:

          cummin ([5 4 6 2 3 1])
             =>  5  4  4  2  2  1

     The call

           [w, iw] = cummin (x)

     with 'x' a vector, is equivalent to the following code:

          w = iw = zeros (size (x));
          for i = 1:length (x)
           [w(i), iw(i)] = max (x(1:i));
          endfor

     but computed in a much faster manner.

     See also: cummax, min, max


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="cumprod" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  cumprod (X)
 -- Built-in Function:  cumprod (X, DIM)
     Cumulative product of elements along dimension DIM.  If DIM is
     omitted, it defaults to the first non-singleton dimension.

     See also: prod, cumsum


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="cumsum" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  cumsum (X)
 -- Built-in Function:  cumsum (X, DIM)
 -- Built-in Function:  cumsum (..., 'native')
 -- Built-in Function:  cumsum (..., 'double')
 -- Built-in Function:  cumsum (..., 'extra')
     Cumulative sum of elements along dimension DIM.  If DIM is
     omitted, it defaults to the first non-singleton dimension.

     See 'sum' for an explanation of the optional parameters 'native',
     'double', and 'extra'.

     See also: sum, cumprod


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="cumtrapz" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: Q = cumtrapz (Y)
 -- Function File: Q = cumtrapz (X, Y)
 -- Function File: Q = cumtrapz (..., DIM)
     Cumulative numerical integration of points Y using the trapezoidal
     method.  'cumtrapz (Y)' computes the cumulative integral of Y
     along the first non-singleton dimension.  Where 'trapz' reports
     only the overall integral sum, 'cumtrapz' reports the current
     partial sum value at each point of Y.  When the argument X is
     omitted an equally spaced X vector with unit spacing (1) is
     assumed.  'cumtrapz (X, Y)' evaluates the integral with respect to
     the spacing in X and the values in Y.  This is useful if the
     points in Y have been sampled unevenly.  If the optional DIM
     argument is given, operate along this dimension.

     If X is not specified then unit spacing will be used.  To scale
     the integral to the correct value you must multiply by the actual
     spacing value (deltaX).

     See also: trapz, cumsum


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="curl" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [CX, CY, CZ, V] = curl (X, Y, Z, FX, FY, FZ)
 -- Function File: [CZ, V] = curl (X, Y, FX, FY)
 -- Function File: [...] = curl (FX, FY, FZ)
 -- Function File: [...] = curl (FX, FY)
 -- Function File: V = curl (...)
     Calculate curl of vector field given by the arrays FX, FY, and FZ
     or FX, FY respectively.

                            / d         d       d         d       d         d     \
          curl F(x,y,z)  =  | -- Fz  -  -- Fy,  -- Fx  -  -- Fz,  -- Fy  -  -- Fx |
                            \ dy        dz      dz        dx      dx        dy    /

     The coordinates of the vector field can be given by the arguments
     X, Y, Z or X, Y respectively.  V calculates the scalar component
     of the angular velocity vector in direction of the z-axis for
     two-dimensional input.  For three-dimensional input the scalar
     rotation is calculated at each grid point in direction of the
     vector field at that point.

     See also: divergence, gradient,...

     USE help curl FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="cylinder" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  cylinder
 -- Function File:  cylinder (R)
 -- Function File:  cylinder (R, N)
 -- Function File: [X, Y, Z] = cylinder (...)
 -- Function File:  cylinder (AX, ...)
     Generate three matrices in 'meshgrid' format, such that 'surf (X,
     Y, Z)' generates a unit cylinder.  The matrices are of size
     'N+1'-by-'N+1'.  R is a vector containing the radius along the
     z-axis.  If N or R are omitted then default values of 20 or [1 1]
     are assumed.

     Called with no return arguments, 'cylinder' calls directly 'surf
     (X, Y, Z)'.  If an axes handle AX is passed as the first argument,
     the surface is plotted to this set of axes.

     Examples:

          [x, y, z] = cylinder (10:-1:0, 50);
          surf (x, y, z);
          title ('a cone');

     See also: sphere


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="dare" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [X, L, G] = dare (A, B, Q, R)
 -- Function File: [X, L, G] = dare (A, B, Q, R, S)
 -- Function File: [X, L, G] = dare (A, B, Q, R, [], E)
 -- Function File: [X, L, G] = dare (A, B, Q, R, S, E)
     Solve discrete-time algebraic Riccati equation (ARE).

     *Inputs*
    A
          Real matrix (n-by-n).

    B
          Real matrix (n-by-m).

    Q
          Real matrix (n-by-n).

    R
          Real matrix (m-by-m).

    S
          Optional real matrix (n-by-m).  If S is not specified, a zero
          matrix is assumed.

    E
          Optional descriptor matrix (n-by-n).  If E is not specified,
          an identity matrix is assumed.

     *Outputs*
    X
          Unique stabilizing solution of the discrete-time Riccati
          equation (n-by-n).

    L
          Closed-loop poles (n-by-1).

    G
          Corresponding gain matrix (m-by-n).

     *Equations*
                                    -1
          A'XA - X - A'XB (B'XB + R)   B'XA + Q = 0

      ...

     USE help dare FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="daspect" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  daspect (DATA_ASPECT_RATIO)
     Set the data aspect ratio of the current axes.  The aspect ratio is
     a normalized 3-element vector representing the span of the x, y,
     and z-axes limits.

 -- Function File: DATA_ASPECT_RATIO = daspect ( )
     Return the data aspect ratio of the current axes.

 -- Function File:  daspect (MODE)
     Set the data aspect ratio mode of the current axes.

 -- Function File: DATA_ASPECT_RATIO_MODE = daspect ('mode')
     Return the data aspect ratio mode of the current axes.

 -- Function File:  daspect (HAX, ...)
     Use the axes, with handle HAX, instead of the current axes.

     See also: axis, pbaspect, xlim, ylim, zlim


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="daspk" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: [X, XDOT, ISTATE, MSG] = daspk (FCN, X_0,
          XDOT_0, T, T_CRIT)
     Solve the set of differential-algebraic equations

          0 = f (x, xdot, t)

     with

          x(t_0) = x_0, xdot(t_0) = xdot_0

     The solution is returned in the matrices X and XDOT, with each row
     in the result matrices corresponding to one of the elements in the
     vector T.  The first element of T should be t_0 and correspond to
     the initial state of the system X_0 and its derivative XDOT_0, so
     that the first row of the output X is X_0 and the first row of the
     output XDOT is XDOT_0.

     The first argument, FCN, is a string, inline, or function handle
     that names the function f to call to compute the vector of
     residuals for the set of equations.  It must have the form

          RES = f (X, XDOT, T)

     in which X, XDOT, and RES are vectors, and T is a scalar.

     If FCN is a two-element string array or a two-element cell array
     of strin...

     USE help daspk FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="daspk_options" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function:  daspk_options ()
 -- Loadable Function: val = daspk_options (OPT)
 -- Loadable Function:  daspk_options (OPT, VAL)
     Query or set options for the function 'daspk'.  When called with
     no arguments, the names of all available options and their current
     values are displayed.  Given one argument, return the value of the
     corresponding option.  When called with two arguments,
     'daspk_options' set the option OPT to value VAL.

     Options include

    &quot;absolute tolerance&quot;
          Absolute tolerance.  May be either vector or scalar.  If a
          vector, it must match the dimension of the state vector, and
          the relative tolerance must also be a vector of the same
          length.

    &quot;relative tolerance&quot;
          Relative tolerance.  May be either vector or scalar.  If a
          vector, it must match the dimension of the state vector, and
          the absolute tolerance must also be a vector of the same
          length.

    ...

     USE help daspk_options FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="dasrt" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: [X, XDOT, T_OUT, ISTAT, MSG] = dasrt (FCN, [],
          X_0, XDOT_0, T)
 -- Loadable Function: ... = dasrt (FCN, G, X_0, XDOT_0, T)
 -- Loadable Function: ... = dasrt (FCN, [], X_0, XDOT_0, T, T_CRIT)
 -- Loadable Function: ... = dasrt (FCN, G, X_0, XDOT_0, T, T_CRIT)
     Solve the set of differential-algebraic equations

          0 = f (x, xdot, t)

     with

          x(t_0) = x_0, xdot(t_0) = xdot_0

     with functional stopping criteria (root solving).

     The solution is returned in the matrices X and XDOT, with each row
     in the result matrices corresponding to one of the elements in the
     vector T_OUT.  The first element of T should be t_0 and correspond
     to the initial state of the system X_0 and its derivative XDOT_0,
     so that the first row of the output X is X_0 and the first row of
     the output XDOT is XDOT_0.

     The vector T provides an upper limit on the length of the
     integration.  If the stopping condition is met, the...

     USE help dasrt FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="dasrt_options" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function:  dasrt_options ()
 -- Loadable Function: val = dasrt_options (OPT)
 -- Loadable Function:  dasrt_options (OPT, VAL)
     Query or set options for the function 'dasrt'.  When called with
     no arguments, the names of all available options and their current
     values are displayed.  Given one argument, return the value of the
     corresponding option.  When called with two arguments,
     'dasrt_options' set the option OPT to value VAL.

     Options include

    &quot;absolute tolerance&quot;
          Absolute tolerance.  May be either vector or scalar.  If a
          vector, it must match the dimension of the state vector, and
          the relative tolerance must also be a vector of the same
          length.

    &quot;relative tolerance&quot;
          Relative tolerance.  May be either vector or scalar.  If a
          vector, it must match the dimension of the state vector, and
          the absolute tolerance must also be a vector of the same
          length.

    ...

     USE help dasrt_options FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="dassl" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: [X, XDOT, ISTATE, MSG] = dassl (FCN, X_0,
          XDOT_0, T, T_CRIT)
     Solve the set of differential-algebraic equations

          0 = f (x, xdot, t)

     with

          x(t_0) = x_0, xdot(t_0) = xdot_0

     The solution is returned in the matrices X and XDOT, with each row
     in the result matrices corresponding to one of the elements in the
     vector T.  The first element of T should be t_0 and correspond to
     the initial state of the system X_0 and its derivative XDOT_0, so
     that the first row of the output X is X_0 and the first row of the
     output XDOT is XDOT_0.

     The first argument, FCN, is a string, inline, or function handle
     that names the function f to call to compute the vector of
     residuals for the set of equations.  It must have the form

          RES = f (X, XDOT, T)

     in which X, XDOT, and RES are vectors, and T is a scalar.

     If FCN is a two-element string array or a two-element cell array
     of strin...

     USE help dassl FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="dassl_options" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function:  dassl_options ()
 -- Loadable Function: val = dassl_options (OPT)
 -- Loadable Function:  dassl_options (OPT, VAL)
     Query or set options for the function 'dassl'.  When called with
     no arguments, the names of all available options and their current
     values are displayed.  Given one argument, return the value of the
     corresponding option.  When called with two arguments,
     'dassl_options' set the option OPT to value VAL.

     Options include

    &quot;absolute tolerance&quot;
          Absolute tolerance.  May be either vector or scalar.  If a
          vector, it must match the dimension of the state vector, and
          the relative tolerance must also be a vector of the same
          length.

    &quot;relative tolerance&quot;
          Relative tolerance.  May be either vector or scalar.  If a
          vector, it must match the dimension of the state vector, and
          the absolute tolerance must also be a vector of the same
          length.

    ...

     USE help dassl_options FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="date" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  date ()
     Return the current date as a character string in the form
     DD-MMM-YYYY.

     For example:

          date ()
            => '20-Aug-1993'

     See also: now, clock, datestr, localtime


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="datenum" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: DAYS = datenum (DATEVEC)
 -- Function File: DAYS = datenum (YEAR, MONTH, DAY)
 -- Function File: DAYS = datenum (YEAR, MONTH, DAY, HOUR)
 -- Function File: DAYS = datenum (YEAR, MONTH, DAY, HOUR, MINUTE)
 -- Function File: DAYS = datenum (YEAR, MONTH, DAY, HOUR, MINUTE,
          SECOND)
 -- Function File: DAYS = datenum ('datestr')
 -- Function File: DAYS = datenum ('datestr', P)
 -- Function File: [DAYS, SECS] = datenum (...)
     Return the date/time input as a serial day number, with Jan 1, 0000
     defined as day 1.

     The integer part, 'floor (DAYS)' counts the number of complete
     days in the date input.

     The fractional part, 'rem (DAYS, 1)' corresponds to the time on
     the given day.

     The input may be a date vector (see 'datevec'), datestr (see
     'datestr'), or directly specified as input.

     When processing input datestrings, P is the year at the start of
     the century to which two-digit years will be referenced.  If not
     spe...

     USE help datenum FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="datestr" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: STR = datestr (DATE)
 -- Function File: STR = datestr (DATE, F)
 -- Function File: STR = datestr (DATE, F, P)
     Format the given date/time according to the format 'f' and return
     the result in STR.  DATE is a serial date number (see 'datenum')
     or a date vector (see 'datevec').  The value of DATE may also be a
     string or cell array of strings.

     F can be an integer which corresponds to one of the codes in the
     table below, or a date format string.

     P is the year at the start of the century in which two-digit years
     are to be interpreted in.  If not specified, it defaults to the
     current year minus 50.

     For example, the date 730736.65149 (2000-09-07 15:38:09.0934)
     would be formatted as follows:

     Code    Format                         Example
     --------------------------------------------------------------- 
     0       dd-mmm-yyyy HH:MM:SS           07-Sep-2000 15:38:09
     1       dd-mmm-yyyy                    ...

     USE help datestr FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="datetick" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  datetick ()
 -- Function File:  datetick (FORM)
 -- Function File:  datetick (AXIS, FORM)
 -- Function File:  datetick (..., 'keeplimits')
 -- Function File:  datetick (..., 'keepticks')
 -- Function File:  datetick (...ax, ...)
     Add date formatted tick labels to an axis.  The axis the apply the
     ticks to is determined by AXIS that can take the values 'x', 'y'
     or 'z'.  The default value is 'x'.  The formatting of the labels is
     determined by the variable FORM, that can either be a string in
     the format needed by 'dateform', or a positive integer that can be
     accepted by 'datestr'.

     See also: datenum, datestr


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="datevec" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: V = datevec (DATE)
 -- Function File: V = datevec (DATE, F)
 -- Function File: V = datevec (DATE, P)
 -- Function File: V = datevec (DATE, F, P)
 -- Function File: [Y, M, D, H, MI, S] = datevec (...)
     Convert a serial date number (see 'datenum') or date string (see
     'datestr') into a date vector.

     A date vector is a row vector with six members, representing the
     year, month, day, hour, minute, and seconds respectively.

     F is the format string used to interpret date strings (see
     'datestr').

     P is the year at the start of the century to which two-digit years
     will be referenced.  If not specified, it defaults to the current
     year minus 50.

     See also: datenum, datestr, clock, now, date


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="dbclear" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function:  dbclear ('FUNC')
 -- Loadable Function:  dbclear ('FUNC', LINE, ...)
     Delete a breakpoint in the function FUNC.

     Arguments are

    FUNC
          Function name as a string variable.  When already in debug
          mode this should be left out and only the line should be
          given.

    LINE
          Line number from which to remove a breakpoint.  Multiple
          lines may be given as separate arguments or as a vector.

     When called without a line number specification all breakpoints in
     the named function are cleared.

     If the requested line is not a breakpoint no action is performed.

     See also: dbstop, dbstatus, dbwhere


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="dbcont" func="yes">
            <Overload retVal="">
                <Param name="
 -- Command:  dbcont
     Leave command-line debugging mode and continue code execution
     normally.

     See also: dbstep, dbquit


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="dbdown" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function:  dbdown
 -- Loadable Function:  dbdown (N)
     In debugging mode, move down the execution stack N frames.  If N
     is omitted, move down one frame.

     See also: dbstack, dbup


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="dblquad" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  dblquad (F, XA, XB, YA, YB)
 -- Function File:  dblquad (F, XA, XB, YA, YB, TOL)
 -- Function File:  dblquad (F, XA, XB, YA, YB, TOL, QUADF)
 -- Function File:  dblquad (F, XA, XB, YA, YB, TOL, QUADF, ...)
     Numerically evaluate the double integral of F.  F is a function
     handle, inline function, or string containing the name of the
     function to evaluate.  The function F must have the form z =
     f(x,y) where X is a vector and Y is a scalar.  It should return a
     vector of the same length and orientation as X.

     XA, YA and XB, YB are the lower and upper limits of integration
     for x and y respectively.  The underlying integrator determines
     whether infinite bounds are accepted.

     The optional argument TOL defines the absolute tolerance used to
     integrate each sub-integral.  The default value is 1e^-6.

     The optional argument QUADF specifies which underlying integrator
     function to use.  Any choice but 'quad' is available an...

     USE help dblquad FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="dbquit" func="yes">
            <Overload retVal="">
                <Param name="
 -- Command:  dbquit
     Quit debugging mode immediately without further code execution and
     return to the Octave prompt.

     See also: dbcont, dbstep


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="dbstack" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function:  dbstack ()
 -- Loadable Function:  dbstack (N)
 -- Loadable Function: [STACK, IDX] = dbstack (...)
     Display or return current debugging function stack information.
     With optional argument N, omit the N innermost stack frames.

     The optional return argument STACK is a struct array with the
     following fields:

    file
          The name of the m-file where the function code is located.

    name
          The name of the function with a breakpoint.

    line
          The line number of an active breakpoint.

    column
          The column number of the line where the breakpoint begins.

    scope
          Undocumented.

    context
          Undocumented.

     The return argument IDX specifies which element of the STACK
     struct array is currently active.

     See also: dbup, dbdown, dbwhere, dbstatus


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="dbstatus" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function:  dbstatus ()
 -- Loadable Function: BRK_LIST = dbstatus ()
 -- Loadable Function: BRK_LIST = dbstatus ('FUNC')
     Report the location of active breakpoints.

     When called with no input or output arguments, print the list of
     all functions with breakpoints and the line numbers where those
     breakpoints are set.  If a function name FUNC is specified then
     only report breakpoints for the named function.

     The optional return argument BRK_LIST is a struct array with the
     following fields.

    name
          The name of the function with a breakpoint.

    file
          The name of the m-file where the function code is located.

    line
          A line number, or vector of line numbers, with a breakpoint.

     See also: dbclear, dbwhere


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="dbstep" func="yes">
            <Overload retVal="">
                <Param name="
 -- Command:  dbstep
 -- Command:  dbstep N
 -- Command:  dbstep in
 -- Command:  dbstep out
 -- Command:  dbnext ...
     In debugging mode, execute the next N lines of code.  If N is
     omitted, execute the next single line of code.  If the next line
     of code is itself defined in terms of an m-file remain in the
     existing function.

     Using 'dbstep in' will cause execution of the next line to step
     into any m-files defined on the next line.  Using 'dbstep out'
     will cause execution to continue until the current function
     returns.

     'dbnext' is an alias for 'dbstep'.

     See also: dbcont, dbquit


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="dbstop" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: RLINE = dbstop ('FUNC')
 -- Loadable Function: RLINE = dbstop ('FUNC', LINE, ...)
     Set a breakpoint in function FUNC.

     Arguments are

    FUNC
          Function name as a string variable.  When already in debug
          mode this should be left out and only the line should be
          given.

    LINE
          Line number where the breakpoint should be set.  Multiple
          lines may be given as separate arguments or as a vector.

     When called with a single argument FUNC, the breakpoint is set at
     the first executable line in the named function.

     The optional output RLINE is the real line number where the
     breakpoint was set.  This can differ from specified line if the
     line is not executable.  For example, if a breakpoint attempted on
     a blank line then Octave will set the real breakpoint at the next
     executable line.

     See also: dbclear, dbstatus, dbstep, debug_on_error,
     debug_on_warning, debug_on_interrupt
...

     USE help dbstop FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="dbtype" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function:  dbtype ()
 -- Loadable Function:  dbtype ('startl:endl')
 -- Loadable Function:  dbtype ('FUNC')
 -- Loadable Function:  dbtype ('FUNC', 'startl:endl')
     When in debugging mode and called with no arguments, list the
     script file being debugged with line numbers.  An optional range
     specification, specified as a string, can be used to list only a
     portion of the file.

     When called with the name of a function, list that script file
     with line numbers.

     See also: dbstatus, dbstop


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="dbup" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function:  dbup
 -- Loadable Function:  dbup (N)
     In debugging mode, move up the execution stack N frames.  If N is
     omitted, move up one frame.

     See also: dbstack, dbdown


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="dbwhere" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function:  dbwhere ()
     In debugging mode, report the current file and line number where
     execution is stopped.

     See also: dbstatus, dbcont, dbstep, dbup


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="deal" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [R1, R2, ..., RN] = deal (A)
 -- Function File: [R1, R2, ..., RN] = deal (A1, A2, ..., AN)
     Copy the input parameters into the corresponding output parameters.
     If only one input parameter is supplied, its value is copied to
     each of the outputs.

     For example,

          [a, b, c] = deal (x, y, z);

     is equivalent to

          a = x;
          b = y;
          c = z;

     and

          [a, b, c] = deal (x);

     is equivalent to

          a = b = c = x;

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="deblank" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  deblank (S)
     Remove trailing whitespace and nulls from S.  If S is a matrix,
     DEBLANK trims each row to the length of longest string.  If S is a
     cell array of strings, operate recursively on each string element.

     Examples:

          deblank ('    abc  ')
               =>  '    abc'

          deblank ([' abc   '; '   def   '])
               =>  [' abc  ' ; '   def']

     See also: strtrim


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="debug_on_error" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: VAL = debug_on_error ()
 -- Built-in Function: OLD_VAL = debug_on_error (NEW_VAL)
 -- Built-in Function:  debug_on_error (NEW_VAL, 'local')
     Query or set the internal variable that controls whether Octave
     will try to enter the debugger when an error is encountered.  This
     will also inhibit printing of the normal traceback message (you
     will only see the top-level error message).

     When called from inside a function with the 'local' option, the
     variable is changed locally for the function and any subroutines
     it calls.  The original variable value is restored when exiting
     the function.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="debug_on_interrupt" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: VAL = debug_on_interrupt ()
 -- Built-in Function: OLD_VAL = debug_on_interrupt (NEW_VAL)
 -- Built-in Function:  debug_on_interrupt (NEW_VAL, 'local')
     Query or set the internal variable that controls whether Octave
     will try to enter debugging mode when it receives an interrupt
     signal (typically generated with 'C-c').  If a second interrupt
     signal is received before reaching the debugging mode, a normal
     interrupt will occur.

     When called from inside a function with the 'local' option, the
     variable is changed locally for the function and any subroutines
     it calls.  The original variable value is restored when exiting
     the function.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="debug_on_warning" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: VAL = debug_on_warning ()
 -- Built-in Function: OLD_VAL = debug_on_warning (NEW_VAL)
 -- Built-in Function:  debug_on_warning (NEW_VAL, 'local')
     Query or set the internal variable that controls whether Octave
     will try to enter the debugger when a warning is encountered.

     When called from inside a function with the 'local' option, the
     variable is changed locally for the function and any subroutines
     it calls.  The original variable value is restored when exiting
     the function.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="dec2base" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  dec2base (D, BASE)
 -- Function File:  dec2base (D, BASE, LEN)
     Return a string of symbols in base BASE corresponding to the
     non-negative integer D.

          dec2base (123, 3)
             => '11120'

     If D is a matrix or cell array, return a string matrix with one
     row per element in D, padded with leading zeros to the width of
     the largest value.

     If BASE is a string then the characters of BASE are used as the
     symbols for the digits of D.  Space (' ') may not be used as a
     symbol.

          dec2base (123, 'aei')
             => 'eeeia'

     The optional third argument, LEN, specifies the minimum number of
     digits in the result.

     See also: base2dec, dec2bin, dec2hex


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="dec2bin" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  dec2bin (D, LEN)
     Return a binary number corresponding to the non-negative integer
     D, as a string of ones and zeros.  For example:

          dec2bin (14)
               => '1110'

     If D is a matrix or cell array, return a string matrix with one
     row per element in D, padded with leading zeros to the width of
     the largest value.

     The optional second argument, LEN, specifies the minimum number of
     digits in the result.

     See also: bin2dec, dec2base, dec2hex


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="dec2hex" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  dec2hex (D, LEN)
     Return the hexadecimal string corresponding to the non-negative
     integer D.  For example:

          dec2hex (2748)
               => 'ABC'

     If D is a matrix or cell array, return a string matrix with one
     row per element in D, padded with leading zeros to the width of
     the largest value.

     The optional second argument, LEN, specifies the minimum number of
     digits in the result.

     See also: hex2dec, dec2base, dec2bin


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="deconv" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  deconv (Y, A)
     Deconvolve two vectors.

     '[b, r] = deconv (y, a)' solves for B and R such that 'y = conv
     (a, b) + r'.

     If Y and A are polynomial coefficient vectors, B will contain the
     coefficients of the polynomial quotient and R will be a remainder
     polynomial of lowest order.

     See also: conv, residue


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="default_save_options" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: VAL = default_save_options ()
 -- Built-in Function: OLD_VAL = default_save_options (NEW_VAL)
 -- Built-in Function:  default_save_options (NEW_VAL, 'local')
     Query or set the internal variable that specifies the default
     options for the 'save' command, and defines the default format.
     Typical values include &quot;-ascii&quot;, &quot;-text -zip&quot;.  The default
     value is '-text'.

     When called from inside a function with the 'local' option, the
     variable is changed locally for the function and any subroutines
     it calls.  The original variable value is restored when exiting
     the function.

     See also: save


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="del2" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: D = del2 (M)
 -- Function File: D = del2 (M, H)
 -- Function File: D = del2 (M, DX, DY, ...)
     Calculate the discrete Laplace operator.  For a 2-dimensional
     matrix M this is defined as

                1    / d^2            d^2         \
          D  = --- * | ---  M(x,y) +  ---  M(x,y) |
                4    \ dx^2           dy^2        /

     For N-dimensional arrays the sum in parentheses is expanded to
     include second derivatives over the additional higher dimensions.

     The spacing between evaluation points may be defined by H, which
     is a scalar defining the equidistant spacing in all dimensions.
     Alternatively, the spacing in each dimension may be defined
     separately by DX, DY, etc.  A scalar spacing argument defines
     equidistant spacing, whereas a vector argument can be used to
     specify variable spacing.  The length of the spacing vectors must
     match the respective dimension of M.  The default spacing value is
     1.

...

     USE help del2 FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="delaunay" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  delaunay (X, Y)
 -- Function File: TRI = delaunay (X, Y)
 -- Function File: TRI = delaunay (X, Y, OPTIONS)
     Compute the Delaunay triangulation for a 2-D set of points.  The
     return value TRI is a set of triangles which satisfies the
     Delaunay circum-circle criterion, i.e., only a single data point
     from [X, Y] is within the circum-circle of the defining triangle.

     The set of triangles TRI is a matrix of size [n, 3].  Each row
     defines a triangle and the three columns are the three vertices of
     the triangle.  The value of 'TRI(i,j)' is an index into X and Y
     for the location of the j-th vertex of the i-th triangle.

     An optional third argument, which must be a string or cell array
     of strings, contains options passed to the underlying qhull
     command.  See the documentation for the Qhull library for details
     'http://www.qhull.org/html/qh-quick.htm#options'.  The default
     options are '{'Qt', 'Qbb', 'Qc', 'Qz'}'.

   ...

     USE help delaunay FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="delaunay3" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: TETR = delaunay3 (X, Y, Z)
 -- Function File: TETR = delaunay3 (X, Y, Z, OPTIONS)
     Compute the Delaunay triangulation for a 3-D set of points.  The
     return value TETR is a set of tetrahedrons which satisfies the
     Delaunay circum-circle criterion, i.e., only a single data point
     from [X, Y, Z] is within the circum-circle of the defining
     tetrahedron.

     The set of tetrahedrons TETR is a matrix of size [n, 4].  Each row
     defines a tetrahedron and the four columns are the four vertices
     of the tetrahedron.  The value of 'TETR(i,j)' is an index into X,
     Y, Z for the location of the j-th vertex of the i-th tetrahedron.

     An optional fourth argument, which must be a string or cell array
     of strings, contains options passed to the underlying qhull
     command.  See the documentation for the Qhull library for details
     'http://www.qhull.org/html/qh-quick.htm#options'.  The default
     options are '{'Qt', 'Qbb', 'Qc', 'Qz'}'.

 ...

     USE help delaunay3 FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="delaunayn" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: T = delaunayn (PTS)
 -- Function File: T = delaunayn (PTS, OPTIONS)
     Compute the Delaunay triangulation for an N-dimensional set of
     points.  The Delaunay triangulation is a tessellation of the
     convex hull of a set of points such that no N-sphere defined by
     the N-triangles contains any other points from the set.

     The input matrix PTS of size [n, dim] contains n points in a space
     of dimension dim.  The return matrix T has size [m, dim+1].  Each
     row of T contains a set of indices back into the original set of
     points PTS which describes a simplex of dimension dim.  For
     example, a 2-D simplex is a triangle and 3-D simplex is a
     tetrahedron.

     An optional second argument, which must be a string or cell array
     of strings, contains options passed to the underlying qhull
     command.  See the documentation for the Qhull library for details
     'http://www.qhull.org/html/qh-quick.htm#options'.  The default
     options ...

     USE help delaunayn FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="delete" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  delete (FILE)
 -- Function File:  delete (HANDLE)
     Delete the named file or graphics handle.

     Deleting graphics objects is the proper way to remove features
     from a plot without clearing the entire figure.

     See also: clf, cla, unlink


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="dellistener" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  dellistener (H, PROP, FCN)
     Remove the registration of FCN as a listener for the property PROP
     of the graphics object H.  The function FCN must be the same
     variable (not just the same value), as was passed to the original
     call to 'addlistener'.

     If FCN is not defined then all listener functions of PROP are
     removed.

     Example:

          function my_listener (h, dummy, p1)
           fprintf ('my_listener called with p1=%s\n', p1);
          endfunction

          c = {@my_listener, 'my string'};
          addlistener (gcf, 'position', c);
          dellistener (gcf, 'position', c);


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="demo" func="yes">
            <Overload retVal="">
                <Param name="
 -- Command:  demo NAME
 -- Command:  demo NAME N
 -- Function File:  demo ('NAME')
 -- Function File:  demo ('NAME', N)
     Run example code block N associated with the function NAME.  If N
     is not specified, all examples are run.

     Examples are stored in the script file, or in a file with the same
     name but no extension located on Octave's load path.  To keep
     examples separate from regular script code, all lines are prefixed
     by '%!'.  Each example must also be introduced by the keyword
     'demo' flush left to the prefix with no intervening spaces.  The
     remainder of the example can contain arbitrary Octave code.  For
     example:

          %!demo
          %! t=0:0.01:2*pi; x = sin (t);
          %! plot (t,x)
          %! %-------------------------------------------------
          %! % the figure window shows one cycle of a sine wave

     Note that the code is displayed before it is executed, so a simple
     comment at the end suffices for labeling ...

     USE help demo FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="det" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function:  det (A)
 -- Loadable Function: [D, RCOND] = det (A)
     Compute the determinant of A.

     Return an estimate of the reciprocal condition number if requested.

     Routines from LAPACK are used for full matrices and code from
     UMFPACK is used for sparse matrices.

     The determinant should not be used to check a matrix for
     singularity.  For that, use any of the condition number functions:
     'cond', 'condest', 'rcond'.

     See also: cond, condest, rcond


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="detrend" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  detrend (X, P)
     If X is a vector, 'detrend (X, P)' removes the best fit of a
     polynomial of order P from the data X.

     If X is a matrix, 'detrend (X, P)' does the same for each column
     in X.

     The second argument is optional.  If it is not specified, a value
     of 1 is assumed.  This corresponds to removing a linear trend.

     The order of the polynomial can also be given as a string, in
     which case P must be either 'constant' (corresponds to 'P=0') or
     'linear' (corresponds to 'P=1').

     See also: polyfit


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="diag" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: M = diag (V)
 -- Built-in Function: M = diag (V, K)
 -- Built-in Function: M = diag (V, M, N)
 -- Built-in Function: V = diag (M)
 -- Built-in Function: V = diag (M, K)
     Return a diagonal matrix with vector V on diagonal K.  The second
     argument is optional.  If it is positive, the vector is placed on
     the K-th super-diagonal.  If it is negative, it is placed on the
     -K-th sub-diagonal.  The default value of K is 0, and the vector
     is placed on the main diagonal.  For example:

          diag ([1, 2, 3], 1)
              =>  0  1  0  0
                  0  0  2  0
                  0  0  0  3
                  0  0  0  0

     The 3-input form returns a diagonal matrix with vector V on the
     main diagonal and the resulting matrix being of size M rows x N
     columns.

     Given a matrix argument, instead of a vector, 'diag' extracts the
     K-th diagonal of the matrix.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="diary" func="yes">
            <Overload retVal="">
                <Param name="
 -- Command:  diary options
     Record a list of all commands _and_ the output they produce, mixed
     together just as you see them on your terminal.  Valid options are:

    'on'
          Start recording your session in a file called 'diary' in your
          current working directory.

    'off'
          Stop recording your session in the diary file.

    'FILE'
          Record your session in the file named FILE.

     With no arguments, 'diary' toggles the current diary state.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="diff" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  diff (X)
 -- Built-in Function:  diff (X, K)
 -- Built-in Function:  diff (X, K, DIM)
     If X is a vector of length n, 'diff (X)' is the vector of first
     differences X(2) - X(1), ..., X(n) - X(n-1).

     If X is a matrix, 'diff (X)' is the matrix of column differences
     along the first non-singleton dimension.

     The second argument is optional.  If supplied, 'diff (X, K)',
     where K is a non-negative integer, returns the K-th differences.
     It is possible that K is larger than the first non-singleton
     dimension of the matrix.  In this case, 'diff' continues to take
     the differences along the next non-singleton dimension.

     The dimension along which to take the difference can be explicitly
     stated with the optional variable DIM.  In this case the K-th
     order differences are calculated along this dimension.  In the
     case where K exceeds 'size (X, DIM)' an empty matrix is returned.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="diffpara" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [D, DD] = diffpara (X, A, B)
     Return the estimator D for the differencing parameter of an
     integrated time series.

     The frequencies from [2*pi*a/t, 2*pi*b/T] are used for the
     estimation.  If B is omitted, the interval [2*pi/T, 2*pi*a/T] is
     used.  If both B and A are omitted then a = 0.5 * sqrt (T) and b =
     1.5 * sqrt (T) is used, where T is the sample size.  If X is a
     matrix, the differencing parameter of each column is estimated.

     The estimators for all frequencies in the intervals described
     above is returned in DD.  The value of D is simply the mean of DD.

     Reference: P.J. Brockwell &amp; R.A. Davis. 'Time Series: Theory and
     Methods'. Springer 1987.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="diffuse" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  diffuse (SX, SY, SZ, LV)
     Calculate diffuse reflection strength of a surface defined by the
     normal vector elements SX, SY, SZ.  The light vector can be
     specified using parameter LV.  It can be given as 2-element vector
     [azimuth, elevation] in degrees or as 3-element vector [lx, ly,
     lz].

     See also: specular, surfl


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="dir" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  dir (DIRECTORY)
 -- Function File: [LIST] = dir (DIRECTORY)
     Display file listing for directory DIRECTORY.  If a return value
     is requested, return a structure array with the fields

          name
          bytes
          date
          isdir
          statinfo

     where 'statinfo' is the structure returned from 'stat'.

     If DIRECTORY is not a directory, return information about the
     named FILENAME.  DIRECTORY may be a list of directories specified
     either by name or with wildcard characters (like * and ?)  which
     will be expanded with glob.

     Note that for symbolic links, 'dir' returns information about the
     file that the symbolic link points to instead of the link itself.
     However, if the link points to a nonexistent file, 'dir' returns
     information about the link.

     See also: ls, stat, lstat, readdir, glob, filesep


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="discrete_cdf" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  discrete_cdf (X, V, P)
     For each element of X, compute the cumulative distribution
     function (CDF) at X of a univariate discrete distribution which
     assumes the values in V with probabilities P.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="discrete_inv" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  discrete_inv (X, V, P)
     For each element of X, compute the quantile (the inverse of the
     CDF) at X of the univariate distribution which assumes the values
     in V with probabilities P.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="discrete_pdf" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  discrete_pdf (X, V, P)
     For each element of X, compute the probability density function
     (PDF) at X of a univariate discrete distribution which assumes the
     values in V with probabilities P.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="discrete_rnd" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  discrete_rnd (V, P)
 -- Function File:  discrete_rnd (V, P, R)
 -- Function File:  discrete_rnd (V, P, R, C, ...)
 -- Function File:  discrete_rnd (V, P, [SZ])
     Return a matrix of random samples from the univariate distribution
     which assumes the values in V with probabilities P.

     When called with a single size argument, return a square matrix
     with the dimension specified.  When called with more than one
     scalar argument the first two arguments are taken as the number of
     rows and columns and any further arguments specify additional
     matrix dimensions.  The size may also be specified with a vector
     of dimensions SZ.

     If no size arguments are given then the result matrix is the
     common size of V and P.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="disp" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  disp (X)
     Display the value of X.  For example:

          disp ('The value of pi is:'), disp (pi)

              -| the value of pi is:
              -| 3.1416

     Note that the output from 'disp' always ends with a newline.

     If an output value is requested, 'disp' prints nothing and returns
     the formatted output in a string.

     See also: fdisp


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="display" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  display (A)
     Display the contents of an object.  If A is an object of the class
     'myclass', then 'display' is called in a case like

          myclass (...)

     where Octave is required to display the contents of a variable of
     the type 'myclass'.

     See also: class, subsref, subsasgn


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="divergence" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: DIV = divergence (X, Y, Z, FX, FY, FZ)
 -- Function File: DIV = divergence (FX, FY, FZ)
 -- Function File: DIV = divergence (X, Y, FX, FY)
 -- Function File: DIV = divergence (FX, FY)
     Calculate divergence of a vector field given by the arrays FX, FY,
     and FZ or FX, FY respectively.

                            d               d               d
          div F(x,y,z)  =   -- F(x,y,z)  +  -- F(x,y,z)  +  -- F(x,y,z)
                            dx              dy              dz

     The coordinates of the vector field can be given by the arguments
     X, Y, Z or X, Y respectively.

     See also: curl, gradient, del2, dot


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="dlmread" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: DATA = dlmread (FILE)
 -- Loadable Function: DATA = dlmread (FILE, SEP)
 -- Loadable Function: DATA = dlmread (FILE, SEP, R0, C0)
 -- Loadable Function: DATA = dlmread (FILE, SEP, RANGE)
 -- Loadable Function: DATA = dlmread (..., 'emptyvalue', EMPTYVAL)
     Read the matrix DATA from a text file.  If not defined the
     separator between fields is determined from the file itself.
     Otherwise the separation character is defined by SEP.

     Given two scalar arguments R0 and C0, these define the starting
     row and column of the data to be read.  These values are indexed
     from zero, such that the first row corresponds to an index of zero.

     The RANGE parameter may be a 4-element vector containing the upper
     left and lower right corner '[R0,C0,R1,C1]' where the lowest index
     value is zero.  Alternatively, a spreadsheet style range such as
     'A2..Q15' or 'T1:AA5' can be used.  The lowest alphabetical index
     'A' refers to the first colum...

     USE help dlmread FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="dlmwrite" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  dlmwrite (FILE, M)
 -- Function File:  dlmwrite (FILE, M, DELIM, R, C)
 -- Function File:  dlmwrite (FILE, M, KEY, VAL ...)
 -- Function File:  dlmwrite (FILE, M, '-append', ...)
 -- Function File:  dlmwrite (FID, ...)
     Write the matrix M to the named file using delimiters.

     FILE should be a file name or writable file ID given by 'fopen'.

     The parameter DELIM specifies the delimiter to use to separate
     values on a row.

     The value of R specifies the number of delimiter-only lines to add
     to the start of the file.

     The value of C specifies the number of delimiters to prepend to
     each line of data.

     If the argument &quot;-append&quot; is given, append to the end of FILE.

     In addition, the following keyword value pairs may appear at the
     end of the argument list:

    'append'
          Either &quot;on&quot; or &quot;off&quot;.  See &quot;-append&quot; above.

    'delimiter'
          See DELIM above.

    'newline'
          The character(s) to use t...

     USE help dlmwrite FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="dlqr" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [G, X, L] = dlqr (SYS, Q, R)
 -- Function File: [G, X, L] = dlqr (SYS, Q, R, S)
 -- Function File: [G, X, L] = dlqr (A, B, Q, R)
 -- Function File: [G, X, L] = dlqr (A, B, Q, R, S)
 -- Function File: [G, X, L] = dlqr (A, B, Q, R, [], E)
 -- Function File: [G, X, L] = dlqr (A, B, Q, R, S, E)
     Linear-quadratic regulator for discrete-time systems.

     *Inputs*
    SYS
          Continuous or discrete-time LTI model.

    A
          State transition matrix of discrete-time system.

    B
          Input matrix of discrete-time system.

    Q
          State weighting matrix.

    R
          Input weighting matrix.

    S
          Optional cross term matrix.  If S is not specified, a zero
          matrix is assumed.

    E
          Optional descriptor matrix.  If E is not specified, an
          identity matrix is assumed.

     *Outputs*
    G
          State feedback matrix.

    X
          Unique stabilizing solution of the discrete-time Riccati
          e...

     USE help dlqr FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="dlyap" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: X = dlyap (A, B)
 -- Function File: X = dlyap (A, B, C)
 -- Function File: X = dlyap (A, B, [], E)
     Solve discrete-time Lyapunov or Sylvester equations.

     *Equations*
          AXA' - X + B = 0      (Lyapunov Equation)

          AXB' - X + C = 0      (Sylvester Equation)

          AXA' - EXE' + B = 0   (Generalized Lyapunov Equation)

     *Algorithm*
     Uses SLICOT SB03MD, SB04QD and SG03AD by courtesy of NICONET e.V.
     (http://www.slicot.org)

     See also: dlyapchol, lyap, lyapchol


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="dlyapchol" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: U = dlyapchol (A, B)
 -- Function File: U = dlyapchol (A, B, E)
     Compute Cholesky factor of discrete-time Lyapunov equations.

     *Equations*
          A U' U A'  -  U' U  +  B B'  =  0           (Lyapunov Equation)

          A U' U A'  -  E U' U E'  +  B B'  =  0      (Generalized Lyapunov Equation)

     *Algorithm*
     Uses SLICOT SB03OD and SG03BD by courtesy of NICONET e.V.
     (http://www.slicot.org)

     See also: dlyap, lyap, lyapchol


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="dmperm" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: P = dmperm (S)
 -- Loadable Function: [P, Q, R, S] = dmperm (S)
     Perform a Dulmage-Mendelsohn permutation of the sparse matrix S.
     With a single output argument 'dmperm' performs the row
     permutations P such that 'S(P,:)' has no zero elements on the
     diagonal.

     Called with two or more output arguments, returns the row and
     column permutations, such that 'S(P, Q)' is in block triangular
     form.  The values of R and S define the boundaries of the blocks.
     If S is square then 'R == S'.

     The method used is described in: A. Pothen &amp; C.-J. Fan. 'Computing
     the Block Triangular Form of a Sparse Matrix'. ACM Trans. Math.
     Software, 16(4):303-324, 1990.

     See also: colamd, ccolamd


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="do_braindead_shortcircuit_evaluation" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: VAL = do_braindead_shortcircuit_evaluation ()
 -- Built-in Function: OLD_VAL = do_braindead_shortcircuit_evaluation
          (NEW_VAL)
 -- Built-in Function:  do_braindead_shortcircuit_evaluation (NEW_VAL,
          'local')
     Query or set the internal variable that controls whether Octave
     will do short-circuit evaluation of '|' and '&amp;' operators inside
     the conditions of if or while statements.

     This feature is only provided for compatibility with MATLAB and
     should not be used unless you are porting old code that relies on
     this feature.

     To obtain short-circuit behavior for logical expressions in new
     programs, you should always use the '&amp;&amp;' and '||' operators.

     When called from inside a function with the 'local' option, the
     variable is changed locally for the function and any subroutines
     it calls.  The original variable value is restored when exiting
     the function.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="do_string_escapes" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  do_string_escapes (STRING)
     Convert special characters in STRING to their escaped forms.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="doc" func="yes">
            <Overload retVal="">
                <Param name="
 -- Command:  doc FUNCTION_NAME
     Display documentation for the function FUNCTION_NAME directly from
     an on-line version of the printed manual, using the GNU Info
     browser.  If invoked without any arguments, the manual is shown
     from the beginning.

     For example, the command 'doc rand' starts the GNU Info browser at
     the 'rand' node in the on-line version of the manual.

     Once the GNU Info browser is running, help for using it is
     available using the command 'C-h'.

     See also: help


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="doc_cache_file" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: VAL = doc_cache_file ()
 -- Built-in Function: OLD_VAL = doc_cache_file (NEW_VAL)
 -- Built-in Function:  doc_cache_file (NEW_VAL, 'local')
     Query or set the internal variable that specifies the name of the
     Octave documentation cache file.  A cache file significantly
     improves the performance of the 'lookfor' command.  The default
     value is 'OCTAVE-HOME/share/octave/VERSION/etc/doc-cache', in
     which OCTAVE-HOME is the root directory of the Octave installation,
     and VERSION is the Octave version number.  The default value may
     be overridden by the environment variable 'OCTAVE_DOC_CACHE_FILE',
     or the command line argument '--doc-cache-file NAME'.

     When called from inside a function with the 'local' option, the
     variable is changed locally for the function and any subroutines
     it calls.  The original variable value is restored when exiting
     the function.

     See also: lookfor, info_program, doc, help, makeinfo_pro...

     USE help doc_cache_file FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="dos" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  dos ('COMMAND')
 -- Function File: STATUS = dos ('COMMAND')
 -- Function File: [STATUS, TEXT] = dos ('COMMAND')
 -- Function File: [...] = dos ('COMMAND', '-echo')
     Execute a system command if running under a Windows-like operating
     system, otherwise do nothing.  Return the exit status of the
     program in STATUS and any output from the command in TEXT.  When
     called with no output argument, or the '-echo' argument is given,
     then TEXT is also sent to standard output.

     See also: unix, system, isunix, ispc


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="dot" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function:  dot (X, Y, DIM)
     Compute the dot product of two vectors.  If X and Y are matrices,
     calculate the dot products along the first non-singleton
     dimension.  If the optional argument DIM is given, calculate the
     dot products along this dimension.

     This is equivalent to 'sum (conj (X) .* Y, DIM)', but avoids
     forming a temporary array and is faster.  When X and Y are column
     vectors, the result is equivalent to 'X' * Y'.

     See also: cross, divergence


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="double" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  double (X)
     Convert X to double precision type.

     See also: single


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="drawnow" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  drawnow ()
 -- Built-in Function:  drawnow ('expose')
 -- Built-in Function:  drawnow (TERM, FILE, MONO, DEBUG_FILE)
     Update figure windows and their children.  The event queue is
     flushed and any callbacks generated are executed.  With the
     optional argument &quot;expose&quot;, only graphic objects are updated and
     no other events or callbacks are processed.  The third calling
     form of 'drawnow' is for debugging and is undocumented.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="dsearch" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: IDX = dsearch (X, Y, TRI, XI, YI)
 -- Function File: IDX = dsearch (X, Y, TRI, XI, YI, S)
     Return the index IDX or the closest point in 'X, Y' to the
     elements '[XI(:), YI(:)]'.  The variable S is accepted for
     compatibility but is ignored.

     See also: dsearchn, tsearch


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="dsearchn" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: IDX = dsearchn (X, TRI, XI)
 -- Function File: IDX = dsearchn (X, TRI, XI, OUTVAL)
 -- Function File: IDX = dsearchn (X, XI)
 -- Function File: [IDX, D] = dsearchn (...)
     Return the index IDX or the closest point in X to the elements XI.
     If OUTVAL is supplied, then the values of XI that are not
     contained within one of the simplices TRI are set to OUTVAL.
     Generally, TRI is returned from 'delaunayn (X)'.

     See also: dsearch, tsearch


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="dss" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: SYS = dss (SYS)
 -- Function File: SYS = dss (D)
 -- Function File: SYS = dss (A, B, C, D, E, ...)
 -- Function File: SYS = dss (A, B, C, D, E, TSAM, ...)
     Create or convert to descriptor state-space model.

     *Inputs*
    SYS
          LTI model to be converted to state-space.

    A
          State transition matrix (n-by-n).

    B
          Input matrix (n-by-m).

    C
          Measurement matrix (p-by-n).

    D
          Feedthrough matrix (p-by-m).

    E
          Descriptor matrix (n-by-n).

    TSAM
          Sampling time in seconds.  If TSAM is not specified, a
          continuous-time model is assumed.

    ...
          Optional pairs of properties and values.  Type 'set (dss)'
          for more information.

     *Outputs*
    SYS
          Descriptor state-space model.

     *Equations*
            .
          E x = A x + B u
            y = C x + D u

     See also: ss, tf


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="dump_prefs" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  dump_prefs ()
 -- Function File:  dump_prefs (FID)
     Dump all of the current user preference variables in a format that
     can be parsed by Octave later.  FID is a file descriptor as
     returned by 'fopen'.  If FILE is omitted, the listing is printed
     to stdout.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="dup2" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: [FID, MSG] = dup2 (OLD, NEW)
     Duplicate a file descriptor.

     If successful, FID is greater than zero and contains the new file
     ID.  Otherwise, FID is negative and MSG contains a
     system-dependent error message.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="duplication_matrix" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  duplication_matrix (N)
     Return the duplication matrix  Dn  which is the unique  n^2 by
     n*(n+1)/2  matrix such that  Dn vech (A) = vec (A)  for all
     symmetric  n by n  matrices  A.

     See Magnus and Neudecker (1988), Matrix differential calculus with
     applications in statistics and econometrics.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="durbinlevinson" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  durbinlevinson (C, OLDPHI, OLDV)
     Perform one step of the Durbin-Levinson algorithm.

     The vector C specifies the autocovariances '[gamma_0, ...,
     gamma_t]' from lag 0 to T, OLDPHI specifies the coefficients based
     on C(T-1) and OLDV specifies the corresponding error.

     If OLDPHI and OLDV are omitted, all steps from 1 to T of the
     algorithm are performed.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="e" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  e
 -- Built-in Function:  e (N)
 -- Built-in Function:  e (N, M)
 -- Built-in Function:  e (N, M, K, ...)
 -- Built-in Function:  e (..., CLASS)
     Return a scalar, matrix, or N-dimensional array whose elements are
     all equal to the base of natural logarithms.  The constant 'e'
     satisfies the equation 'log' (e) = 1.

     When called with no arguments, return a scalar with the value e.
     When called with a single argument, return a square matrix with
     the dimension specified.  When called with more than one scalar
     argument the first two arguments are taken as the number of rows
     and columns and any further arguments specify additional matrix
     dimensions.  The optional argument CLASS specifies the return type
     and may be either 'double' or 'single'.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="echo" func="yes">
            <Overload retVal="">
                <Param name="
 -- Command:  echo options
     Control whether commands are displayed as they are executed.  Valid
     options are:

    'on'
          Enable echoing of commands as they are executed in script
          files.

    'off'
          Disable echoing of commands as they are executed in script
          files.

    'on all'
          Enable echoing of commands as they are executed in script
          files and functions.

    'off all'
          Disable echoing of commands as they are executed in script
          files and functions.

     With no arguments, 'echo' toggles the current echo state.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="echo_executing_commands" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: VAL = echo_executing_commands ()
 -- Built-in Function: OLD_VAL = echo_executing_commands (NEW_VAL)
 -- Built-in Function:  echo_executing_commands (NEW_VAL, 'local')
     Query or set the internal variable that controls the echo state.
     It may be the sum of the following values:

    1
          Echo commands read from script files.

    2
          Echo commands from functions.

    4
          Echo commands read from command line.

     More than one state can be active at once.  For example, a value
     of 3 is equivalent to the command 'echo on all'.

     The value of 'echo_executing_commands' may be set by the 'echo'
     command or the command line option '--echo-commands'.

     When called from inside a function with the 'local' option, the
     variable is changed locally for the function and any subroutines
     it calls.  The original variable value is restored when exiting
     the function.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="edit" func="yes">
            <Overload retVal="">
                <Param name="
 -- Command:  edit NAME
 -- Command:  edit FIELD VALUE
 -- Command: VALUE = edit get FIELD
     Edit the named function, or change editor settings.

     If 'edit' is called with the name of a file or function as its
     argument it will be opened in a text editor.

        * If the function NAME is available in a file on your path and
          that file is modifiable, then it will be edited in place.  If
          it is a system function, then it will first be copied to the
          directory 'HOME' (see further down) and then edited.  If no
          file is found, then the m-file variant, ending with '.m',
          will be considered.  If still no file is found, then variants
          with a leading '@' and then with both a leading '@' and
          trailing '.m' will be considered.

        * If NAME is the name of a function defined in the interpreter
          but not in an m-file, then an m-file will be created in 'HOME'
          to contain that function along with its cur...

     USE help edit FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="edit_history" func="yes">
            <Overload retVal="">
                <Param name="
 -- Command:  edit_history [FIRST] [LAST]
     If invoked with no arguments, 'edit_history' allows you to edit the
     history list using the editor named by the variable 'EDITOR'.  The
     commands to be edited are first copied to a temporary file.  When
     you exit the editor, Octave executes the commands that remain in
     the file.  It is often more convenient to use 'edit_history' to
     define functions rather than attempting to enter them directly on
     the command line.  By default, the block of commands is executed
     as soon as you exit the editor.  To avoid executing any commands,
     simply delete all the lines from the buffer before exiting the
     editor.

     The 'edit_history' command takes two optional arguments specifying
     the history numbers of first and last commands to edit.  For
     example, the command

          edit_history 13

     extracts all the commands from the 13th through the last in the
     history list.  The command

          edit_...

     USE help edit_history FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="EDITOR" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: VAL = EDITOR ()
 -- Built-in Function: OLD_VAL = EDITOR (NEW_VAL)
 -- Built-in Function:  EDITOR (NEW_VAL, 'local')
     Query or set the internal variable that specifies the editor to
     use with the 'edit_history' command.  The default value is taken
     from the environment variable 'EDITOR' when Octave starts.  If the
     environment variable is not initialized, 'EDITOR' will be set to
     &quot;emacs&quot;.

     When called from inside a function with the 'local' option, the
     variable is changed locally for the function and any subroutines
     it calls.  The original variable value is restored when exiting
     the function.

     See also: edit_history


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="eig" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: LAMBDA = eig (A)
 -- Loadable Function: LAMBDA = eig (A, B)
 -- Loadable Function: [V, LAMBDA] = eig (A)
 -- Loadable Function: [V, LAMBDA] = eig (A, B)
     Compute the eigenvalues and eigenvectors of a matrix.

     Eigenvalues are computed in a several step process which begins
     with a Hessenberg decomposition, followed by a
     Schur decomposition, from which the eigenvalues are apparent.  The
     eigenvectors, when desired, are computed by further manipulations
     of the Schur decomposition.

     The eigenvalues returned by 'eig' are not ordered.

     See also: eigs, svd


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="eigs" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: D = eigs (A)
 -- Loadable Function: D = eigs (A, K)
 -- Loadable Function: D = eigs (A, K, SIGMA)
 -- Loadable Function: D = eigs (A, K, SIGMA, OPTS)
 -- Loadable Function: D = eigs (A, B)
 -- Loadable Function: D = eigs (A, B, K)
 -- Loadable Function: D = eigs (A, B, K, SIGMA)
 -- Loadable Function: D = eigs (A, B, K, SIGMA, OPTS)
 -- Loadable Function: D = eigs (AF, N)
 -- Loadable Function: D = eigs (AF, N, B)
 -- Loadable Function: D = eigs (AF, N, K)
 -- Loadable Function: D = eigs (AF, N, B, K)
 -- Loadable Function: D = eigs (AF, N, K, SIGMA)
 -- Loadable Function: D = eigs (AF, N, B, K, SIGMA)
 -- Loadable Function: D = eigs (AF, N, K, SIGMA, OPTS)
 -- Loadable Function: D = eigs (AF, N, B, K, SIGMA, OPTS)
 -- Loadable Function: [V, D] = eigs (A, ...)
 -- Loadable Function: [V, D] = eigs (AF, N, ...)
 -- Loadable Function: [V, D, FLAG] = eigs (A, ...)
 -- Loadable Function: [V, D, FLAG] = eigs (AF, N, ...)
     Calculate a limited number of eigenvalues a...

     USE help eigs FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="ellipsoid" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [X, Y, Z] = ellipsoid (XC, YC, ZC, XR, YR, ZR, N)
 -- Function File:  ellipsoid (H, ...)
     Generate three matrices in 'meshgrid' format that define an
     ellipsoid.  Called with no return arguments, 'ellipsoid' calls
     directly 'surf (X, Y, Z)'.  If an axes handle is passed as the
     first argument, the surface is plotted to this set of axes.

     See also: sphere


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="empirical_cdf" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  empirical_cdf (X, DATA)
     For each element of X, compute the cumulative distribution
     function (CDF) at X of the empirical distribution obtained from
     the univariate sample DATA.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="empirical_inv" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  empirical_inv (X, DATA)
     For each element of X, compute the quantile (the inverse of the
     CDF) at X of the empirical distribution obtained from the
     univariate sample DATA.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="empirical_pdf" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  empirical_pdf (X, DATA)
     For each element of X, compute the probability density function
     (PDF) at X of the empirical distribution obtained from the
     univariate sample DATA.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="empirical_rnd" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  empirical_rnd (DATA)
 -- Function File:  empirical_rnd (DATA, R)
 -- Function File:  empirical_rnd (DATA, R, C, ...)
 -- Function File:  empirical_rnd (DATA, [SZ])
     Return a matrix of random samples from the empirical distribution
     obtained from the univariate sample DATA.

     When called with a single size argument, return a square matrix
     with the dimension specified.  When called with more than one
     scalar argument the first two arguments are taken as the number of
     rows and columns and any further arguments specify additional
     matrix dimensions.  The size may also be specified with a vector
     of dimensions SZ.

     If no size arguments are given then the result matrix is a random
     ordering of the sample DATA.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="endgrent" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function:  endgrent ()
     Close the group database.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="endpwent" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function:  endpwent ()
     Close the password database.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="eomday" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: E = eomday (Y, M)
     Return the last day of the month M for the year Y.

     See also: weekday, datenum, datevec, is_leap_year, calendar


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="eps" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  eps
 -- Built-in Function:  eps (X)
 -- Built-in Function:  eps (N, M)
 -- Built-in Function:  eps (N, M, K, ...)
 -- Built-in Function:  eps (..., CLASS)
     Return a scalar, matrix or N-dimensional array whose elements are
     all eps, the machine precision.  More precisely, 'eps' is the
     relative spacing between any two adjacent numbers in the machine's
     floating point system.  This number is obviously system dependent.
     On machines that support IEEE floating point arithmetic, 'eps' is
     approximately 2.2204e-16 for double precision and 1.1921e-07 for
     single precision.

     When called with no arguments, return a scalar with the value
     'eps(1.0)'.  Given a single argument X, return the distance
     between X and the next largest value.  When called with more than
     one argument the first two arguments are taken as the number of
     rows and columns and any further arguments specify additional
     matrix dimensions.  The option...

     USE help eps FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="eq" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  eq (X, Y)
     Return true if the two inputs are equal.  This function is
     equivalent to 'x == y'.

     See also: ne, isequal


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="erf" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  erf (Z)
     Compute the error function,

                                   z
                                  /
          erf (z) = (2/sqrt (pi)) | e^(-t^2) dt
                                  /
                               t=0

     See also: erfc, erfcx, erfinv


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="erfc" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  erfc (Z)
     Compute the complementary error function, '1 - erf (Z)'.

     See also: erfcx, erf, erfinv


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="erfcx" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  erfcx (Z)
     Compute the scaled complementary error function,

          exp (z^2) * erfc (x)

     See also: erfc, erf, erfinv


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="erfinv" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  erfinv (X)
     Compute the inverse error function, i.e., Y such that

           erf (Y) == X

     See also: erf, erfc, erfcx


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="errno" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: ERR = errno ()
 -- Built-in Function: ERR = errno (VAL)
 -- Built-in Function: ERR = errno (NAME)
     Return the current value of the system-dependent variable errno,
     set its value to VAL and return the previous value, or return the
     named error code given NAME as a character string, or -1 if NAME
     is not found.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="errno_list" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  errno_list ()
     Return a structure containing the system-dependent errno values.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="error" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  error (TEMPLATE, ...)
 -- Built-in Function:  error (ID, TEMPLATE, ...)
     Format the optional arguments under the control of the template
     string TEMPLATE using the same rules as the 'printf' family of
     functions (*note Formatted Output::) and print the resulting
     message on the 'stderr' stream.  The message is prefixed by the
     character string 'error: '.

     Calling 'error' also sets Octave's internal error state such that
     control will return to the top level without evaluating any more
     commands.  This is useful for aborting from functions or scripts.

     If the error message does not end with a new line character,
     Octave will print a traceback of all the function calls leading to
     the error.  For example, given the following function definitions:

          function f () g (); end
          function g () h (); end
          function h () nargin == 1 || error ('nargin != 1'); end

     calling the function 'f' will resu...

     USE help error FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="errorbar" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  errorbar (ARGS)
     This function produces two-dimensional plots with errorbars.  Many
     different combinations of arguments are possible.  The simplest
     form is

          errorbar (Y, EY)

     where the first argument is taken as the set of Y coordinates and
     the second argument EY is taken as the errors of the Y values.  X
     coordinates are taken to be the indices of the elements, starting
     with 1.

     If more than two arguments are given, they are interpreted as

          errorbar (X, Y, ..., FMT, ...)

     where after X and Y there can be up to four error parameters such
     as EY, EX, LY, UY, etc., depending on the plot type.  Any number
     of argument sets may appear, as long as they are separated with a
     format string FMT.

     If Y is a matrix, X and error parameters must also be matrices
     having same dimensions.  The columns of Y are plotted versus the
     corresponding columns of X and errorbars are drawn from the
    ...

     USE help errorbar FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="estim" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: EST = estim (SYS, L)
 -- Function File: EST = estim (SYS, L, SENSORS, KNOWN)
     Return state estimator for a given estimator gain.

     *Inputs*
    SYS
          LTI model.

    L
          State feedback matrix.

    SENSORS
          Indices of measured output signals y from SYS.  If omitted,
          all outputs are measured.

    KNOWN
          Indices of known input signals u (deterministic) to SYS.  All
          other inputs to SYS are assumed stochastic.  If argument
          KNOWN is omitted, no inputs u are known.

     *Outputs*
    EST
          State-space model of estimator.

     See also: kalman, place


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="etime" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  etime (T2, T1)
     Return the difference in seconds between two time values returned
     from 'clock' (T2 - T1).  For example:

          t0 = clock ();
          # many computations later...
          elapsed_time = etime (clock (), t0);

     will set the variable 'elapsed_time' to the number of seconds since
     the variable 't0' was set.

     See also: tic, toc, clock, cputime, addtodate


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="etree" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: P = etree (S)
 -- Loadable Function: P = etree (S, TYP)
 -- Loadable Function: [P, Q] = etree (S, TYP)
     Return the elimination tree for the matrix S.  By default S is
     assumed to be symmetric and the symmetric elimination tree is
     returned.  The argument TYP controls whether a symmetric or column
     elimination tree is returned.  Valid values of TYP are 'sym' or
     'col', for symmetric or column elimination tree respectively

     Called with a second argument, 'etree' also returns the postorder
     permutations on the tree.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="etreeplot" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  etreeplot (A)
 -- Function File:  etreeplot (A, NODE_STYLE, EDGE_STYLE)
     Plot the elimination tree of the matrix A or A+A' if A in not
     symmetric.  The optional parameters NODE_STYLE and EDGE_STYLE
     define the output style.

     See also: treeplot, gplot


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="eval" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  eval (TRY)
 -- Built-in Function:  eval (TRY, CATCH)
     Parse the string TRY and evaluate it as if it were an Octave
     program.  If that fails, evaluate the optional string CATCH.  The
     string TRY is evaluated in the current context, so any results
     remain available after 'eval' returns.

     The following example makes the variable A with the approximate
     value 3.1416 available.

          eval('a = acos(-1);');

     If an error occurs during the evaluation of TRY the CATCH string
     is evaluated, as the following example shows:

          eval ('error ('This is a bad example');',
               'printf ('This error occurred:\n%s\n', lasterr ());');
              -| This error occurred:
                 This is a bad example

     Consider using try/catch blocks instead if you are only using
     'eval' as an error-capturing mechanism rather than for the
     execution of arbitrary code strings.

     See also: evalin


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="evalin" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  evalin (CONTEXT, TRY)
 -- Built-in Function:  evalin (CONTEXT, TRY, CATCH)
     Like 'eval', except that the expressions are evaluated in the
     context CONTEXT, which may be either &quot;caller&quot; or &quot;base&quot;.

     See also: eval, assignin


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="example" func="yes">
            <Overload retVal="">
                <Param name="
 -- Command:  example NAME
 -- Command:  example NAME N
 -- Function File:  example ('NAME')
 -- Function File:  example ('NAME', N)
 -- Function File: [S, IDX] = example (...)
     Display the code for example N associated with the function
     'NAME', but do not run it.  If N is not specified, all examples
     are displayed.

     When called with output arguments, the examples are returned in
     the form of a string S, with IDX indicating the ending position of
     the various examples.

     See 'demo' for a complete explanation.

     See also: demo, test


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="exec" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: [ERR, MSG] = exec (FILE, ARGS)
     Replace current process with a new process.  Calling 'exec' without
     first calling 'fork' will terminate your current Octave process and
     replace it with the program named by FILE.  For example,

          exec ('ls' '-l')

     will run 'ls' and return you to your shell prompt.

     If successful, 'exec' does not return.  If 'exec' does return, ERR
     will be nonzero, and MSG will contain a system-dependent error
     message.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="EXEC_PATH" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: VAL = EXEC_PATH ()
 -- Built-in Function: OLD_VAL = EXEC_PATH (NEW_VAL)
 -- Built-in Function:  EXEC_PATH (NEW_VAL, 'local')
     Query or set the internal variable that specifies a colon separated
     list of directories to append to the shell PATH when executing
     external programs.  The initial value of is taken from the
     environment variable 'OCTAVE_EXEC_PATH', but that value can be
     overridden by the command line argument '--exec-path PATH'.

     When called from inside a function with the 'local' option, the
     variable is changed locally for the function and any subroutines
     it calls.  The original variable value is restored when exiting
     the function.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="exist" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  exist (NAME, TYPE)
     Return 1 if the name exists as a variable, 2 if the name is an
     absolute file name, an ordinary file in Octave's 'path', or (after
     appending '.m') a function file in Octave's 'path', 3 if the name
     is a '.oct' or '.mex' file in Octave's 'path', 5 if the name is a
     built-in function, 7 if the name is a directory, or 103 if the
     name is a function not associated with a file (entered on the
     command line).

     Otherwise, return 0.

     This function also returns 2 if a regular file called NAME exists
     in Octave's search path.  If you want information about other
     types of files, you should use some combination of the functions
     'file_in_path' and 'stat' instead.

     If the optional argument TYPE is supplied, check only for symbols
     of the specified type.  Valid types are

    'var'
          Check only for variables.

    'builtin'
          Check only for built-in functions.

    'file'
        ...

     USE help exist FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="exp" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  exp (X)
     Compute 'e^x' for each element of X.  To compute the matrix
     exponential, see *note Linear Algebra::.

     See also: log


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="expcdf" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  expcdf (X, LAMBDA)
     For each element of X, compute the cumulative distribution
     function (CDF) at X of the exponential distribution with mean
     LAMBDA.

     The arguments can be of common size or scalars.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="expinv" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  expinv (X, LAMBDA)
     For each element of X, compute the quantile (the inverse of the
     CDF) at X of the exponential distribution with mean LAMBDA.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="expm" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  expm (A)
     Return the exponential of a matrix, defined as the infinite Taylor
     series

          expm (A) = I + A + A^2/2! + A^3/3! + ...

     The Taylor series is _not_ the way to compute the matrix
     exponential; see Moler and Van Loan, 'Nineteen Dubious Ways to
     Compute the Exponential of a Matrix', SIAM Review, 1978.  This
     routine uses Ward's diagonal Pade' approximation method with three
     step preconditioning (SIAM Journal on Numerical Analysis, 1977).
     Diagonal Pade' approximations are rational polynomials of matrices

               -1
          D (A)   N (A)

     whose Taylor series matches the first '2q+1' terms of the Taylor
     series above; direct evaluation of the Taylor series (with the
     same preconditioning steps) may be desirable in lieu of the Pade'
     approximation when 'Dq(A)' is ill-conditioned.

     See also: logm, sqrtm


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="expm1" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  expm1 (X)
     Compute 'exp (X) - 1' accurately in the neighborhood of zero.

     See also: exp


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="exppdf" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  exppdf (X, LAMBDA)
     For each element of X, compute the probability density function
     (PDF) at X of the exponential distribution with mean LAMBDA.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="exprnd" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  exprnd (LAMBDA)
 -- Function File:  exprnd (LAMBDA, R)
 -- Function File:  exprnd (LAMBDA, R, C, ...)
 -- Function File:  exprnd (LAMBDA, [SZ])
     Return a matrix of random samples from the exponential
     distribution with mean LAMBDA.

     When called with a single size argument, return a square matrix
     with the dimension specified.  When called with more than one
     scalar argument the first two arguments are taken as the number of
     rows and columns and any further arguments specify additional
     matrix dimensions.  The size may also be specified with a vector
     of dimensions SZ.

     If no size arguments are given then the result matrix is the size
     of LAMBDA.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="eye" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  eye (N)
 -- Built-in Function:  eye (M, N)
 -- Built-in Function:  eye ([M N])
 -- Built-in Function:  eye (..., CLASS)
     Return an identity matrix.  If invoked with a single scalar
     argument N, return a square NxN identity matrix.  If supplied two
     scalar arguments (M, N), 'eye' takes them to be the number of rows
     and columns.  If given a vector with two elements, 'eye' uses the
     values of the elements as the number of rows and columns,
     respectively.  For example:

          eye (3)
              =>  1  0  0
                  0  1  0
                  0  0  1

     The following expressions all produce the same result:

          eye (2)
          ==
          eye (2, 2)
          ==
          eye (size ([1, 2; 3, 4])

     The optional argument CLASS, allows 'eye' to return an array of
     the specified type, like

          val = zeros (n,m, 'uint8')

     Calling 'eye' with no arguments is equivalent to calling it with
     an argum...

     USE help eye FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="ezcontour" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  ezcontour (F)
 -- Function File:  ezcontour (..., DOM)
 -- Function File:  ezcontour (..., N)
 -- Function File:  ezcontour (H, ...)
 -- Function File: H = ezcontour (...)
     Plot the contour lines of a function.  F is a string, inline
     function or function handle with two arguments defining the
     function.  By default the plot is over the domain '-2*pi &lt; X &lt;
     2*pi' and '-2*pi &lt; Y &lt; 2*pi' with 60 points in each dimension.

     If DOM is a two element vector, it represents the minimum and
     maximum value of both X and Y.  If DOM is a four element vector,
     then the minimum and maximum value of X and Y are specify
     separately.

     N is a scalar defining the number of points to use in each
     dimension.

     The optional return value H is a graphics handle to the created
     plot.

          f = @(x,y) sqrt (abs (x .* y)) ./ (1 + x.^2 + y.^2);
          ezcontour (f, [-3, 3]);

     See also: ezplot, ezcontourf, ezsurfc, ezmeshc


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="ezcontourf" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  ezcontourf (F)
 -- Function File:  ezcontourf (..., DOM)
 -- Function File:  ezcontourf (..., N)
 -- Function File:  ezcontourf (H, ...)
 -- Function File: H = ezcontourf (...)
     Plot the filled contour lines of a function.  F is a string, inline
     function or function handle with two arguments defining the
     function.  By default the plot is over the domain '-2*pi &lt; X &lt;
     2*pi' and '-2*pi &lt; Y &lt; 2*pi' with 60 points in each dimension.

     If DOM is a two element vector, it represents the minimum and
     maximum value of both X and Y.  If DOM is a four element vector,
     then the minimum and maximum value of X and Y are specify
     separately.

     N is a scalar defining the number of points to use in each
     dimension.

     The optional return value H is a graphics handle to the created
     plot.

          f = @(x,y) sqrt (abs (x .* y)) ./ (1 + x.^2 + y.^2);
          ezcontourf (f, [-3, 3]);

     See also: ezplot, ezcontour, ezsurfc, ezmesh...

     USE help ezcontourf FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="ezmesh" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  ezmesh (F)
 -- Function File:  ezmesh (FX, FY, FZ)
 -- Function File:  ezmesh (..., DOM)
 -- Function File:  ezmesh (..., N)
 -- Function File:  ezmesh (..., 'circ')
 -- Function File:  ezmesh (H, ...)
 -- Function File: H = ezmesh (...)
     Plot the mesh defined by a function.  F is a string, inline
     function or function handle with two arguments defining the
     function.  By default the plot is over the domain '-2*pi &lt; X &lt;
     2*pi' and '-2*pi &lt; Y &lt; 2*pi' with 60 points in each dimension.

     If DOM is a two element vector, it represents the minimum and
     maximum value of both X and Y.  If DOM is a four element vector,
     then the minimum and maximum value of X and Y are specify
     separately.

     N is a scalar defining the number of points to use in each
     dimension.

     If three functions are passed, then plot the parametrically defined
     function '[FX (S, T), FY (S, T), FZ (S, T)]'.

     If the argument 'circ' is given, then the func...

     USE help ezmesh FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="ezmeshc" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  ezmeshc (F)
 -- Function File:  ezmeshc (FX, FY, FZ)
 -- Function File:  ezmeshc (..., DOM)
 -- Function File:  ezmeshc (..., N)
 -- Function File:  ezmeshc (..., 'circ')
 -- Function File:  ezmeshc (H, ...)
 -- Function File: H = ezmeshc (...)
     Plot the mesh and contour lines defined by a function.  F is a
     string, inline function or function handle with two arguments
     defining the function.  By default the plot is over the domain
     '-2*pi &lt; X &lt; 2*pi' and '-2*pi &lt; Y &lt; 2*pi' with 60 points in each
     dimension.

     If DOM is a two element vector, it represents the minimum and
     maximum value of both X and Y.  If DOM is a four element vector,
     then the minimum and maximum value of X and Y are specify
     separately.

     N is a scalar defining the number of points to use in each
     dimension.

     If three functions are passed, then plot the parametrically defined
     function '[FX (S, T), FY (S, T), FZ (S, T)]'.

     If the argument ...

     USE help ezmeshc FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="ezplot" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  ezplot (F)
 -- Function File:  ezplot (FX, FY)
 -- Function File:  ezplot (..., DOM)
 -- Function File:  ezplot (..., N)
 -- Function File:  ezplot (H, ...)
 -- Function File: H = ezplot (...)
     Plot the curve defined by F in two dimensions.  The function F may
     be a string, inline function or function handle and can have
     either one or two variables.  If F has one variable, then the
     function is plotted over the domain '-2*pi &lt; X &lt; 2*pi' with 500
     points.

     If F has two variables then 'F(X,Y) = 0' is calculated over the
     meshed domain '-2*pi &lt; X | Y &lt; 2*pi' with 60 by 60 in the mesh.
     For example:

          ezplot (@(X, Y) X.^2 - Y.^2 - 1)

     If two functions are passed as strings, inline functions or
     function handles, then the parametric function

          X = FX (T)
          Y = FY (T)

     is plotted over the domain '-2*pi &lt; T &lt; 2*pi' with 500 points.

     If DOM is a two element vector, it represents the minimum and
 ...

     USE help ezplot FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="ezplot3" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  ezplot3 (FX, FY, FZ)
 -- Function File:  ezplot3 (..., DOM)
 -- Function File:  ezplot3 (..., N)
 -- Function File:  ezplot3 (H, ...)
 -- Function File: H = ezplot3 (...)
     Plot a parametrically defined curve in three dimensions.  FX, FY,
     and FZ are strings, inline functions or function handles with one
     arguments defining the function.  By default the plot is over the
     domain '-2*pi &lt; X &lt; 2*pi' with 60 points.

     If DOM is a two element vector, it represents the minimum and
     maximum value of T.  N is a scalar defining the number of points
     to use.

     The optional return value H is a graphics handle to the created
     plot.

          fx = @(t) cos (t);
          fy = @(t) sin (t);
          fz = @(t) t;
          ezplot3 (fx, fy, fz, [0, 10*pi], 100);

     See also: plot3, ezplot, ezsurf, ezmesh


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="ezpolar" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  ezpolar (F)
 -- Function File:  ezpolar (..., DOM)
 -- Function File:  ezpolar (..., N)
 -- Function File:  ezpolar (H, ...)
 -- Function File: H = ezpolar (...)
     Plot a function in polar coordinates.  The function F is either a
     string, inline function or function handle with one arguments
     defining the function.  By default the plot is over the domain '0
     &lt; X &lt; 2*pi' with 60 points.

     If DOM is a two element vector, it represents the minimum and
     maximum value of both T.  N is a scalar defining the number of
     points to use.

     The optional return value H is a graphics handle to the created
     plot.

          ezpolar (@(t) 1 + sin (t));

     See also: polar, ezplot, ezsurf, ezmesh


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="ezsurf" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  ezsurf (F)
 -- Function File:  ezsurf (FX, FY, FZ)
 -- Function File:  ezsurf (..., DOM)
 -- Function File:  ezsurf (..., N)
 -- Function File:  ezsurf (..., 'circ')
 -- Function File:  ezsurf (H, ...)
 -- Function File: H = ezsurf (...)
     Plot the surface defined by a function.  F is a string, inline
     function or function handle with two arguments defining the
     function.  By default the plot is over the domain '-2*pi &lt; X &lt;
     2*pi' and '-2*pi &lt; Y &lt; 2*pi' with 60 points in each dimension.

     If DOM is a two element vector, it represents the minimum and
     maximum value of both X and Y.  If DOM is a four element vector,
     then the minimum and maximum value of X and Y are specify
     separately.

     N is a scalar defining the number of points to use in each
     dimension.

     If three functions are passed, then plot the parametrically defined
     function '[FX (S, T), FY (S, T), FZ (S, T)]'.

     If the argument 'circ' is given, then the f...

     USE help ezsurf FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="ezsurfc" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  ezsurfc (F)
 -- Function File:  ezsurfc (FX, FY, FZ)
 -- Function File:  ezsurfc (..., DOM)
 -- Function File:  ezsurfc (..., N)
 -- Function File:  ezsurfc (..., 'circ')
 -- Function File:  ezsurfc (H, ...)
 -- Function File: H = ezsurfc (...)
     Plot the surface and contour lines defined by a function.  F is a
     string, inline function or function handle with two arguments
     defining the function.  By default the plot is over the domain
     '-2*pi &lt; X &lt; 2*pi' and '-2*pi &lt; Y &lt; 2*pi' with 60 points in each
     dimension.

     If DOM is a two element vector, it represents the minimum and
     maximum value of both X and Y.  If DOM is a four element vector,
     then the minimum and maximum value of X and Y are specify
     separately.

     N is a scalar defining the number of points to use in each
     dimension.

     If three functions are passed, then plot the parametrically defined
     function '[FX (S, T), FY (S, T), FZ (S, T)]'.

     If the argume...

     USE help ezsurfc FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="f_test_regression" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [PVAL, F, DF_NUM, DF_DEN] = f_test_regression (Y, X,
          RR, R)
     Perform an F test for the null hypothesis rr * b = r in a classical
     normal regression model y = X * b + e.

     Under the null, the test statistic F follows an F distribution
     with DF_NUM and DF_DEN degrees of freedom.

     The p-value (1 minus the CDF of this distribution at F) is
     returned in PVAL.

     If not given explicitly, R = 0.

     If no output argument is given, the p-value is displayed.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="factor" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: P = factor (Q)
 -- Function File: [P, N] = factor (Q)
     Return prime factorization of Q.  That is, 'prod (P) == Q' and
     every element of P is a prime number.  If 'Q == 1', return 1.

     With two output arguments, return the unique primes P and their
     multiplicities.  That is, 'prod (P .^ N) == Q'.

     See also: gcd, lcm


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="factorial" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  factorial (N)
     Return the factorial of N where N is a positive integer.  If N is
     a scalar, this is equivalent to 'prod (1:N)'.  For vector or
     matrix arguments, return the factorial of each element in the
     array.  For non-integers see the generalized factorial function
     'gamma'.

     See also: prod, gamma


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="fail" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  fail (CODE)
 -- Function File:  fail (CODE, PATTERN)
 -- Function File:  fail (CODE, 'warning', PATTERN)
     Return true if CODE fails with an error message matching PATTERN,
     otherwise produce an error.  Note that CODE is a string and if
     CODE runs successfully, the error produced is:

                    expected error but got none

     If the code fails with a different error, the message produced is:

                    expected &lt;pattern&gt;
                    but got &lt;text of actual error&gt;

     The angle brackets are not part of the output.

     Called with three arguments, the behavior is similar to
     'fail(CODE, PATTERN)', but produces an error if no warning is
     given during code execution or if the code fails.

     See also: assert


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="false" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  false (X)
 -- Built-in Function:  false (N, M)
 -- Built-in Function:  false (N, M, K, ...)
     Return a matrix or N-dimensional array whose elements are all
     logical 0.  If invoked with a single scalar integer argument,
     return a square matrix of the specified size.  If invoked with two
     or more scalar integer arguments, or a vector of integer values,
     return an array with given dimensions.

     See also: true


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="fcdf" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  fcdf (X, M, N)
     For each element of X, compute the cumulative distribution function
     (CDF) at X of the F distribution with M and N degrees of freedom.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="fclear" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  fclear (FID)
     Clear the stream state for the specified file.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="fclose" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  fclose (FID)
 -- Built-in Function:  fclose ('all')
     Close the specified file.  If successful, 'fclose' returns 0,
     otherwise, it returns -1.  The second form of the 'fclose' call
     closes all open files except 'stdout', 'stderr', and 'stdin'.

     See also: fopen, fseek, ftell


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="fcntl" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: [ERR, MSG] = fcntl (FID, REQUEST, ARG)
     Change the properties of the open file FID.  The following values
     may be passed as REQUEST:

    'F_DUPFD'
          Return a duplicate file descriptor.

    'F_GETFD'
          Return the file descriptor flags for FID.

    'F_SETFD'
          Set the file descriptor flags for FID.

    'F_GETFL'
          Return the file status flags for FID.  The following codes
          may be returned (some of the flags may be undefined on some
          systems).

         'O_RDONLY'
               Open for reading only.

         'O_WRONLY'
               Open for writing only.

         'O_RDWR'
               Open for reading and writing.

         'O_APPEND'
               Append on each write.

         'O_CREAT'
               Create the file if it does not exist.

         'O_NONBLOCK'
               Non-blocking mode.

         'O_SYNC'
               Wait for writes to complete.

         'O_ASYNC'
               As...

     USE help fcntl FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="fdisp" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  fdisp (FID, X)
     Display the value of X on the stream FID.  For example:

          fdisp (stdout, 'The value of pi is:'), fdisp (stdout, pi)

              -| the value of pi is:
              -| 3.1416

     Note that the output from 'fdisp' always ends with a newline.

     See also: disp


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="feather" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  feather (U, V)
 -- Function File:  feather (Z)
 -- Function File:  feather (..., STYLE)
 -- Function File:  feather (H, ...)
 -- Function File: H = feather (...)
     Plot the '(U, V)' components of a vector field emanating from
     equidistant points on the x-axis.  If a single complex argument Z
     is given, then 'U = real (Z)' and 'V = imag (Z)'.

     The style to use for the plot can be defined with a line style
     STYLE in a similar manner to the line styles used with the 'plot'
     command.

     The optional return value H is a vector of graphics handles to the
     line objects representing the drawn vectors.

          phi = [0 : 15 : 360] * pi/180;
          feather (sin (phi), cos (phi));

     See also: plot, quiver, compass


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="feof" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  feof (FID)
     Return 1 if an end-of-file condition has been encountered for a
     given file and 0 otherwise.  Note that it will only return 1 if
     the end of the file has already been encountered, not if the next
     read operation will result in an end-of-file condition.

     See also: fread, fopen, fclose


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="ferror" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: [ERR, MSG] = ferror (FID, 'clear')
     Return 1 if an error condition has been encountered for the file ID
     FID and 0 otherwise.  Note that it will only return 1 if an error
     has already been encountered, not if the next operation will
     result in an error condition.

     The second argument is optional.  If it is supplied, also clear the
     error condition.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="feval" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  feval (NAME, ...)
     Evaluate the function named NAME.  Any arguments after the first
     are passed on to the named function.  For example,

          feval ('acos', -1)
              => 3.1416

     calls the function 'acos' with the argument '-1'.

     The function 'feval' can also be used with function handles of any
     sort (*note Function Handles::).  Historically, 'feval' was the
     only way to call user-supplied functions in strings, but function
     handles are now preferred due to the cleaner syntax they offer.
     For example,

          F = @exp;
          feval (F, 1)
              => 2.7183
          F (1)
              => 2.7183

     are equivalent ways to call the function referred to by F.  If it
     cannot be predicted beforehand that F is a function handle or the
     function name in a string, 'feval' can be used instead.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="fflush" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  fflush (FID)
     Flush output to FID.  This is useful for ensuring that all pending
     output makes it to the screen before some other event occurs.  For
     example, it is always a good idea to flush the standard output
     stream before calling 'input'.

     'fflush' returns 0 on success and an OS dependent error value (-1
     on Unix) on error.

     See also: fopen, fclose


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="fft" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function:  fft (X)
 -- Loadable Function:  fft (X, N)
 -- Loadable Function:  fft (X, N, DIM)
     Compute the discrete Fourier transform of A using a Fast Fourier
     Transform (FFT) algorithm.

     The FFT is calculated along the first non-singleton dimension of
     the array.  Thus if X is a matrix, 'fft (X)' computes the FFT for
     each column of X.

     If called with two arguments, N is expected to be an integer
     specifying the number of elements of X to use, or an empty matrix
     to specify that its value should be ignored.  If N is larger than
     the dimension along which the FFT is calculated, then X is resized
     and padded with zeros.  Otherwise, if N is smaller than the
     dimension along which the FFT is calculated, then X is truncated.

     If called with three arguments, DIM is an integer specifying the
     dimension of the matrix along which the FFT is performed

     See also: ifft, fft2, fftn, fftw


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="fft2" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function:  fft2 (A)
 -- Loadable Function:  fft2 (A, M, N)
     Compute the two-dimensional discrete Fourier transform of A using
     a Fast Fourier Transform (FFT) algorithm.

     The optional arguments M and N may be used specify the number of
     rows and columns of A to use.  If either of these is larger than
     the size of A, A is resized and padded with zeros.

     If A is a multi-dimensional matrix, each two-dimensional sub-matrix
     of A is treated separately.

     See also: ifft2, fft, fftn, fftw


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="fftconv" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  fftconv (X, Y)
 -- Function File:  fftconv (X, Y, N)
     Convolve two vectors using the FFT for computation.

     'c = fftconv (X, Y)' returns a vector of length equal to 'length
     (X) + length (Y) - 1'.  If X and Y are the coefficient vectors of
     two polynomials, the returned value is the coefficient vector of
     the product polynomial.

     The computation uses the FFT by calling the function 'fftfilt'.  If
     the optional argument N is specified, an N-point FFT is used.

     See also: deconv, conv, conv2


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="fftfilt" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  fftfilt (B, X, N)
     With two arguments, 'fftfilt' filters X with the FIR filter B
     using the FFT.

     Given the optional third argument, N, 'fftfilt' uses the
     overlap-add method to filter X with B using an N-point FFT.

     If X is a matrix, filter each column of the matrix.

     See also: filter, filter2


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="fftn" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function:  fftn (A)
 -- Loadable Function:  fftn (A, SIZE)
     Compute the N-dimensional discrete Fourier transform of A using a
     Fast Fourier Transform (FFT) algorithm.

     The optional vector argument SIZE may be used specify the
     dimensions of the array to be used.  If an element of SIZE is
     smaller than the corresponding dimension of A, then the dimension
     of A is truncated prior to performing the FFT.  Otherwise, if an
     element of SIZE is larger than the corresponding dimension then A
     is resized and padded with zeros.

     See also: ifftn, fft, fft2, fftw


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="fftshift" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  fftshift (X)
 -- Function File:  fftshift (X, DIM)
     Perform a shift of the vector X, for use with the 'fft' and 'ifft'
     functions, in order the move the frequency 0 to the center of the
     vector or matrix.

     If X is a vector of N elements corresponding to N time samples
     spaced by dt, then 'fftshift (fft (X))' corresponds to frequencies

          f = [ -(ceil((N-1)/2):-1:1)*df 0 (1:floor((N-1)/2))*df ]

     where df = 1 / dt.

     If X is a matrix, the same holds for rows and columns.  If X is an
     array, then the same holds along each dimension.

     The optional DIM argument can be used to limit the dimension along
     which the permutation occurs.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="fftw" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: METHOD = fftw ('planner')
 -- Loadable Function:  fftw ('planner', METHOD)
 -- Loadable Function: WISDOM = fftw ('dwisdom')
 -- Loadable Function:  fftw ('dwisdom', WISDOM)
     Manage FFTW wisdom data.  Wisdom data can be used to significantly
     accelerate the calculation of the FFTs, but implies an initial cost
     in its calculation.  When the FFTW libraries are initialized, they
     read a system wide wisdom file (typically in '/etc/fftw/wisdom'),
     allowing wisdom to be shared between applications other than
     Octave.  Alternatively, the 'fftw' function can be used to import
     wisdom.  For example,

          WISDOM = fftw ('dwisdom')

     will save the existing wisdom used by Octave to the string WISDOM.
     This string can then be saved to a file and restored using the
     'save' and 'load' commands respectively.  This existing wisdom can
     be reimported as follows

          fftw ('dwisdom', WISDOM)

     If WISDOM is an empty matrix, ...

     USE help fftw FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="fgetl" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  fgetl (FID, LEN)
     Read characters from a file, stopping after a newline, or EOF, or
     LEN characters have been read.  The characters read, excluding the
     possible trailing newline, are returned as a string.

     If LEN is omitted, 'fgetl' reads until the next newline character.

     If there are no more characters to read, 'fgetl' returns -1.

     See also: fread, fscanf


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="fgets" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  fgets (FID)
 -- Built-in Function:  fgets (FID, LEN)
     Read characters from a file, stopping after a newline, or EOF, or
     LEN characters have been read.  The characters read, including the
     possible trailing newline, are returned as a string.

     If LEN is omitted, 'fgets' reads until the next newline character.

     If there are no more characters to read, 'fgets' returns -1.

     See also: fputs, fopen, fread, fscanf


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="fieldnames" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  fieldnames (STRUCT)
     Return a cell array of strings naming the elements of the structure
     STRUCT.  It is an error to call 'fieldnames' with an argument that
     is not a structure.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="figure" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  figure (N)
 -- Function File:  figure (N, PROPERTY, VALUE, ...)
     Set the current plot window to plot window N.  If no arguments are
     specified, the next available window number is chosen.

     Multiple property-value pairs may be specified for the figure, but
     they must appear in pairs.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="file_in_loadpath" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  file_in_loadpath (FILE)
 -- Built-in Function:  file_in_loadpath (FILE, 'all')
     Return the absolute name of FILE if it can be found in the list of
     directories specified by 'path'.  If no file is found, return an
     empty character string.

     If the first argument is a cell array of strings, search each
     directory of the loadpath for element of the cell array and return
     the first that matches.

     If the second optional argument &quot;all&quot; is supplied, return a cell
     array containing the list of all files that have the same name in
     the path.  If no files are found, return an empty cell array.

     See also: file_in_path, path


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="file_in_path" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  file_in_path (PATH, FILE)
 -- Built-in Function:  file_in_path (PATH, FILE, 'all')
     Return the absolute name of FILE if it can be found in PATH.  The
     value of PATH should be a colon-separated list of directories in
     the format described for 'path'.  If no file is found, return an
     empty character string.  For example:

          file_in_path (EXEC_PATH, 'sh')
              => '/bin/sh'

     If the second argument is a cell array of strings, search each
     directory of the path for element of the cell array and return the
     first that matches.

     If the third optional argument &quot;all&quot; is supplied, return a cell
     array containing the list of all files that have the same name in
     the path.  If no files are found, return an empty cell array.

     See also: file_in_loadpath


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="fileattrib" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [STATUS, RESULT, MSGID] = fileattrib (FILE)
     Return information about FILE.

     If successful, STATUS is 1, with RESULT containing a structure
     with the following fields:

    'Name'
          Full name of FILE.

    'archive'
          True if FILE is an archive (Windows).

    'system'
          True if FILE is a system file (Windows).

    'hidden'
          True if FILE is a hidden file (Windows).

    'directory'
          True if FILE is a directory.

    'UserRead'
    'GroupRead'
    'OtherRead'
          True if the user (group; other users) has read permission for
          FILE.

    'UserWrite'
    'GroupWrite'
    'OtherWrite'
          True if the user (group; other users) has write permission for
          FILE.

    'UserExecute'
    'GroupExecute'
    'OtherExecute'
          True if the user (group; other users) has execute permission
          for FILE.
     If an attribute does not apply (i.e., archive on a Unix system)
     then the fie...

     USE help fileattrib FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="filemarker" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: VAL = filemarker ()
 -- Built-in Function:  filemarker (NEW_VAL)
 -- Built-in Function:  filemarker (NEW_VAL, 'local')
     Query or set the character used to separate filename from the the
     subfunction names contained within the file.  This can be used in
     a generic manner to interact with subfunctions.  For example,

          help (['myfunc', filemarker, 'mysubfunc'])

     returns the help string associated with the sub-function
     'mysubfunc' of the function 'myfunc'.  Another use of 'filemarker'
     is when debugging it allows easier placement of breakpoints within
     sub-functions.  For example,

          dbstop (['myfunc', filemarker, 'mysubfunc'])

     will set a breakpoint at the first line of the subfunction
     'mysubfunc'.

     When called from inside a function with the 'local' option, the
     variable is changed locally for the function and any subroutines
     it calls.  The original variable value is restored when exiting
     t...

     USE help filemarker FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="fileparts" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [DIR, NAME, EXT, VER] = fileparts (FILENAME)
     Return the directory, name, extension, and version components of
     FILENAME.

     See also: fullfile


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="fileread" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: STR = fileread (FILENAME)
     Read the contents of FILENAME and return it as a string.

     See also: fread, textread, sscanf


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="filesep" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  filesep ()
 -- Built-in Function:  filesep ('all')
     Return the system-dependent character used to separate directory
     names.

     If 'all' is given, the function returns all valid file separators
     in the form of a string.  The list of file separators is
     system-dependent.  It is '/' (forward slash) under UNIX or
     Mac OS X, '/' and '\' (forward and backward slashes) under Windows.

     See also: pathsep


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="fill" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  fill (X, Y, C)
 -- Function File:  fill (X1, Y1, C1, X2, Y2, C2)
 -- Function File:  fill (..., PROP, VAL)
 -- Function File:  fill (H, ...)
 -- Function File: H = fill (...)
     Create one or more filled patch objects.

     The optional return value H is an array of graphics handles to the
     created patch objects.

     See also: patch


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="filt" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: SYS = filt (NUM, DEN, ...)
 -- Function File: SYS = filt (NUM, DEN, TSAM, ...)
     Create discrete-time transfer function model from data in DSP
     format.

     *Inputs*
    NUM
          Numerator or cell of numerators.  Each numerator must be a
          row vector containing the coefficients of the polynomial in
          ascending powers of z^-1.  num{i,j} contains the numerator
          polynomial from input j to output i.  In the SISO case, a
          single vector is accepted as well.

    DEN
          Denominator or cell of denominators.  Each denominator must
          be a row vector containing the coefficients of the polynomial
          in ascending powers of z^-1.  den{i,j} contains the
          denominator polynomial from input j to output i.  In the SISO
          case, a single vector is accepted as well.

    TSAM
          Sampling time in seconds.  If TSAM is not specified, default
          value -1 (unspecified) is taken.

    ...
       ...

     USE help filt FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="filter" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: y = filter (B, A, X)
 -- Loadable Function: [Y, SF] = filter (B, A, X, SI)
 -- Loadable Function: [Y, SF] = filter (B, A, X, [], DIM)
 -- Loadable Function: [Y, SF] = filter (B, A, X, SI, DIM)
     Return the solution to the following linear, time-invariant
     difference equation:

            N                   M
           SUM a(k+1) y(n-k) = SUM b(k+1) x(n-k)      for 1&lt;=n&lt;=length(x)
           k=0                 k=0

     where N=length(a)-1 and M=length(b)-1.  over the first
     non-singleton dimension of X or over DIM if supplied.  An
     equivalent form of this equation is:

                     N                   M
           y(n) = - SUM c(k+1) y(n-k) + SUM d(k+1) x(n-k)  for 1&lt;=n&lt;=length(x)
                    k=1                 k=0

     where c = a/a(1) and d = b/a(1).

     If the fourth argument SI is provided, it is taken as the initial
     state of the system and the final state is returned as SF.  The
     state vector is a column vector...

     USE help filter FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="filter2" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: Y = filter2 (B, X)
 -- Function File: Y = filter2 (B, X, SHAPE)
     Apply the 2-D FIR filter B to X.  If the argument SHAPE is
     specified, return an array of the desired shape.  Possible values
     are:

    'full'
          pad X with zeros on all sides before filtering.

    'same'
          unpadded X (default)

    'valid'
          trim X after filtering so edge effects are no included.

     Note this is just a variation on convolution, with the parameters
     reversed and B rotated 180 degrees.

     See also: conv2


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="find" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: IDX = find (X)
 -- Loadable Function: IDX = find (X, N)
 -- Loadable Function: IDX = find (X, N, DIRECTION)
 -- Loadable Function: [i, j] = find (...)
 -- Loadable Function: [i, j, v] = find (...)
     Return a vector of indices of nonzero elements of a matrix, as a
     row if X is a row vector or as a column otherwise.  To obtain a
     single index for each matrix element, Octave pretends that the
     columns of a matrix form one long vector (like Fortran arrays are
     stored).  For example:

          find (eye (2))
              => [ 1; 4 ]

     If two outputs are requested, 'find' returns the row and column
     indices of nonzero elements of a matrix.  For example:

          [i, j] = find (2 * eye (2))
              => i = [ 1; 2 ]
              => j = [ 1; 2 ]

     If three outputs are requested, 'find' also returns a vector
     containing the nonzero values.  For example:

          [i, j, v] = find (3 * eye (2))
              => i = [ 1; 2 ]
    ...

     USE help find FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="find_dir_in_path" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  find_dir_in_path (DIR)
 -- Built-in Function:  find_dir_in_path (DIR, 'all')
     Return the full name of the path element matching DIR.  The match
     is performed at the end of each path element.  For example, if DIR
     is &quot;foo/bar&quot;, it matches the path element &quot;/some/dir/foo/bar&quot;,
     but not &quot;/some/dir/foo/bar/baz&quot; or &quot;/some/dir/allfoo/bar&quot;.

     The second argument is optional.  If it is supplied, return a cell
     array containing all name matches rather than just the first.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="findall" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: H = findall ()
 -- Function File: H = findall (PROP_NAME, PROP_VALUE)
 -- Function File: H = findall (H, ...)
 -- Function File: H = findall (H, '-depth', D, ...)
     Find graphics object with specified property values including
     hidden handles.

     This function performs the same function as 'findobj', but it
     includes hidden objects in its search.  For full documentation, see
     'findobj'.

     See also: get, set, findobj, allchild


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="findobj" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: H = findobj ()
 -- Function File: H = findobj (PROP_NAME, PROP_VALUE)
 -- Function File: H = findobj ('-property', PROP_NAME)
 -- Function File: H = findobj ('-regexp', PROP_NAME, PATTERN)
 -- Function File: H = findobj ('flat', ...)
 -- Function File: H = findobj (H, ...)
 -- Function File: H = findobj (H, '-depth', D, ...)
     Find graphics object with specified property values.  The simplest
     form is

          findobj (PROP_NAME, PROP_VALUE)

     which returns all of the handles to the objects with the name
     PROP_NAME and the name PROP_VALUE.  The search can be limited to a
     particular object or set of objects and their descendants by
     passing a handle or set of handles H as the first argument to
     'findobj'.

     The depth of hierarchy of objects to which to search to can be
     limited with the '-depth' argument.  To limit the number depth of
     the hierarchy to search to D generations of children, and example
     is

          findobj...

     USE help findobj FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="findstr" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  findstr (S, T)
 -- Function File:  findstr (S, T, OVERLAP)
     Return the vector of all positions in the longer of the two strings
     S and T where an occurrence of the shorter of the two starts.  If
     the optional argument OVERLAP is true, the returned vector can
     include overlapping positions (this is the default).  For example:

          findstr ('ababab', 'a')
               => [1, 3, 5];
          findstr ('abababa', 'aba', 0)
               => [1, 5]

     *Caution:* 'findstr' is scheduled for deprecation.  Use 'strfind'
     in all new code.

     See also: strfind, strmatch, strcmp, strncmp, strcmpi, strncmpi,
     find


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="finv" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  finv (X, M, N)
     For each element of X, compute the quantile (the inverse of the
     CDF) at X of the F distribution with M and N degrees of freedom.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="fitfrd" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [SYS, N] = fitfrd (DAT, N)
 -- Function File: [SYS, N] = fitfrd (DAT, N, FLAG)
     Fit frequency response data with a state-space system.  If
     requested, the returned system is stable and minimum-phase.

     *Inputs*
    DAT
          LTI model containing frequency response data of a SISO system.

    N
          The desired order of the system to be fitted.  'n &lt;=
          length(dat.w)'.

    FLAG
          The flag controls whether the returned system is stable and
          minimum-phase.
         0
               The system zeros and poles are not constrained.  Default
               value.

         1
               The system zeros and poles will have negative real parts
               in the continuous-time case, or moduli less than 1 in
               the discrete-time case.

     *Outputs*
    SYS
          State-space model of order N, fitted to frequency response
          data DAT.

    N
          The order of the obtained system.  The value of N...

     USE help fitfrd FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="fix" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  fix (X)
     Truncate fractional portion of X and return the integer portion.
     This is equivalent to rounding towards zero.  If X is complex,
     return 'fix (real (X)) + fix (imag (X)) * I'.

          fix ([-2.7, 2.7])
            => -2   2

     See also: ceil, floor, round


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="fixed_point_format" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: VAL = fixed_point_format ()
 -- Built-in Function: OLD_VAL = fixed_point_format (NEW_VAL)
 -- Built-in Function:  fixed_point_format (NEW_VAL, 'local')
     Query or set the internal variable that controls whether Octave
     will use a scaled format to print matrix values such that the
     largest element may be written with a single leading digit with
     the scaling factor is printed on the first line of output.  For
     example:

          octave:1> logspace (1, 7, 5)'
          ans =

           1.0e+07  *

           0.00000
           0.00003
           0.00100
           0.03162
           1.00000

     Notice that first value appears to be zero when it is actually 1.
     For this reason, you should be careful when setting
     'fixed_point_format' to a nonzero value.

     When called from inside a function with the 'local' option, the
     variable is changed locally for the function and any subroutines
     it calls.  The original variable value is...

     USE help fixed_point_format FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="flag" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: MAP = flag ()
 -- Function File: MAP = flag (N)
     Create color colormap.  This colormap cycles through red, white,
     blue and black with each index change.  The argument N must be a
     scalar.  If unspecified, the length of the current colormap, or
     64, is used.

     See also: colormap


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="flipdim" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  flipdim (X)
 -- Function File:  flipdim (X, DIM)
     Return a copy of X flipped about the dimension DIM.  DIM defaults
     to the first non-singleton dimension.  For example:

          flipdim ([1, 2; 3, 4], 2)
                =>  2  1
                    4  3

     See also: fliplr, flipud, rot90, rotdim


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="fliplr" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  fliplr (X)
     Return a copy of X with the order of the columns reversed.  In
     other words, X is flipped left-to-right about a vertical axis.  For
     example:

          fliplr ([1, 2; 3, 4])
               =>  2  1
                   4  3

     Note that 'fliplr' only works with 2-D arrays.  To flip N-D arrays
     use 'flipdim' instead.

     See also: flipud, flipdim, rot90, rotdim


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="flipud" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  flipud (X)
     Return a copy of X with the order of the rows reversed.  In other
     words, X is flipped upside-down about a horizontal axis.  For
     example:

          flipud ([1, 2; 3, 4])
               =>  3  4
                   1  2

     Note that 'flipud' only works with 2-D arrays.  To flip N-D arrays
     use 'flipdim' instead.

     See also: fliplr, flipdim, rot90, rotdim


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="floor" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  floor (X)
     Return the largest integer not greater than X.  This is equivalent
     to rounding towards negative infinity.  If X is complex, return
     'floor (real (X)) + floor (imag (X)) * I'.

          floor ([-2.7, 2.7])
              => -3   2

     See also: ceil, round, fix


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="fminbnd" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [X, FVAL, INFO, OUTPUT] = fminbnd (FUN, A, B,
          OPTIONS)
     Find a minimum point of a univariate function.  FUN should be a
     function handle or name.  A, B specify a starting interval.
     OPTIONS is a structure specifying additional options.  Currently,
     'fminbnd' recognizes these options: &quot;FunValCheck&quot;, &quot;OutputFcn&quot;,
     &quot;TolX&quot;, &quot;MaxIter&quot;, &quot;MaxFunEvals&quot;.  For description of these
     options, see *note optimset: doc-optimset.

     On exit, the function returns X, the approximate minimum point and
     FVAL, the function value thereof.  INFO is an exit flag that can
     have these values:

        * 1 The algorithm converged to a solution.

        * 0 Maximum number of iterations or function evaluations has
          been exhausted.

        * -1 The algorithm has been terminated from user output
          function.

     See also: optimset, fzero, fminunc


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="fminunc" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  fminunc (FCN, X0)
 -- Function File:  fminunc (FCN, X0, OPTIONS)
 -- Function File: [X, FVEC, INFO, OUTPUT, GRAD, HESS] = fminunc (FCN,
          ...)
     Solve an unconstrained optimization problem defined by the function
     FCN.  FCN should accepts a vector (array) defining the unknown
     variables, and return the objective function value, optionally
     with gradient.  In other words, this function attempts to
     determine a vector X such that 'FCN (X)' is a local minimum.  X0
     determines a starting guess.  The shape of X0 is preserved in all
     calls to FCN, but otherwise is treated as a column vector.
     OPTIONS is a structure specifying additional options.  Currently,
     'fminunc' recognizes these options: &quot;FunValCheck&quot;,
     &quot;OutputFcn&quot;, &quot;TolX&quot;, &quot;TolFun&quot;, &quot;MaxIter&quot;, &quot;MaxFunEvals&quot;,
     &quot;GradObj&quot;, &quot;FinDiffType&quot;, &quot;TypicalX&quot;, &quot;AutoScaling&quot;.

     If &quot;GradObj&quot; is &quot;on&quot;, it specifies that FCN, called with 2
     output argu...

     USE help fminunc FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="fnmatch" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  fnmatch (PATTERN, STRING)
     Return 1 or zero for each element of STRING that matches any of
     the elements of the string array PATTERN, using the rules of
     filename pattern matching.  For example:

          fnmatch ('a*b', {'ab'; 'axyzb'; 'xyzab'})
              => [ 1; 1; 0 ]

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="fopen" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: [FID, MSG] = fopen (NAME, MODE, ARCH)
 -- Built-in Function: FID_LIST = fopen ('all')
 -- Built-in Function: [FILE, MODE, ARCH] = fopen (FID)
     The first form of the 'fopen' function opens the named file with
     the specified mode (read-write, read-only, etc.) and architecture
     interpretation (IEEE big endian, IEEE little endian, etc.), and
     returns an integer value that may be used to refer to the file
     later.  If an error occurs, FID is set to -1 and MSG contains the
     corresponding system error message.  The MODE is a one or two
     character string that specifies whether the file is to be opened
     for reading, writing, or both.

     The second form of the 'fopen' function returns a vector of file
     ids corresponding to all the currently open files, excluding the
     'stdin', 'stdout', and 'stderr' streams.

     The third form of the 'fopen' function returns information about
     the open file given its file id.

     For example...

     USE help fopen FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="fork" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: [PID, MSG] = fork ()
     Create a copy of the current process.

     Fork can return one of the following values:

    &gt; 0
          You are in the parent process.  The value returned from
          'fork' is the process id of the child process.  You should
          probably arrange to wait for any child processes to exit.

    0
          You are in the child process.  You can call 'exec' to start
          another process.  If that fails, you should probably call
          'exit'.

    &lt; 0
          The call to 'fork' failed for some reason.  You must take
          evasive action.  A system dependent error message will be
          waiting in MSG.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="format" func="yes">
            <Overload retVal="">
                <Param name="
 -- Command:  format
 -- Command:  format options
     Reset or specify the format of the output produced by 'disp' and
     Octave's normal echoing mechanism.  This command only affects the
     display of numbers but not how they are stored or computed.  To
     change the internal representation from the default double use one
     of the conversion functions such as 'single', 'uint8', 'int64',
     etc.

     By default, Octave displays 5 significant digits in a human
     readable form (option 'short' paired with 'loose' format for
     matrices).  If 'format' is invoked without any options, this
     default format is restored.

     Valid formats for floating point numbers are listed in the
     following table.

    'short'
          Fixed point format with 5 significant figures in a field that
          is a maximum of 10 characters wide.  (default).

          If Octave is unable to format a matrix so that columns line
          up on the decimal point and all numbers fit wit...

     USE help format FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="formula" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  formula (FUN)
     Return a character string representing the inline function FUN.
     Note that 'char (FUN)' is equivalent to 'formula (FUN)'.

     See also: argnames, inline, vectorize


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="fpdf" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  fpdf (X, M, N)
     For each element of X, compute the probability density function
     (PDF) at X of the F distribution with M and N degrees of freedom.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="fplot" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  fplot (FN, LIMITS)
 -- Function File:  fplot (FN, LIMITS, TOL)
 -- Function File:  fplot (FN, LIMITS, N)
 -- Function File:  fplot (..., FMT)
     Plot a function FN within defined limits.  FN is a function
     handle, inline function, or string containing the name of the
     function to evaluate.  The limits of the plot are given by LIMITS
     of the form '[XLO, XHI]' or '[XLO, XHI, YLO, YHI]'.  TOL is the
     default tolerance to use for the plot, and if TOL is an integer it
     is assumed that it defines the number points to use in the plot.
     The FMT argument is passed to the plot command.

          fplot ('cos', [0, 2*pi])
          fplot ('[cos(x), sin(x)]', [0, 2*pi])

     See also: plot


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="fprintf" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  fprintf (FID, TEMPLATE, ...)
     This function is just like 'printf', except that the output is
     written to the stream FID instead of 'stdout'.  If FID is omitted,
     the output is written to 'stdout'.

     See also: printf, sprintf, fread, fscanf, fopen, fclose


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="fputs" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  fputs (FID, STRING)
     Write a string to a file with no formatting.

     Return a non-negative number on success and EOF on error.

     See also: scanf, sscanf, fread, fprintf, fgets, fscanf


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="fractdiff" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  fractdiff (X, D)
     Compute the fractional differences (1-L)^d x where L denotes the
     lag-operator and d is greater than -1.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="frd" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: SYS = frd (SYS)
 -- Function File: SYS = frd (SYS, W)
 -- Function File: SYS = frd (H, W, ...)
 -- Function File: SYS = frd (H, W, TSAM, ...)
     Create or convert to frequency response data.

     *Inputs*
    SYS
          LTI model to be converted to frequency response data.  If
          second argument W is omitted, the interesting frequency range
          is calculated by the zeros and poles of SYS.

    H
          Frequency response array (p-by-m-by-lw).  H(i,j,k) contains
          the response from input j to output i at frequency k.  In the
          SISO case, a vector (lw-by-1) or (1-by-lw) is accepted as
          well.

    W
          Frequency vector (lw-by-1) in radian per second [rad/s].
          Frequencies must be in ascending order.

    TSAM
          Sampling time in seconds.  If TSAM is not specified, a
          continuous-time model is assumed.

    ...
          Optional pairs of properties and values.  Type 'set (frd)'
          for mo...

     USE help frd FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="fread" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: [VAL, COUNT] = fread (FID, SIZE, PRECISION,
          SKIP, ARCH)
     Read binary data of type PRECISION from the specified file ID FID.

     The optional argument SIZE specifies the amount of data to read
     and may be one of

    'Inf'
          Read as much as possible, returning a column vector.

    'NR'
          Read up to NR elements, returning a column vector.

    '[NR, Inf]'
          Read as much as possible, returning a matrix with NR rows.
          If the number of elements read is not an exact multiple of
          NR, the last column is padded with zeros.

    '[NR, NC]'
          Read up to 'NR * NC' elements, returning a matrix with NR
          rows.  If the number of elements read is not an exact multiple
          of NR, the last column is padded with zeros.

     If SIZE is omitted, a value of 'Inf' is assumed.

     The optional argument PRECISION is a string specifying the type of
     data to read and may be one of

    'schar'
    '...

     USE help fread FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="freport" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  freport ()
     Print a list of which files have been opened, and whether they are
     open for reading, writing, or both.  For example:

          freport ()

              -|  number  mode  name
              -|
              -|       0     r  stdin
              -|       1     w  stdout
              -|       2     w  stderr
              -|       3     r  myfile

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="freqz" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [H, W] = freqz (B, A, N, 'whole')
     Return the complex frequency response H of the rational IIR filter
     whose numerator and denominator coefficients are B and A,
     respectively.  The response is evaluated at N angular frequencies
     between 0 and  2*pi.

     The output value W is a vector of the frequencies.

     If the fourth argument is omitted, the response is evaluated at
     frequencies between 0 and  pi.

     If N is omitted, a value of 512 is assumed.

     If A is omitted, the denominator is assumed to be 1 (this
     corresponds to a simple FIR filter).

     For fastest computation, N should factor into a small number of
     small primes.

 -- Function File: H = freqz (B, A, W)
     Evaluate the response at the specific frequencies in the vector W.
     The values for W are measured in radians.

 -- Function File: [...] = freqz (..., FS)
     Return frequencies in Hz instead of radians assuming a sampling
     rate FS.  If you are evaluatin...

     USE help freqz FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="freqz_plot" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  freqz_plot (W, H)
     Plot the pass band, stop band and phase response of H.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="frewind" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  frewind (FID)
     Move the file pointer to the beginning of the file FID, returning
     0 for success, and -1 if an error was encountered.  It is
     equivalent to 'fseek (FID, 0, SEEK_SET)'.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="frnd" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  frnd (M, N)
 -- Function File:  frnd (M, N, R)
 -- Function File:  frnd (M, N, R, C, ...)
 -- Function File:  frnd (M, N, [SZ])
     Return a matrix of random samples from the F distribution with M
     and N degrees of freedom.

     When called with a single size argument, return a square matrix
     with the dimension specified.  When called with more than one
     scalar argument the first two arguments are taken as the number of
     rows and columns and any further arguments specify additional
     matrix dimensions.  The size may also be specified with a vector
     of dimensions SZ.

     If no size arguments are given then the result matrix is the
     common size of M and N.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="fscanf" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: [VAL, COUNT, ERRMSG] = fscanf (FID, TEMPLATE,
          SIZE)
 -- Built-in Function: [V1, V2, ..., COUNT, ERRMSG] = fscanf (FID,
          TEMPLATE, 'C')
     In the first form, read from FID according to TEMPLATE, returning
     the result in the matrix VAL.

     The optional argument SIZE specifies the amount of data to read
     and may be one of

    'Inf'
          Read as much as possible, returning a column vector.

    'NR'
          Read up to NR elements, returning a column vector.

    '[NR, Inf]'
          Read as much as possible, returning a matrix with NR rows.
          If the number of elements read is not an exact multiple of
          NR, the last column is padded with zeros.

    '[NR, NC]'
          Read up to 'NR * NC' elements, returning a matrix with NR
          rows.  If the number of elements read is not an exact multiple
          of NR, the last column is padded with zeros.

     If SIZE is omitted, a value of 'Inf' is assumed.

    ...

     USE help fscanf FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="fseek" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  fseek (FID, OFFSET, ORIGIN)
     Set the file pointer to any location within the file FID.

     The pointer is positioned OFFSET characters from the ORIGIN, which
     may be one of the predefined variables 'SEEK_CUR' (current
     position), 'SEEK_SET' (beginning), or 'SEEK_END' (end of file) or
     strings 'cof', 'bof' or 'eof'.  If ORIGIN is omitted, 'SEEK_SET'
     is assumed.  The offset must be zero, or a value returned by
     'ftell' (in which case ORIGIN must be 'SEEK_SET').

     Return 0 on success and -1 on error.

     See also: ftell, fopen, fclose


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="fskipl" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  fskipl (FID, COUNT)
     Skip a given number of lines, i.e., discards characters until an
     end-of-line is met exactly COUNT-times, or end-of-file occurs.
     Returns the number of lines skipped (end-of-line sequences
     encountered).  If COUNT is omitted, it defaults to 1. COUNT may
     also be 'Inf', in which case lines are skipped to the end of file.
     This form is suitable for counting lines in a file.

     See also: fgetl, fgets


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="fsolve" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  fsolve (FCN, X0, OPTIONS)
 -- Function File: [X, FVEC, INFO, OUTPUT, FJAC] = fsolve (FCN, ...)
     Solve a system of nonlinear equations defined by the function FCN.
     FCN should accept a vector (array) defining the unknown variables,
     and return a vector of left-hand sides of the equations.
     Right-hand sides are defined to be zeros.  In other words, this
     function attempts to determine a vector X such that 'FCN (X)'
     gives (approximately) all zeros.  X0 determines a starting guess.
     The shape of X0 is preserved in all calls to FCN, but otherwise it
     is treated as a column vector.  OPTIONS is a structure specifying
     additional options.  Currently, 'fsolve' recognizes these options:
     &quot;FunValCheck&quot;, &quot;OutputFcn&quot;, &quot;TolX&quot;, &quot;TolFun&quot;, &quot;MaxIter&quot;,
     &quot;MaxFunEvals&quot;, &quot;Jacobian&quot;, &quot;Updating&quot;, &quot;ComplexEqn&quot;
     &quot;TypicalX&quot;, &quot;AutoScaling&quot; and &quot;FinDiffType&quot;.

     If &quot;Jacobian&quot; is &quot;on&quot;, it specifies that FCN, called w...

     USE help fsolve FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="ftell" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  ftell (FID)
     Return the position of the file pointer as the number of characters
     from the beginning of the file FID.

     See also: fseek, fopen, fclose


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="ftp" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: F = ftp (HOST)
 -- Function File: F = ftp (HOST, USERNAME, PASSWORD)
     Connect to the FTP server HOST with USERNAME and PASSWORD.  If
     USERNAME and PASSWORD are not specified, user 'anonymous' with no
     password is used.  The returned FTP object F represents the
     established FTP connection.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="full" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: FM = full (SM)
     Return a full storage matrix from a sparse, diagonal, permutation
     matrix or a range.

     See also: sparse


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="fullfile" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: FILENAME = fullfile (DIR1, DIR2, ..., FILE)
     Return a complete filename constructed from the given components.

     See also: fileparts


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="func2str" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  func2str (FCN_HANDLE)
     Return a string containing the name of the function referenced by
     the function handle FCN_HANDLE.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="functions" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  functions (FCN_HANDLE)
     Return a struct containing information about the function handle
     FCN_HANDLE.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="fwcfconred" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [KR, INFO] = fwcfconred (G, F, L, ...)
 -- Function File: [KR, INFO] = fwcfconred (G, F, L, NCR, ...)
 -- Function File: [KR, INFO] = fwcfconred (G, F, L, OPT, ...)
 -- Function File: [KR, INFO] = fwcfconred (G, F, L, NCR, OPT, ...)
     Reduction of state-feedback-observer based controller by
     frequency-weighted coprime factorization (FW CF).  Given a plant
     G, state feedback gain F and full observer gain L, determine a
     reduced order controller KR by using stability enforcing frequency
     weights.

     *Inputs*
    G
          LTI model of the open-loop plant (A,B,C,D).  It has m inputs,
          p outputs and n states.

    F
          Stabilizing state feedback matrix (m-by-n).

    L
          Stabilizing observer gain matrix (n-by-p).

    NCR
          The desired order of the resulting reduced order controller
          KR.  If not specified, NCR is chosen automatically according
          to the description of key 'ORDER'.

    ...
          ...

     USE help fwcfconred FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="fwrite" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: COUNT = fwrite (FID, DATA, PRECISION, SKIP, ARCH)
     Write data in binary form of type PRECISION to the specified file
     ID FID, returning the number of values successfully written to the
     file.

     The argument DATA is a matrix of values that are to be written to
     the file.  The values are extracted in column-major order.

     The remaining arguments PRECISION, SKIP, and ARCH are optional,
     and are interpreted as described for 'fread'.

     The behavior of 'fwrite' is undefined if the values in DATA are
     too large to fit in the specified precision.

     See also: fread, fopen, fclose


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="fzero" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  fzero (FUN, X0)
 -- Function File:  fzero (FUN, X0, OPTIONS)
 -- Function File: [X, FVAL, INFO, OUTPUT] = fzero (...)
     Find a zero of a univariate function.

     FUN is a function handle, inline function, or string containing
     the name of the function to evaluate.  X0 should be a two-element
     vector specifying two points which bracket a zero.  In other
     words, there must be a change in sign of the function between
     X0(1) and X0(2).  More mathematically, the following must hold

          sign (FUN(X0(1))) * sign (FUN(X0(2))) &lt;= 0

     If X0 is a single scalar then several nearby and distant values
     are probed in an attempt to obtain a valid bracketing.  If this is
     not successful, the function fails.  OPTIONS is a structure
     specifying additional options.  Currently, 'fzero' recognizes
     these options: &quot;FunValCheck&quot;, &quot;OutputFcn&quot;, &quot;TolX&quot;,
     &quot;MaxIter&quot;, &quot;MaxFunEvals&quot;.  For a description of these options,
     see *note ...

     USE help fzero FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="gamcdf" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  gamcdf (X, A, B)
     For each element of X, compute the cumulative distribution
     function (CDF) at X of the Gamma distribution with shape parameter
     A and scale B.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="gaminv" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  gaminv (X, A, B)
     For each element of X, compute the quantile (the inverse of the
     CDF) at X of the Gamma distribution with shape parameter A and
     scale B.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="gamma" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  gamma (Z)
     Compute the Gamma function,

                       infinity
                      /
          gamma (z) = | t^(z-1) exp (-t) dt.
                      /
                   t=0

     See also: gammainc, lgamma


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="gammainc" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  gammainc (X, A)
 -- Mapping Function:  gammainc (X, A, 'lower')
 -- Mapping Function:  gammainc (X, A, 'upper')
     Compute the normalized incomplete gamma function,

                                          x
                                1        /
          gammainc (x, a) = ---------    | exp (-t) t^(a-1) dt
                            gamma (a)    /
                                      t=0

     with the limiting value of 1 as X approaches infinity.  The
     standard notation is P(a,x), e.g., Abramowitz and Stegun (6.5.1).

     If A is scalar, then 'gammainc (X, A)' is returned for each
     element of X and vice versa.

     If neither X nor A is scalar, the sizes of X and A must agree, and
     'gammainc' is applied element-by-element.

     By default the incomplete gamma function integrated from 0 to X is
     computed.  If 'upper' is given then the complementary function
     integrated from X to infinity is calculated.  It should be noted
     t...

     USE help gammainc FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="gampdf" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  gampdf (X, A, B)
     For each element of X, return the probability density function
     (PDF) at X of the Gamma distribution with shape parameter A and
     scale B.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="gamrnd" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  gamrnd (A, B)
 -- Function File:  gamrnd (A, B, R)
 -- Function File:  gamrnd (A, B, R, C, ...)
 -- Function File:  gamrnd (A, B, [SZ])
     Return a matrix of random samples from the Gamma distribution with
     shape parameter A and scale B.

     When called with a single size argument, return a square matrix
     with the dimension specified.  When called with more than one
     scalar argument the first two arguments are taken as the number of
     rows and columns and any further arguments specify additional
     matrix dimensions.  The size may also be specified with a vector
     of dimensions SZ.

     If no size arguments are given then the result matrix is the
     common size of A and B.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="gca" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  gca ()
     Return a handle to the current axis object.  If no axis object
     exists, create one and return its handle.  The handle may then be
     used to examine or set properties of the axes.  For example,

          ax = gca ();
          set (ax, 'position', [0.5, 0.5, 0.5, 0.5]);

     creates an empty axes object, then changes its location and size in
     the figure window.

     See also: get, set


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="gcbf" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: FIG = gcbf ()
     Return a handle to the figure containing the object whose callback
     is currently executing.  If no callback is executing, this function
     returns the empty matrix.  The handle returned by this function is
     the same as the second output argument of gcbo.

     See also: gcf, gca, gcbo


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="gcbo" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: H = gcbo ()
 -- Function File: [H, FIG] = gcbo ()
     Return a handle to the object whose callback is currently
     executing.  If no callback is executing, this function returns the
     empty matrix.  This handle is obtained from the root object
     property 'CallbackObject'.

     Additionally return the handle of the figure containing the object
     whose callback is currently executing.  If no callback is
     executing, the second output is also set to the empty matrix.

     See also: gcf, gca, gcbf


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="gcd" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: G = gcd (A1, A2, ...)
 -- Loadable Function: [G, V1, ...] = gcd (A1, A2, ...)
     Compute the greatest common divisor of A1, A2, ....  If more than
     one argument is given all arguments must be the same size or
     scalar.  In this case the greatest common divisor is calculated
     for each element individually.  All elements must be ordinary or
     Gaussian (complex) integers.  Note that for Gaussian integers, the
     gcd is not unique up to units (multiplication by 1, -1, I or -I),
     so an arbitrary greatest common divisor amongst four possible is
     returned.  For example,

     and

          gcd ([15, 9], [20, 18])
             =>  5  9

     Optional return arguments V1, etc., contain integer vectors such
     that,

          G = V1 .* A1 + V2 .* A2 + ...

     See also: lcm, factor


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="gcf" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  gcf ()
     Return the current figure handle.  If a figure does not exist,
     create one and return its handle.  The handle may then be used to
     examine or set properties of the figure.  For example,

          fplot (@sin, [-10, 10]);
          fig = gcf ();
          set (fig, 'visible', 'off');

     plots a sine wave, finds the handle of the current figure, and then
     makes that figure invisible.  Setting the visible property of the
     figure to &quot;on&quot; will cause it to be displayed again.

     See also: get, set


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="ge" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  ge (X, Y)
     This function is equivalent to 'x &gt;= y'.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="gen_doc_cache" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  gen_doc_cache (OUT_FILE, DIRECTORY)
     Generate documentation caches for all functions in a given
     directory.

     A documentation cache is generated for all functions in DIRECTORY.
     The resulting cache is saved in the file OUT_FILE.  The cache is
     used to speed up 'lookfor'.

     If no directory is given (or it is the empty matrix), a cache for
     builtin operators, etc. is generated.

     See also: lookfor, path


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="genpath" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  genpath (DIR)
 -- Built-in Function:  genpath (DIR, SKIP, ...)
     Return a path constructed from DIR and all its subdirectories.  If
     additional string parameters are given, the resulting path will
     exclude directories with those names.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="gensig" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [U, T] = gensig (SIGTYPE, TAU)
 -- Function File: [U, T] = gensig (SIGTYPE, TAU, TFINAL)
 -- Function File: [U, T] = gensig (SIGTYPE, TAU, TFINAL, TSAM)
     Generate periodic signal.  Useful in combination with lsim.

     *Inputs*
    SIGTYPE = 'SIN'
          Sine wave.

    SIGTYPE = 'COS'
          Cosine wave.

    SIGTYPE = 'SQUARE'
          Square wave.

    SIGTYPE = 'PULSE'
          Periodic pulse.

    TAU
          Duration of one period in seconds.

    TFINAL
          Optional duration of the signal in seconds.  Default duration
          is 5 periods.

    TSAM
          Optional sampling time in seconds.  Default spacing is tau/64.

     *Outputs*
    U
          Vector of signal values.

    T
          Time vector of the signal.

     See also: lsim


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="genvarname" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: VARNAME = genvarname (STR)
 -- Function File: VARNAME = genvarname (STR, EXCLUSIONS)
     Create unique variable(s) from STR.  If EXCLUSIONS is given, then
     the variable(s) will be unique to each other and to EXCLUSIONS
     (EXCLUSIONS may be either a string or a cellstr).

     If STR is a cellstr, then a unique variable is created for each
     cell in STR.

          x = 3.141;
          genvarname ('x', who ())
            => x1

     If WANTED is a cell array, genvarname will make sure the returned
     strings are distinct:

          genvarname ({'foo', 'foo'})
            =>
               {
                 [1,1] = foo
                 [1,2] = foo1
               }

     Note that the result is a char array/cell array of strings, not the
     variables themselves.  To define a variable, 'eval()' can be used.
     The following trivial example sets 'x' to '42'.

          name = genvarname ('x');
          eval ([name ' = 42']);
            => x =  42

 ...

     USE help genvarname FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="geocdf" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  geocdf (X, P)
     For each element of X, compute the cumulative distribution function
     (CDF) at X of the geometric distribution with parameter P.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="geoinv" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  geoinv (X, P)
     For each element of X, compute the quantile (the inverse of the
     CDF) at X of the geometric distribution with parameter P.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="geopdf" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  geopdf (X, P)
     For each element of X, compute the probability density function
     (PDF) at X of the geometric distribution with parameter P.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="geornd" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  geornd (P)
 -- Function File:  geornd (P, R)
 -- Function File:  geornd (P, R, C, ...)
 -- Function File:  geornd (P, [SZ])
     Return a matrix of random samples from the geometric distribution
     with parameter P.

     When called with a single size argument, return a square matrix
     with the dimension specified.  When called with more than one
     scalar argument the first two arguments are taken as the number of
     rows and columns and any further arguments specify additional
     matrix dimensions.  The size may also be specified with a vector
     of dimensions SZ.

     If no size arguments are given then the result matrix is the size
     of P.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="get" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  get (H, P)
     Return the named property P from the graphics handle H.  If P is
     omitted, return the complete property list for H.  If H is a
     vector, return a cell array including the property values or lists
     respectively.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="get_first_help_sentence" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [TEXT, STATUS] = get_first_help_sentence (NAME)
 -- Function File: [TEXT, STATUS] = get_first_help_sentence (NAME,
          MAX_LEN)
     Return the first sentence of a function's help text.

     The first sentence is defined as the text after the function
     declaration until either the first period ('.') or the first
     appearance of two consecutive newlines ('\n\n').  The text is
     truncated to a maximum length of MAX_LEN, which defaults to 80.

     The optional output argument STATUS returns the status reported by
     'makeinfo'.  If only one output argument is requested, and STATUS
     is non-zero, a warning is displayed.

     As an example, the first sentence of this help text is

          get_first_help_sentence ('get_first_help_sentence')
          -| ans = Return the first sentence of a function's help text.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="get_help_text" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: [TEXT, FORMAT] = get_help_text (NAME)
     Return the raw help text of function NAME.

     The raw help text is returned in TEXT and the format in FORMAT The
     format is a string which is one of 'texinfo', 'html', or 'plain
     text'.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="get_help_text_from_file" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: [TEXT, FORMAT] = get_help_text_from_file (FNAME)
     Return the raw help text from the file FNAME.

     The raw help text is returned in TEXT and the format in FORMAT The
     format is a string which is one of 'texinfo', 'html', or 'plain
     text'.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="getappdata" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: VALUE = getappdata (H, NAME)
     Return the VALUE for named application data for the object(s) with
     handle(s) H.

 -- Function File: APPDATA = getappdata (H)
     Return a structure, APPDATA, whose fields correspond to the appdata
     properties.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="getegid" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: egid = getegid ()
     Return the effective group id of the current process.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="getenv" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  getenv (VAR)
     Return the value of the environment variable VAR.  For example,

          getenv ('PATH')

     returns a string containing the value of your path.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="geteuid" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: euid = geteuid ()
     Return the effective user id of the current process.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="getfield" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [V1, ...] = getfield (S, KEY, ...)
     Extract a field from a structure (or a nested structure).  For
     example:

          ss(1,2).fd(3).b = 5;
          getfield (ss, {1,2}, 'fd', {3}, 'b')
             => 5

     Note that the function call in the previous example is equivalent
     to the expression

          i1 = {1,2}; i2 = 'fd'; i3 = {3}; i4= 'b';
          ss(i1{:}).(i2)(i3{:}).(i4)
             => 5

     See also: setfield, rmfield, isfield, isstruct, fieldnames, struct


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="getgid" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: gid = getgid ()
     Return the real group id of the current process.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="getgrent" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: GRP_STRUCT = getgrent ()
     Return an entry from the group database, opening it if necessary.
     Once the end of data has been reached, 'getgrent' returns 0.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="getgrgid" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: GRP_STRUCT = getgrgid (GID).
     Return the first entry from the group database with the group ID
     GID.  If the group ID does not exist in the database, 'getgrgid'
     returns 0.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="getgrnam" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: GRP_STRUCT = getgrnam (NAME)
     Return the first entry from the group database with the group name
     NAME.  If the group name does not exist in the database,
     'getgrnam' returns 0.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="gethostname" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  gethostname ()
     Return the hostname of the system where Octave is running.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="getpgrp" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: pgid = getpgrp ()
     Return the process group id of the current process.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="getpid" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: pid = getpid ()
     Return the process id of the current process.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="getppid" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: pid = getppid ()
     Return the process id of the parent process.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="getpref" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  getpref (GROUP, PREF, DEFAULT)
     Return the preference value corresponding to the named preference
     PREF in the preference group GROUP.

     The named preference group must be a character string.

     If PREF does not exist in GROUP and DEFAULT is specified, return
     DEFAULT.

     The preference PREF may be a character string or a cell array of
     character strings.  The corresponding default value DEFAULT may be
     any value, or, if PREF is a cell array of strings, DEFAULT must be
     a cell array of values with the same size as PREF.

     If neither PREF nor DEFAULT are specified, return a structure of
     preferences for the preference group GROUP.

     If no arguments are specified, return a structure containing all
     groups of preferences and their values.

     See also: addpref, setpref, ispref, rmpref


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="getpwent" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: PW_STRUCT = getpwent ()
     Return a structure containing an entry from the password database,
     opening it if necessary.  Once the end of the data has been
     reached, 'getpwent' returns 0.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="getpwnam" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: PW_STRUCT = getpwnam (NAME)
     Return a structure containing the first entry from the password
     database with the user name NAME.  If the user name does not exist
     in the database, 'getpwname' returns 0.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="getpwuid" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: PW_STRUCT = getpwuid (UID).
     Return a structure containing the first entry from the password
     database with the user ID UID.  If the user ID does not exist in
     the database, 'getpwuid' returns 0.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="getrusage" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function:  getrusage ()
     Return a structure containing a number of statistics about the
     current Octave process.  Not all fields are available on all
     systems.  If it is not possible to get CPU time statistics, the
     CPU time slots are set to zero.  Other missing data are replaced
     by NaN.  The list of possible fields is:

    'idrss'
          Unshared data size.

    'inblock'
          Number of block input operations.

    'isrss'
          Unshared stack size.

    'ixrss'
          Shared memory size.

    'majflt'
          Number of major page faults.

    'maxrss'
          Maximum data size.

    'minflt'
          Number of minor page faults.

    'msgrcv'
          Number of messages received.

    'msgsnd'
          Number of messages sent.

    'nivcsw'
          Number of involuntary context switches.

    'nsignals'
          Number of signals received.

    'nswap'
          Number of swaps.

    'nvcsw'
          Number of voluntary con...

     USE help getrusage FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="getuid" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: uid = getuid ()
     Return the real user id of the current process.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="ginput" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [X, Y, BUTTONS] = ginput (N)
     Return which mouse buttons were pressed and keys were hit on the
     current figure.  If N is defined, then wait for N mouse clicks
     before returning.  If N is not defined, then 'ginput' will loop
     until the return key &lt;RET&gt; is pressed.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="givens" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: G = givens (X, Y)
 -- Loadable Function: [C, S] = givens (X, Y)
     Return a 2 by 2 orthogonal matrix 'G = [C S; -S' C]' such that 'G
     [X; Y] = [*; 0]' with X and Y scalars.

     For example:

          givens (1, 1)
              =>   0.70711   0.70711
                  -0.70711   0.70711

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="glob" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  glob (PATTERN)
     Given an array of pattern strings (as a char array or a cell
     array) in PATTERN, return a cell array of file names that match
     any of them, or an empty cell array if no patterns match.  The
     pattern strings are interpreted as filename globbing patterns (as
     they are used by Unix shells).  Within a pattern
    '*'
          matches any string, including the null string,

    '?'
          matches any single character, and

    '[...]'
          matches any of the enclosed characters.

     Tilde expansion is performed on each of the patterns before
     looking for matching file names.  For example:

          ls
              =>
                 file1  file2  file3  myfile1 myfile1b
          glob ('*file1')
              =>
                 {
                   [1,1] = file1
                   [2,1] = myfile1
                 }
          glob ('myfile?')
              =>
                 {
                   [1,1] = myfile1
 ...

     USE help glob FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="glpk" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [XOPT, FMIN, STATUS, EXTRA] = glpk (C, A, B, LB, UB,
          CTYPE, VARTYPE, SENSE, PARAM)
     Solve a linear program using the GNU GLPK library.  Given three
     arguments, 'glpk' solves the following standard LP:

          min C'*x

     subject to

          A*x  = b
            x &gt;= 0

     but may also solve problems of the form

          [ min | max ] C'*x

     subject to

          A*x [ '=' | '&lt;=' | '&gt;=' ] b
            x &gt;= LB
            x &lt;= UB

     Input arguments:

    C
          A column array containing the objective function coefficients.

    A
          A matrix containing the constraints coefficients.

    B
          A column array containing the right-hand side value for each
          constraint in the constraint matrix.

    LB
          An array containing the lower bound on each of the variables.
          If LB is not supplied, the default lower bound for the
          variables is zero.

    UB
          An array containing the upp...

     USE help glpk FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="gls" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [BETA, V, R] = gls (Y, X, O)
     Generalized least squares estimation for the multivariate model
     y = x*b + e with mean (e) = 0 and cov (vec (e)) = (s^2) o,  where
     y is a t by p matrix, x is a t by k matrix, b is a k by p matrix, e
     is a t by p matrix, and o is a t*p by t*p matrix.

     Each row of Y and X is an observation and each column a variable.
     The return values BETA, V, and R are defined as follows.

    BETA
          The GLS estimator for b.

    V
          The GLS estimator for s^2.

    R
          The matrix of GLS residuals, r = y - x*beta.

     See also: ols


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="gmap40" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: MAP = gmap40 ()
 -- Function File: MAP = gmap40 (N)
     Create color colormap.  The colormap consists of red, green, blue,
     yellow, magenta and cyan.  This colormap is specifically designed
     for users of gnuplot 4.0 where these 6 colors are the allowable
     ones for patch objects.  The argument N must be a scalar.  If
     unspecified, a length of 6 is assumed.  Larger values of N result
     in a repetition of the above colors.

     See also: colormap


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="gmres" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: X = gmres (A, B, M, RTOL, MAXIT, M1, M2, X0)
 -- Function File: X = gmres (A, B, M, RTOL, MAXIT, P)
 -- Function File: [X, FLAG, RELRES, ITER, RESVEC] = gmres (...)
     Solve 'A x = b' using the Preconditioned GMRES iterative method
     with restart, a.k.a. PGMRES(m).

        - RTOL is the relative tolerance, if not given or set to [] the
          default value 1e-6 is used.

        - MAXIT is the maximum number of outer iterations, if not given
          or set to [] the default value 'min (10, numel (b) /
          restart)' is used.

        - X0 is the initial guess, if not given or set to [] the
          default value 'zeros(size (b))' is used.

        - M is the restart parameter, if not given or set to [] the
          default value 'numel (b)' is used.

     Argument A can be passed as a matrix, function handle, or inline
     function 'f' such that 'f(x) = A*x'.

     The preconditioner P is given as 'P = M1 * M2'.  Both M1 and M2
     can be passed a...

     USE help gmres FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="gmtime" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: TM_STRUCT = gmtime (T)
     Given a value returned from 'time', or any non-negative integer,
     return a time structure corresponding to CUT (Coordinated
     Universal Time).  For example:

          gmtime (time ())
              => {
                    usec = 0
                    sec = 6
                    min = 15
                    hour = 7
                    mday = 17
                    mon = 1
                    year = 97
                    wday = 1
                    yday = 47
                    isdst = 0
                    zone = CST
                  }

     See also: strftime, strptime, localtime, mktime, time, now, date,
     clock, datenum, datestr, datevec, calendar, weekday


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="gnuplot_binary" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: [PROG, ARGS] = gnuplot_binary ()
 -- Loadable Function: [OLD_PROG, OLD_ARGS] = gnuplot_binary (NEW_PROG,
          ARG1, ...)
     Query or set the name of the program invoked by the plot command
     when the graphics toolkit is set to 'gnuplot'.  Additional
     arguments to pass to the external plotting program may also be
     given.  The default value is &quot;gnuplot&quot; without additional
     arguments.  *Note Installation::.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="gplot" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  gplot (A, XY)
 -- Function File:  gplot (A, XY, LINE_STYLE)
 -- Function File: [X, Y] = gplot (A, XY)
     Plot a graph defined by A and XY in the graph theory sense.  A is
     the adjacency matrix of the array to be plotted and XY is an
     N-by-2 matrix containing the coordinates of the nodes of the graph.

     The optional parameter LINE_STYLE defines the output style for the
     plot.  Called with no output arguments the graph is plotted
     directly.  Otherwise, return the coordinates of the plot in X and
     Y.

     See also: treeplot, etreeplot, spy


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="gradient" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: DX = gradient (M)
 -- Function File: [DX, DY, DZ, ...] = gradient (M)
 -- Function File: [...] = gradient (M, S)
 -- Function File: [...] = gradient (M, X, Y, Z, ...)
 -- Function File: [...] = gradient (F, X0)
 -- Function File: [...] = gradient (F, X0, S)
 -- Function File: [...] = gradient (F, X0, X, Y, ...)
     Calculate the gradient of sampled data or a function.  If M is a
     vector, calculate the one-dimensional gradient of M.  If M is a
     matrix the gradient is calculated for each dimension.

     '[DX, DY] = gradient (M)' calculates the one dimensional gradient
     for X and Y direction if M is a matrix.  Additional return
     arguments can be use for multi-dimensional matrices.

     A constant spacing between two points can be provided by the S
     parameter.  If S is a scalar, it is assumed to be the spacing for
     all dimensions.  Otherwise, separate values of the spacing can be
     supplied by the X, ... arguments.  Scalar values specify an
...

     USE help gradient FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="gram" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: W = gram (SYS, MODE)
 -- Function File: WC = gram (A, B)
     'gram (SYS, 'c')' returns the controllability gramian of the
     (continuous- or discrete-time) system SYS.  'gram (SYS, 'o')'
     returns the observability gramian of the (continuous- or
     discrete-time) system SYS.  'gram (A, B)' returns the
     controllability gramian WC of the continuous-time system dx/dt = a
     x + b u; i.e., WC satisfies a Wc + m Wc' + b b' = 0.


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="graphics_toolkit" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: NAME = graphics_toolkit ()
 -- Function File: OLD_NAME = graphics_toolkit (NAME)
 -- Function File:  graphics_toolkit (HLIST, NAME)
     Query or set the default graphics toolkit to NAME.  If the toolkit
     is not already loaded, it is first initialized by calling the
     function '__init_NAME__'.

     When called with a list of figure handles, HLIST, the graphics
     toolkit is changed only for the listed figures.

     See also: available_graphics_toolkits


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="gray" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: MAP = gray ()
 -- Function File: MAP = gray (N)
     Create gray colormap.  This colormap varies from black to white
     with shades of gray.  The argument N must be a scalar.  If
     unspecified, the length of the current colormap, or 64, is used.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="gray2ind" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [IMG, MAP] = gray2ind (I, N)
     Convert a gray scale intensity image to an Octave indexed image.
     The indexed image will consist of N different intensity values.
     If not given N will default to 64.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="grid" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  grid (ARG)
 -- Function File:  grid ('minor', ARG2)
 -- Function File:  grid (HAX, ...)
     Force the display of a grid on the plot.  The argument may be
     either &quot;on&quot;, or &quot;off&quot;.  If it is omitted, the current grid
     state is toggled.

     If ARG is &quot;minor&quot; then the minor grid is toggled.  When using a
     minor grid a second argument ARG2 is allowed, which can be either
     &quot;on&quot; or &quot;off&quot; to explicitly set the state of the minor grid.

     If the first argument is an axis handle, HAX, operate on the
     specified axis object.

     See also: plot


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="griddata" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: ZI = griddata (X, Y, Z, XI, YI, METHOD)
 -- Function File: [XI, YI, ZI] = griddata (X, Y, Z, XI, YI, METHOD)
     Generate a regular mesh from irregular data using interpolation.
     The function is defined by 'Z = f (X, Y)'.  Inputs 'X, Y, Z' are
     vectors of the same length or 'X, Y' are vectors and 'Z' is matrix.

     The interpolation points are all '(XI, YI)'.  If XI, YI are
     vectors then they are made into a 2-D mesh.

     The interpolation method can be &quot;nearest&quot;, &quot;cubic&quot; or
     &quot;linear&quot;.  If method is omitted it defaults to &quot;linear&quot;.

     See also: delaunay


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="griddata3" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: VI = griddata3 (X, Y, Z, V, XI, YI, ZI, METHOD,
          OPTIONS)
     Generate a regular mesh from irregular data using interpolation.
     The function is defined by 'V = f (X, Y, Z)'.  The interpolation
     points are specified by XI, YI, ZI.

     The interpolation method can be &quot;nearest&quot; or &quot;linear&quot;.  If
     method is omitted it defaults to &quot;linear&quot;.

     See also: griddata, griddatan, delaunayn


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="griddatan" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: YI = griddatan (X, Y, XI, METHOD, OPTIONS)
     Generate a regular mesh from irregular data using interpolation.
     The function is defined by 'Y = f (X)'.  The interpolation points
     are all XI.

     The interpolation method can be &quot;nearest&quot; or &quot;linear&quot;.  If
     method is omitted it defaults to &quot;linear&quot;.

     See also: griddata, delaunayn


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="gt" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  gt (X, Y)
     This function is equivalent to 'x &gt; y'.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="gtext" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  gtext (S)
 -- Function File:  gtext ({S1; S2; ...})
 -- Function File:  gtext (..., PROP, VAL)
     Place text on the current figure using the mouse.  The text is
     defined by the string S.  If S is a cell array, each element of
     the cell array is written to a separate line.  Additional
     arguments are passed to the underlying text object as properties.

     See also: ginput, text


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="gui_mode" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: MODE = gui_mode ()
 -- Built-in Function:  gui_mode (MODE)
     Query or set the GUI mode for the current graphics toolkit.  The
     MODE argument can be one of the following strings:
    '2d'
          Allows panning and zooming of current axes.

    '3d'
          Allows rotating and zooming of current axes.

    'none'
          Mouse inputs have no effect.

     This function is currently implemented only for the FLTK graphics
     toolkit.

     See also: mouse_wheel_zoom


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="guidata" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: DATA = guidata (HANDLE)
 -- Function File:  guidata (HANDLE, DATA)

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="guihandles" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: HDATA = guihandles (HANDLE)
 -- Function File: HDATA = guihandles

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="gunzip" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  gunzip (GZFILE, DIR)
     Unpack the gzip archive GZFILE to the directory DIR.  If DIR is
     not specified, it defaults to the current directory.  If GZFILE is
     a directory, all gzfiles in the directory will be recursively
     gunzipped.

     See also: gzip, unpack, bunzip2, unzip, untar


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="gzip" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: ENTRIES = gzip (FILES)
 -- Function File: ENTRIES = gzip (FILES, OUTDIR)
     Compress the list of files and/or directories specified in FILES.
     Each file is compressed separately and a new file with a '.gz'
     extension is created.  The original files are not modified.
     Existing compressed files are silently overwritten.  If OUTDIR is
     defined the compressed files are placed in this directory.

     See also: gunzip, bzip2, zip, tar


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="h2syn" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [K, N, GAMMA, RCOND] = h2syn (P, NMEAS, NCON)
     H-2 control synthesis for LTI plant.

     *Inputs*
    P
          Generalized plant.  Must be a proper/realizable LTI model.

    NMEAS
          Number of measured outputs v.  The last nmeas outputs of P
          are connected to the inputs of controller K.  The remaining
          outputs z (indices 1 to p-nmeas) are used to calculate the
          H-2 norm.

    NCON
          Number of controlled inputs u.  The last ncon inputs of P are
          connected to the outputs of controller K.  The remaining
          inputs w (indices 1 to m-ncon) are excited by a harmonic test
          signal.

     *Outputs*
    K
          State-space model of the H-2 optimal controller.

    N
          State-space model of the lower LFT of P and K.

    GAMMA
          H-2 norm of N.

    RCOND
          Vector RCOND contains estimates of the reciprocal condition
          numbers of the matrices which are to be inverted and
...

     USE help h2syn FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="hadamard" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  hadamard (N)
     Construct a Hadamard matrix (Hn) of size N-by-N.  The size N must
     be of the form 2^k * p in which p is one of 1, 12, 20 or 28.  The
     returned matrix is normalized, meaning 'Hn(:,1) == 1' and
     'Hn(1,:) == 1'.

     Some of the properties of Hadamard matrices are:

        * 'kron (Hm, Hn)' is a Hadamard matrix of size M-by-N.

        * 'Hn * Hn' = N * eye (N)'.

        * The rows of Hn are orthogonal.

        * 'det (A) &lt;= abs (det (Hn))' for all A with
          'abs (A(i, j)) &lt;= 1'.

        * Multiplying any row or column by -1 and the matrix will
          remain a Hadamard matrix.

     See also: compan, hankel, toeplitz


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="hamming" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  hamming (M)
     Return the filter coefficients of a Hamming window of length M.

     For a definition of the Hamming window, see e.g., A. V. Oppenheim &amp;amp;
     R. W. Schafer, 'Discrete-Time Signal Processing'.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="hankel" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  hankel (C)
 -- Function File:  hankel (C, R)
     Return the Hankel matrix constructed from the first column C, and
     (optionally) the last row R.  If the last element of C is not the
     same as the first element of R, the last element of C is used.  If
     the second argument is omitted, it is assumed to be a vector of
     zeros with the same size as C.

     A Hankel matrix formed from an m-vector C, and an n-vector R, has
     the elements

          H(i,j) = c(i+j-1),  i+j-1 &lt;= m;
          H(i,j) = r(i+j-m),  otherwise

     See also: hadamard, toeplitz


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="hanning" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  hanning (M)
     Return the filter coefficients of a Hanning window of length M.

     For a definition of this window type, see e.g., A. V. Oppenheim &amp;
     R. W. Schafer, 'Discrete-Time Signal Processing'.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="help" func="yes">
            <Overload retVal="">
                <Param name="
 -- Command:  help NAME
 -- Command:  help '--list'
     Display the help text for NAME.   For example, the command 'help
     help' prints a short message describing the 'help' command.

     Given the single argument '--list', list all operators, keywords,
     built-in functions, and loadable functions available in the
     current session of Octave.

     If invoked without any arguments, 'help' display instructions on
     how to access help from the command line.

     The help command can give you information about operators, but not
     the comma and semicolons that are used as command separators.  To
     get help for those, you must type 'help comma' or 'help semicolon'.

     See also: doc, lookfor, which


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="hess" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: H = hess (A)
 -- Loadable Function: [P, H] = hess (A)
     Compute the Hessenberg decomposition of the matrix A.

     The Hessenberg decomposition is 'P * H * P' = A' where P is a
     square unitary matrix ('P' * P = I', using complex-conjugate
     transposition) and H is upper Hessenberg ('H(i, j) = 0 forall i &gt;=
     j+1)'.

     The Hessenberg decomposition is usually used as the first step in
     an eigenvalue computation, but has other applications as well (see
     Golub, Nash, and Van Loan, IEEE Transactions on Automatic Control,
     1979).

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="hex2dec" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  hex2dec (S)
     Return the integer corresponding to the hexadecimal number
     represented by the string S.  For example:

          hex2dec ('12B')
               => 299
          hex2dec ('12b')
               => 299

     If S is a string matrix, return a column vector with one converted
     number per row of S; Invalid rows evaluate to NaN.

     If S is a cell array of strings, return a column vector with one
     converted number per cell element in S.

     See also: dec2hex, base2dec, bin2dec


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="hex2num" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: N = hex2num (S)
     Typecast the 16 character hexadecimal character string to an IEEE
     754 double precision number.  If fewer than 16 characters are
     given the strings are right padded with '0' characters.

     Given a string matrix, 'hex2num' treats each row as a separate
     number.

          hex2num (['4005bf0a8b145769';'4024000000000000'])
          => [2.7183; 10.000]

     See also: num2hex, hex2dec, dec2hex


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="hggroup" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  hggroup ()
 -- Function File:  hggroup (H)
 -- Function File:  hggroup (..., PROPERTY, VALUE, ...)
     Create group object with parent H.  If no parent is specified, the
     group is created in the current axes.  Return the handle of the
     group object created.

     Multiple property-value pairs may be specified for the group, but
     they must appear in pairs.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="hidden" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  hidden (MODE)
 -- Function File:  hidden ()
     Manipulation the mesh hidden line removal.  Called with no argument
     the hidden line removal is toggled.  The argument MODE can be
     either 'on' or 'off' and the set of the hidden line removal is set
     accordingly.

     See also: mesh, meshc, surf


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="hilb" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  hilb (N)
     Return the Hilbert matrix of order N.  The i,j element of a
     Hilbert matrix is defined as

          H(i, j) = 1 / (i + j - 1)

     Hilbert matrices are close to being singular which make them
     difficult to invert with numerical routines.  Comparing the
     condition number of a random matrix 5x5 matrix with that of a
     Hilbert matrix of order 5 reveals just how difficult the problem
     is.

          cond (rand (5))
             => 14.392
          cond (hilb (5))
             => 4.7661e+05

     See also: invhilb


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="hinfsyn" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [K, N, GAMMA, RCOND] = hinfsyn (P, NMEAS, NCON)
 -- Function File: [K, N, GAMMA, RCOND] = hinfsyn (P, NMEAS, NCON, GMAX)
     H-infinity control synthesis for LTI plant.

     *Inputs*
    P
          Generalized plant.  Must be a proper/realizable LTI model.

    NMEAS
          Number of measured outputs v.  The last nmeas outputs of P
          are connected to the inputs of controller K.  The remaining
          outputs z (indices 1 to p-nmeas) are used to calculate the
          H-infinity norm.

    NCON
          Number of controlled inputs u.  The last ncon inputs of P are
          connected to the outputs of controller K.  The remaining
          inputs w (indices 1 to m-ncon) are excited by a harmonic test
          signal.

    GMAX
          The maximum value of the H-infinity norm of N.  It is assumed
          that GMAX is sufficiently large so that the controller is
          admissible.

     *Outputs*
    K
          State-space model of the H-infin...

     USE help hinfsyn FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="hist" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  hist (Y)
 -- Function File:  hist (Y, X)
 -- Function File:  hist (Y, NBINS)
 -- Function File:  hist (Y, X, NORM)
 -- Function File: [NN, XX] = hist (...)
 -- Function File: [...] = hist (..., PROP, VAL)
     Produce histogram counts or plots.

     With one vector input argument, Y, plot a histogram of the values
     with 10 bins.  The range of the histogram bins is determined by the
     range of the data.  With one matrix input argument, Y, plot a
     histogram where each bin contains a bar per input column.

     Given a second vector argument, X, use that as the centers of the
     bins, with the width of the bins determined from the adjacent
     values in the vector.

     If scalar, the second argument, NBINS, defines the number of bins.

     If a third argument is provided, the histogram is normalized such
     that the sum of the bars is equal to NORM.

     Extreme values are lumped in the first and last bins.

     With two output arguments, produce ...

     USE help hist FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="histc" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: N = histc (X, EDGES)
 -- Function File: N = histc (X, EDGES, DIM)
 -- Function File: [N, IDX] = histc (...)
     Produce histogram counts.

     When X is a vector, the function counts the number of elements of
     X that fall in the histogram bins defined by EDGES.  This must be
     a vector of monotonically increasing values that define the edges
     of the histogram bins.  'N(k)' contains the number of elements in
     X for which 'EDGES(k) &lt;= X &lt; EDGES(k+1)'.  The final element of N
     contains the number of elements of X exactly equal to the last
     element of EDGES.

     When X is an N-dimensional array, the computation is carried out
     along dimension DIM.  If not specified DIM defaults to the first
     non-singleton dimension.

     When a second output argument is requested an index matrix is also
     returned.  The IDX matrix has the same size as X.  Each element of
     IDX contains the index of the histogram bin in which the
     correspondin...

     USE help histc FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="history" func="yes">
            <Overload retVal="">
                <Param name="
 -- Command:  history options
     If invoked with no arguments, 'history' displays a list of commands
     that you have executed.  Valid options are:

    '-w FILE'
          Write the current history to the file FILE.  If the name is
          omitted, use the default history file (normally
          '~/.octave_hist').

    '-r FILE'
          Read the file FILE, appending its contents to the current
          history list.  If the name is omitted, use the default
          history file (normally '~/.octave_hist').

    'N'
          Display only the most recent N lines of history.

    '-q'
          Don't number the displayed lines of history.  This is useful
          for cutting and pasting commands using the X Window System.

     For example, to display the five most recent commands that you have
     typed without displaying line numbers, use the command 'history -q
     5'.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="history_control" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: VAL = history_control ()
 -- Built-in Function: OLD_VAL = history_control (NEW_VAL)
     Query or set the internal variable that specifies how commands are
     saved to the history list.  The default value is an empty
     character string, but may be overridden by the environment variable
     'OCTAVE_HISTCONTROL'.

     The value of 'history_control' is a colon-separated list of values
     controlling how commands are saved on the history list.  If the
     list of values includes 'ignorespace', lines which begin with a
     space character are not saved in the history list.  A value of
     'ignoredups' causes lines matching the previous history entry to
     not be saved.  A value of 'ignoreboth' is shorthand for
     'ignorespace' and 'ignoredups'.  A value of 'erasedups' causes all
     previous lines matching the current line to be removed from the
     history list before that line is saved.  Any value not in the
     above list is ignored.  If 'history...

     USE help history_control FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="history_file" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: VAL = history_file ()
 -- Built-in Function: OLD_VAL = history_file (NEW_VAL)
     Query or set the internal variable that specifies the name of the
     file used to store command history.  The default value is
     '~/.octave_hist', but may be overridden by the environment
     variable 'OCTAVE_HISTFILE'.

     See also: history_size, saving_history,
     history_timestamp_format_string


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="history_size" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: VAL = history_size ()
 -- Built-in Function: OLD_VAL = history_size (NEW_VAL)
     Query or set the internal variable that specifies how many entries
     to store in the history file.  The default value is '1024', but
     may be overridden by the environment variable 'OCTAVE_HISTSIZE'.

     See also: history_file, history_timestamp_format_string,
     saving_history


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="history_timestamp_format_string" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: VAL = history_timestamp_format_string ()
 -- Built-in Function: OLD_VAL = history_timestamp_format_string
          (NEW_VAL)
 -- Built-in Function:  history_timestamp_format_string (NEW_VAL,
          'local')
     Query or set the internal variable that specifies the format string
     for the comment line that is written to the history file when
     Octave exits.  The format string is passed to 'strftime'.  The
     default value is

          '# Octave VERSION, %a %b %d %H:%M:%S %Y %Z &lt;USER@HOST&gt;'

     When called from inside a function with the 'local' option, the
     variable is changed locally for the function and any subroutines
     it calls.  The original variable value is restored when exiting
     the function.

     See also: strftime, history_file, history_size, saving_history


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="hnamodred" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [GR, INFO] = hnamodred (G, ...)
 -- Function File: [GR, INFO] = hnamodred (G, NR, ...)
 -- Function File: [GR, INFO] = hnamodred (G, OPT, ...)
 -- Function File: [GR, INFO] = hnamodred (G, NR, OPT, ...)
     Model order reduction by frequency weighted optimal Hankel-norm
     (HNA) method.  The aim of model reduction is to find an LTI system
     GR of order NR (nr &lt; n) such that the input-output behaviour of GR
     approximates the one from original system G.

     HNA is an absolute error method which tries to minimize
          ||G-Gr||  = min
                  H

          ||V (G-Gr) W||  = min
                        H
     where V and W denote output and input weightings.

     *Inputs*
    G
          LTI model to be reduced.

    NR
          The desired order of the resulting reduced order system GR.
          If not specified, NR is chosen automatically according to the
          description of key 'ORDER'.

    ...
          Optional pairs of keys and val...

     USE help hnamodred FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="hold" func="yes">
            <Overload retVal="">
                <Param name="
 -- Command:  hold
 -- Command:  hold STATE
 -- Function File:  hold (HAX, ...)
     Toggle or set the 'hold' state of the plotting engine which
     determines whether new graphic objects are added to the plot or
     replace the existing objects.

    'hold on'
          Retain plot data and settings so that subsequent plot
          commands are displayed on a single graph.

    'hold all'
          Retain plot line color, line style, data and settings so that
          subsequent plot commands are displayed on a single graph with
          the next line color and style.

    'hold off'
          Clear plot and restore default graphics settings before each
          new plot command.  (default).

    'hold'
          Toggle the current 'hold' state.

     When given the additional argument HAX, the hold state is modified
     only for the given axis handle.

     To query the current 'hold' state use the 'ishold' function.

     See also: ishold, cla, newplot, clf


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="horzcat" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  horzcat (ARRAY1, ARRAY2, ..., ARRAYN)
     Return the horizontal concatenation of N-D array objects, ARRAY1,
     ARRAY2, ..., ARRAYN along dimension 2.

     Arrays may also be concatenated horizontally using the syntax for
     creating new matrices.  For example:

          HCAT = [ ARRAY1, ARRAY2, ... ];

     See also: cat, vertcat


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="hot" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: MAP = hot ()
 -- Function File: MAP = hot (N)
     Create color colormap.  This colormap ranges from black through
     dark red, red, orange, yellow, to white.  The argument N must be a
     scalar.  If unspecified, the length of the current colormap, or
     64, is used.

     See also: colormap


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="hotelling_test" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [PVAL, TSQ] = hotelling_test (X, M)
     For a sample X from a multivariate normal distribution with unknown
     mean and covariance matrix, test the null hypothesis that 'mean
     (X) == M'.

     Hotelling's T^2 is returned in TSQ.  Under the null, (n-p) T^2 /
     (p(n-1)) has an F distribution with p and n-p degrees of freedom,
     where n and p are the numbers of samples and variables,
     respectively.

     The p-value of the test is returned in PVAL.

     If no output argument is given, the p-value of the test is
     displayed.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="hotelling_test_2" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [PVAL, TSQ] = hotelling_test_2 (X, Y)
     For two samples X from multivariate normal distributions with the
     same number of variables (columns), unknown means and unknown
     equal covariance matrices, test the null hypothesis 'mean (X) ==
     mean (Y)'.

     Hotelling's two-sample T^2 is returned in TSQ.  Under the null,

          (n_x+n_y-p-1) T^2 / (p(n_x+n_y-2))

     has an F distribution with p and n_x+n_y-p-1 degrees of freedom,
     where n_x and n_y are the sample sizes and p is the number of
     variables.

     The p-value of the test is returned in PVAL.

     If no output argument is given, the p-value of the test is
     displayed.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="housh" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [HOUSV, BETA, ZER] = housh (X, J, Z)
     Compute Householder reflection vector HOUSV to reflect X to be the
     j-th column of identity, i.e.,

          (I - beta*housv*housv')x =  norm(x)*e(j) if x(j) &lt; 0,
          (I - beta*housv*housv')x = -norm(x)*e(j) if x(j) &gt;= 0

     Inputs

    X
          vector

    J
          index into vector

    Z
          threshold for zero  (usually should be the number 0)

     Outputs (see Golub and Van Loan):

    BETA
          If beta = 0, then no reflection need be applied (zer set to 0)

    HOUSV
          householder vector

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="hsv" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  hsv (N)
     Create color colormap.  This colormap begins with red, changes
     through yellow, green, cyan, blue, and magenta, before returning
     to red.  It is useful for displaying periodic functions.  It is
     obtained by linearly varying the hue through all possible values
     while keeping constant maximum saturation and value and is
     equivalent to 'hsv2rgb ([linspace(0,1,N)', ones(N,2)])'.

     The argument N must be a scalar.  If unspecified, the length of
     the current colormap, or 64, is used.

     See also: colormap


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="hsv2rgb" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: RGB_MAP = hsv2rgb (HSV_MAP)
     Transform a colormap or image from the HSV space to the RGB space.

     See also: rgb2hsv


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="hsvd" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: HSV = hsvd (SYS)
 -- Function File: HSV = hsvd (SYS, 'OFFSET', OFFSET)
 -- Function File: HSV = hsvd (SYS, 'ALPHA', ALPHA)
     Hankel singular values of the stable part of an LTI model.  If no
     output arguments are given, the Hankel singular values are
     displayed in a plot.

     *Algorithm*
     Uses SLICOT AB13AD by courtesy of NICONET e.V.
     (http://www.slicot.org)

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="hurst" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  hurst (X)
     Estimate the Hurst parameter of sample X via the rescaled range
     statistic.  If X is a matrix, the parameter is estimated for every
     single column.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="hygecdf" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  hygecdf (X, T, M, N)
     Compute the cumulative distribution function (CDF) at X of the
     hypergeometric distribution with parameters T, M, and N.  This is
     the probability of obtaining not more than X marked items when
     randomly drawing a sample of size N without replacement from a
     population of total size T containing M marked items.

     The parameters T, M, and N must be positive integers with M and N
     not greater than T.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="hygeinv" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  hygeinv (X, T, M, N)
     For each element of X, compute the quantile (the inverse of the
     CDF) at X of the hypergeometric distribution with parameters T, M,
     and N.  This is the probability of obtaining X marked items when
     randomly drawing a sample of size N without replacement from a
     population of total size T containing M marked items.

     The parameters T, M, and N must be positive integers with M and N
     not greater than T.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="hygepdf" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  hygepdf (X, T, M, N)
     Compute the probability density function (PDF) at X of the
     hypergeometric distribution with parameters T, M, and N.  This is
     the probability of obtaining X marked items when randomly drawing
     a sample of size N without replacement from a population of total
     size T containing M marked items.

     The parameters T, M, and N must be positive integers with M and N
     not greater than T.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="hygernd" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  hygernd (T, M, N)
 -- Function File:  hygernd (T, M, N, R)
 -- Function File:  hygernd (T, M, N, R, C, ...)
 -- Function File:  hygernd (T, M, N, [SZ])
     Return a matrix of random samples from the hypergeometric
     distribution with parameters T, M, and N.

     The parameters T, M, and N must be positive integers with M and N
     not greater than T.

     When called with a single size argument, return a square matrix
     with the dimension specified.  When called with more than one
     scalar argument the first two arguments are taken as the number of
     rows and columns and any further arguments specify additional
     matrix dimensions.  The size may also be specified with a vector
     of dimensions SZ.

     If no size arguments are given then the result matrix is the
     common size of T, M, and N.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="hypot" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  hypot (X, Y)
 -- Built-in Function:  hypot (X, Y, Z, ...)
     Compute the element-by-element square root of the sum of the
     squares of X and Y.  This is equivalent to 'sqrt (X.^2 + Y.^2)',
     but calculated in a manner that avoids overflows for large values
     of X or Y.  'hypot' can also be called with more than 2 arguments;
     in this case, the arguments are accumulated from left to right:

           hypot (hypot (X, Y), Z)
           hypot (hypot (hypot (X, Y), Z), W), etc.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="I" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  I
 -- Built-in Function:  I (N)
 -- Built-in Function:  I (N, M)
 -- Built-in Function:  I (N, M, K, ...)
 -- Built-in Function:  I (..., CLASS)
     Return a scalar, matrix, or N-dimensional array whose elements are
     all equal to the pure imaginary unit, defined as 'sqrt (-1)'.  I,
     and its equivalents i, J, and j, are functions so any of the names
     may be reused for other purposes (such as i for a counter
     variable).

     When called with no arguments, return a scalar with the value i.
     When called with a single argument, return a square matrix with
     the dimension specified.  When called with more than one scalar
     argument the first two arguments are taken as the number of rows
     and columns and any further arguments specify additional matrix
     dimensions.  The optional argument CLASS specifies the return type
     and may be either 'double' or 'single'.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="idivide" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  idivide (X, Y, OP)
     Integer division with different rounding rules.

     The standard behavior of integer division such as 'A ./ B' is to
     round the result to the nearest integer.  This is not always the
     desired behavior and 'idivide' permits integer element-by-element
     division to be performed with different treatment for the
     fractional part of the division as determined by the OP flag.  OP
     is a string with one of the values:

    'fix'
          Calculate 'A ./ B' with the fractional part rounded towards
          zero.

    'round'
          Calculate 'A ./ B' with the fractional part rounded towards
          the nearest integer.

    'floor'
          Calculate 'A ./ B' with the fractional part rounded towards
          negative infinity.

    'ceil'
          Calculate 'A ./ B' with the fractional part rounded towards
          positive infinity.

     If OP is not given it defaults to &quot;fix&quot;.  An example
     demonstrating these r...

     USE help idivide FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="ifft" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function:  ifft (X)
 -- Loadable Function:  ifft (X, N)
 -- Loadable Function:  ifft (X, N, DIM)
     Compute the inverse discrete Fourier transform of A using a Fast
     Fourier Transform (FFT) algorithm.

     The inverse FFT is calculated along the first non-singleton
     dimension of the array.  Thus if X is a matrix, 'fft (X)' computes
     the inverse FFT for each column of X.

     If called with two arguments, N is expected to be an integer
     specifying the number of elements of X to use, or an empty matrix
     to specify that its value should be ignored.  If N is larger than
     the dimension along which the inverse FFT is calculated, then X is
     resized and padded with zeros.  Otherwise, if N is smaller than
     the dimension along which the inverse FFT is calculated, then X is
     truncated.

     If called with three arguments, DIM is an integer specifying the
     dimension of the matrix along which the inverse FFT is performed

     See also: fft,...

     USE help ifft FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="ifft2" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function:  ifft2 (A)
 -- Loadable Function:  ifft2 (A, M, N)
     Compute the inverse two-dimensional discrete Fourier transform of A
     using a Fast Fourier Transform (FFT) algorithm.

     The optional arguments M and N may be used specify the number of
     rows and columns of A to use.  If either of these is larger than
     the size of A, A is resized and padded with zeros.

     If A is a multi-dimensional matrix, each two-dimensional sub-matrix
     of A is treated separately

     See also: fft2, ifft, ifftn, fftw


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="ifftn" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function:  ifftn (A)
 -- Loadable Function:  ifftn (A, SIZE)
     Compute the inverse N-dimensional discrete Fourier transform of A
     using a Fast Fourier Transform (FFT) algorithm.

     The optional vector argument SIZE may be used specify the
     dimensions of the array to be used.  If an element of SIZE is
     smaller than the corresponding dimension of A, then the dimension
     of A is truncated prior to performing the inverse FFT.  Otherwise,
     if an element of SIZE is larger than the corresponding dimension
     then A is resized and padded with zeros.

     See also: fftn, ifft, ifft2, fftw


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="ifftshift" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  ifftshift (X)
 -- Function File:  ifftshift (X, DIM)
     Undo the action of the 'fftshift' function.  For even length X,
     'fftshift' is its own inverse, but odd lengths differ slightly.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="ignore_function_time_stamp" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: VAL = ignore_function_time_stamp ()
 -- Built-in Function: OLD_VAL = ignore_function_time_stamp (NEW_VAL)
     Query or set the internal variable that controls whether Octave
     checks the time stamp on files each time it looks up functions
     defined in function files.  If the internal variable is set to
     &quot;system&quot;, Octave will not automatically recompile function files
     in subdirectories of 'OCTAVE-HOME/lib/VERSION' if they have
     changed since they were last compiled, but will recompile other
     function files in the search path if they change.  If set to
     &quot;all&quot;, Octave will not recompile any function files unless their
     definitions are removed with 'clear'.  If set to 'none', Octave
     will always check time stamps on files to determine whether
     functions defined in function files need to recompiled.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="imag" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  imag (Z)
     Return the imaginary part of Z as a real number.

     See also: real, conj


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="image" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  image (IMG)
 -- Function File:  image (X, Y, IMG)
 -- Function File: H = image (...)
     Display a matrix as a color image.  The elements of IMG are indices
     into the current colormap, and the colormap will be scaled so that
     the extremes of IMG are mapped to the extremes of the colormap.

     The axis values corresponding to the matrix elements are specified
     in X and Y.  If you're not using gnuplot 4.2 or later, these
     variables are ignored.

     Implementation Note: The origin (0, 0) for images is located in the
     upper left.  For ordinary plots, the origin is located in the lower
     left.  Octave handles this inversion by plotting the data normally,
     and then reversing the direction of the y-axis by setting the
     'ydir' property to &quot;reverse&quot;.  This has implications whenever an
     image and an ordinary plot need to be overlaid.  The recommended
     solution is to display the image and then plot the reversed ydata
     using, fo...

     USE help image FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="IMAGE_PATH" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: VAL = IMAGE_PATH ()
 -- Built-in Function: OLD_VAL = IMAGE_PATH (NEW_VAL)
 -- Built-in Function:  IMAGE_PATH (NEW_VAL, 'local')
     Query or set the internal variable that specifies a colon separated
     list of directories in which to search for image files.

     When called from inside a function with the 'local' option, the
     variable is changed locally for the function and any subroutines
     it calls.  The original variable value is restored when exiting
     the function.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="imagesc" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  imagesc (A)
 -- Function File:  imagesc (X, Y, A)
 -- Function File:  imagesc (..., LIMITS)
 -- Function File:  imagesc (H, ...)
 -- Function File: H = imagesc (...)
     Display a scaled version of the matrix A as a color image.  The
     colormap is scaled so that the entries of the matrix occupy the
     entire colormap.  If LIMITS = [LO, HI] are given, then that range
     is set to the 'clim' of the current axes.

     The axis values corresponding to the matrix elements are specified
     in X and Y, either as pairs giving the minimum and maximum values
     for the respective axes, or as values for each row and column of
     the matrix A.

     The optional return value H is a graphics handle to the image.

     See also: image, imshow, caxis


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="imfinfo" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: INFO = imfinfo (FILENAME)
 -- Function File: INFO = imfinfo (URL)
     Read image information from a file.

     'imfinfo' returns a structure containing information about the
     image stored in the file FILENAME.  The output structure contains
     the following fields.

    'Filename'
          The full name of the image file.

    'FileSize'
          Number of bytes of the image on disk

    'FileModDate'
          Date of last modification to the file.

    'Height'
          Image height in pixels.

    'Width'
          Image Width in pixels.

    'BitDepth'
          Number of bits per channel per pixel.

    'Format'
          Image format (e.g., &quot;jpeg&quot;).

    'LongFormat'
          Long form image format description.

    'XResolution'
          X resolution of the image.

    'YResolution'
          Y resolution of the image.

    'TotalColors'
          Number of unique colors in the image.

    'TileName'
          Tile name.

    'AnimationDelay'
  ...

     USE help imfinfo FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="impulse" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [Y, T, X] = impulse (SYS)
 -- Function File: [Y, T, X] = impulse (SYS, T)
 -- Function File: [Y, T, X] = impulse (SYS, TFINAL)
 -- Function File: [Y, T, X] = impulse (SYS, TFINAL, DT)
     Impulse response of LTI system.  If no output arguments are given,
     the response is printed on the screen.

     *Inputs*
    SYS
          LTI model.

    T
          Time vector.  Should be evenly spaced.  If not specified, it
          is calculated by the poles of the system to reflect
          adequately the response transients.

    TFINAL
          Optional simulation horizon.  If not specified, it is
          calculated by the poles of the system to reflect adequately
          the response transients.

    DT
          Optional sampling time.  Be sure to choose it small enough to
          capture transient phenomena.  If not specified, it is
          calculated by the poles of the system.

     *Outputs*
    Y
          Output response array.  Has as many rows as t...

     USE help impulse FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="imread" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [IMG, MAP, ALPHA] = imread (FILENAME)
     Read images from various file formats.

     The size and numeric class of the output depends on the format of
     the image.  A color image is returned as an MxNx3 matrix.
     Gray-level and black-and-white images are of size MxN.  The color
     depth of the image determines the numeric class of the output:
     'uint8' or 'uint16' for gray and color, and 'logical' for black
     and white.

     See also: imwrite, imfinfo


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="imshow" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  imshow (IM)
 -- Function File:  imshow (IM, LIMITS)
 -- Function File:  imshow (IM, MAP)
 -- Function File:  imshow (RGB, ...)
 -- Function File:  imshow (FILENAME)
 -- Function File:  imshow (..., STRING_PARAM1, VALUE1, ...)
 -- Function File: H = imshow (...)
     Display the image IM, where IM can be a 2-dimensional (gray-scale
     image) or a 3-dimensional (RGB image) matrix.

     If LIMITS is a 2-element vector '[LOW, HIGH]', the image is shown
     using a display range between LOW and HIGH.  If an empty matrix is
     passed for LIMITS, the display range is computed as the range
     between the minimal and the maximal value in the image.

     If MAP is a valid color map, the image will be shown as an indexed
     image using the supplied color map.

     If a file name is given instead of an image, the file will be read
     and shown.

     If given, the parameter STRING_PARAM1 has value VALUE1.
     STRING_PARAM1 can be any of the following:
    'displa...

     USE help imshow FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="imwrite" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  imwrite (IMG, FILENAME)
 -- Function File:  imwrite (IMG, FILENAME, FMT)
 -- Function File:  imwrite (IMG, FILENAME, FMT, P1, V1, ...)
 -- Function File:  imwrite (IMG, MAP, FILENAME, ...)
     Write images in various file formats.

     If FMT is not supplied, the file extension of FILENAME is used to
     determine the format.

     The parameter-value pairs (P1, V1, ...) are optional.  Currently
     the following options are supported for JPEG images:

    'Quality'
          Set the quality of the compression.  The value should be an
          integer between 0 and 100, with larger values indicating
          higher visual quality and lower compression.

     *Supported Formats*
     Extension              Format
     -------------------------------------------------------------------- 
     bmp                    Windows Bitmap
     gif                    Graphics Interchange Format
     jpg and jpeg           Joint Photographic Experts Group
     pbm         ...

     USE help imwrite FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="ind2gray" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  ind2gray (X, MAP)
     Convert an Octave indexed image to a gray scale intensity image.
     If MAP is omitted, the current colormap is used to determine the
     intensities.

     See also: gray2ind, rgb2ntsc, image, colormap


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="ind2rgb" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: RGB = ind2rgb (X, MAP)
 -- Function File: [R, R, R] = ind2rgb (X, MAP)
     Convert an indexed image to red, green, and blue color components.
     If the colormap doesn't contain enough colors, pad it with the
     last color in the map.  If MAP is omitted, the current colormap is
     used for the conversion.

     See also: rgb2ind, image, imshow, ind2gray, gray2ind


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="ind2sub" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [S1, S2, ..., SN] = ind2sub (DIMS, IND)
     Convert a linear index to subscripts.

     The following example shows how to convert the linear index '8' in
     a 3-by-3 matrix into a subscript.  The matrix is linearly indexed
     moving from one column to next, filling up all rows in each column.

          [r, c] = ind2sub ([3, 3], 8)
          => r =  2
            c =  3

     See also: sub2ind


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="index" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  index (S, T)
 -- Function File:  index (S, T, DIRECTION)
     Return the position of the first occurrence of the string T in the
     string S, or 0 if no occurrence is found.  S may also be a string
     array or cell array of strings.

     For example:

          index ('Teststring', 't')
             => 4

     If DIRECTION is &quot;first&quot;, return the first element found.  If
     DIRECTION is &quot;last&quot;, return the last element found.

     See also: find, rindex


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="Inf" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  Inf
 -- Built-in Function:  Inf (N)
 -- Built-in Function:  Inf (N, M)
 -- Built-in Function:  Inf (N, M, K, ...)
 -- Built-in Function:  Inf (..., CLASS)
     Return a scalar, matrix or N-dimensional array whose elements are
     all equal to the IEEE representation for positive infinity.

     Infinity is produced when results are too large to be represented
     using the the IEEE floating point format for numbers.  Two common
     examples which produce infinity are division by zero and overflow.

          [1/0 e^800]
          =>
          Inf   Inf

     When called with no arguments, return a scalar with the value
     'Inf'.  When called with a single argument, return a square matrix
     with the dimension specified.  When called with more than one
     scalar argument the first two arguments are taken as the number of
     rows and columns and any further arguments specify additional
     matrix dimensions.  The optional argument CLASS specifies the
 ...

     USE help Inf FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="inferiorto" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  inferiorto (CLASS_NAME, ...)
     When called from a class constructor, mark the object currently
     constructed as having a lower precedence than CLASS_NAME.  More
     that one such class can be specified in a single call.  This
     function may only be called from a class constructor.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="info" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  info ()
     Display contact information for the GNU Octave community.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="info_file" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: VAL = info_file ()
 -- Built-in Function: OLD_VAL = info_file (NEW_VAL)
 -- Built-in Function:  info_file (NEW_VAL, 'local')
     Query or set the internal variable that specifies the name of the
     Octave info file.  The default value is
     'OCTAVE-HOME/info/octave.info', in which OCTAVE-HOME is the root
     directory of the Octave installation.  The default value may be
     overridden by the environment variable 'OCTAVE_INFO_FILE', or the
     command line argument '--info-file NAME'.

     When called from inside a function with the 'local' option, the
     variable is changed locally for the function and any subroutines
     it calls.  The original variable value is restored when exiting
     the function.

     See also: info_program, doc, help, makeinfo_program


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="info_program" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: VAL = info_program ()
 -- Built-in Function: OLD_VAL = info_program (NEW_VAL)
 -- Built-in Function:  info_program (NEW_VAL, 'local')
     Query or set the internal variable that specifies the name of the
     info program to run.  The default value is
     'OCTAVE-HOME/libexec/octave/VERSION/exec/ARCH/info' in which
     OCTAVE-HOME is the root directory of the Octave installation,
     VERSION is the Octave version number, and ARCH is the system type
     (for example, 'i686-pc-linux-gnu').  The default value may be
     overridden by the environment variable 'OCTAVE_INFO_PROGRAM', or
     the command line argument '--info-program NAME'.

     When called from inside a function with the 'local' option, the
     variable is changed locally for the function and any subroutines
     it calls.  The original variable value is restored when exiting
     the function.

     See also: info_file, doc, help, makeinfo_program


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="initial" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [Y, T, X] = initial (SYS, X0)
 -- Function File: [Y, T, X] = initial (SYS, X0, T)
 -- Function File: [Y, T, X] = initial (SYS, X0, TFINAL)
 -- Function File: [Y, T, X] = initial (SYS, X0, TFINAL, DT)
     Initial condition response of state-space model.  If no output
     arguments are given, the response is printed on the screen.

     *Inputs*
    SYS
          State-space model.

    X0
          Vector of initial conditions for each state.

    T
          Optional time vector.  Should be evenly spaced.  If not
          specified, it is calculated by the poles of the system to
          reflect adequately the response transients.

    TFINAL
          Optional simulation horizon.  If not specified, it is
          calculated by the poles of the system to reflect adequately
          the response transients.

    DT
          Optional sampling time.  Be sure to choose it small enough to
          capture transient phenomena.  If not specified, it is
          cal...

     USE help initial FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="inline" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  inline (STR)
 -- Built-in Function:  inline (STR, ARG1, ...)
 -- Built-in Function:  inline (STR, N)
     Create an inline function from the character string STR.  If
     called with a single argument, the arguments of the generated
     function are extracted from the function itself.  The generated
     function arguments will then be in alphabetical order.  It should
     be noted that i, and j are ignored as arguments due to the
     ambiguity between their use as a variable or their use as an
     inbuilt constant.  All arguments followed by a parenthesis are
     considered to be functions.

     If the second and subsequent arguments are character strings, they
     are the names of the arguments of the function.

     If the second argument is an integer N, the arguments are &quot;x&quot;,
     &quot;P1&quot;, ..., &quot;PN&quot;.

     See also: argnames, formula, vectorize


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="inpolygon" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [IN, ON] = inpolygon (X, Y, XV, YV)
     For a polygon defined by vertex points '(XV, YV)', determine if
     the points '(X, Y)' are inside or outside the polygon.  The
     variables X, Y, must have the same dimension.  The optional output
     ON gives the points that are on the polygon.


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="input" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  input (PROMPT)
 -- Built-in Function:  input (PROMPT, 's')
     Print a prompt and wait for user input.  For example,

          input ('Pick a number, any number! ')

     prints the prompt

          Pick a number, any number!

     and waits for the user to enter a value.  The string entered by
     the user is evaluated as an expression, so it may be a literal
     constant, a variable name, or any other valid expression.

     Currently, 'input' only returns one value, regardless of the number
     of values produced by the evaluation of the expression.

     If you are only interested in getting a literal string value, you
     can call 'input' with the character string &quot;s&quot; as the second
     argument.  This tells Octave to return the string entered by the
     user directly, without evaluating it first.

     Because there may be output waiting to be displayed by the pager,
     it is a good idea to always call 'fflush (stdout)' before calling
     'inp...

     USE help input FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="inputname" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  inputname (N)
     Return the name of the N-th argument to the calling function.  If
     the argument is not a simple variable name, return an empty string.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="int16" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  int16 (X)
     Convert X to 16-bit integer type.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="int2str" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  int2str (N)
     Convert an integer (or array of integers) to a string (or a
     character array).

          int2str (123)
               => '123'

          s = int2str ([1, 2, 3; 4, 5, 6])
               => s =
                  1  2  3
                  4  5  6

          whos s
               => s =
                Attr Name        Size                     Bytes  Class
                ==== ====        ====                     =====  =====
                     s           2x7                         14  char

     This function is not very flexible.  For better control over the
     results, use 'sprintf' (*note Formatted Output::).

     See also: sprintf, num2str, mat2str


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="int32" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  int32 (X)
     Convert X to 32-bit integer type.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="int64" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  int64 (X)
     Convert X to 64-bit integer type.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="int8" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  int8 (X)
     Convert X to 8-bit integer type.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="interp1" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: YI = interp1 (X, Y, XI)
 -- Function File: YI = interp1 (Y, XI)
 -- Function File: YI = interp1 (..., METHOD)
 -- Function File: YI = interp1 (..., EXTRAP)
 -- Function File: PP = interp1 (..., 'pp')
     One-dimensional interpolation.  Interpolate Y, defined at the
     points X, at the points XI.  The sample points X must be
     monotonic.  If not specified, X is taken to be the indices of Y.
     If Y is an array, treat the columns of Y separately.

     Method is one of:

    'nearest'
          Return the nearest neighbor.

    'linear'
          Linear interpolation from nearest neighbors

    'pchip'
          Piecewise cubic Hermite interpolating polynomial

    'cubic'
          Cubic interpolation (same as 'pchip')

    'spline'
          Cubic spline interpolation--smooth first and second
          derivatives throughout the curve

     Appending '*' to the start of the above method forces 'interp1' to
     assume that X is uniformly spaced, and only 'X (...

     USE help interp1 FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="interp1q" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: YI = interp1q (X, Y, XI)
     One-dimensional linear interpolation without error checking.
     Interpolates Y, defined at the points X, at the points XI.  The
     sample points X must be a strictly monotonically increasing column
     vector.  If Y is an array, treat the columns of Y separately.  If
     Y is a vector, it must be a column vector of the same length as X.

     Values of XI beyond the endpoints of the interpolation result in
     NA being returned.

     Note that the error checking is only a significant portion of the
     execution time of this 'interp1' if the size of the input arguments
     is relatively small.  Therefore, the benefit of using 'interp1q'
     is relatively small.

     See also: interp1


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="interp2" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: ZI = interp2 (X, Y, Z, XI, YI)
 -- Function File: ZI = interp2 (Z, XI, YI)
 -- Function File: ZI = interp2 (Z, N)
 -- Function File: ZI = interp2 (..., METHOD)
 -- Function File: ZI = interp2 (..., METHOD, EXTRAPVAL)
     Two-dimensional interpolation.  X, Y and Z describe a surface
     function.  If X and Y are vectors their length must correspondent
     to the size of Z.  X and Y must be monotonic.  If they are
     matrices they must have the 'meshgrid' format.

    'interp2 (X, Y, Z, XI, YI, ...)'
          Returns a matrix corresponding to the points described by the
          matrices XI, YI.

          If the last argument is a string, the interpolation method can
          be specified.  The method can be 'linear', 'nearest' or
          'cubic'.  If it is omitted 'linear' interpolation is assumed.

    'interp2 (Z, XI, YI)'
          Assumes 'X = 1:rows (Z)' and 'Y = 1:columns (Z)'

    'interp2 (Z, N)'
          Interleaves the matrix Z n-times.  If N is ...

     USE help interp2 FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="interp3" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: VI = interp3 (X, Y, Z, V, XI, YI, ZI)
 -- Function File: VI = interp3 (V, XI, YI, ZI)
 -- Function File: VI = interp3 (V, M)
 -- Function File: VI = interp3 (V)
 -- Function File: VI = interp3 (..., METHOD)
 -- Function File: VI = interp3 (..., METHOD, EXTRAPVAL)
     Perform 3-dimensional interpolation.  Each element of the
     3-dimensional array V represents a value at a location given by
     the parameters X, Y, and Z.  The parameters X, X, and Z are either
     3-dimensional arrays of the same size as the array V in the
     'meshgrid' format or vectors.  The parameters XI, etc.  respect a
     similar format to X, etc., and they represent the points at which
     the array VI is interpolated.

     If X, Y, Z are omitted, they are assumed to be 'x = 1 : size (V,
     2)', 'y = 1 : size (V, 1)' and 'z = 1 : size (V, 3)'.  If M is
     specified, then the interpolation adds a point half way between
     each of the interpolation points.  This process is perform...

     USE help interp3 FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="interpft" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  interpft (X, N)
 -- Function File:  interpft (X, N, DIM)
     Fourier interpolation.  If X is a vector, then X is resampled with
     N points.  The data in X is assumed to be equispaced.  If X is an
     array, then operate along each column of the array separately.  If
     DIM is specified, then interpolate along the dimension DIM.

     'interpft' assumes that the interpolated function is periodic, and
     so assumptions are made about the endpoints of the interpolation.

     See also: interp1


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="interpn" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: VI = interpn (X1, X2, ..., V, Y1, Y2, ...)
 -- Function File: VI = interpn (V, Y1, Y2, ...)
 -- Function File: VI = interpn (V, M)
 -- Function File: VI = interpn (V)
 -- Function File: VI = interpn (..., METHOD)
 -- Function File: VI = interpn (..., METHOD, EXTRAPVAL)
     Perform N-dimensional interpolation, where N is at least two.
     Each element of the N-dimensional array V represents a value at a
     location given by the parameters X1, X2, ..., XN.  The parameters
     X1, X2, ..., XN are either N-dimensional arrays of the same size
     as the array V in the 'ndgrid' format or vectors.  The parameters
     Y1, etc. respect a similar format to X1, etc., and they represent
     the points at which the array VI is interpolated.

     If X1, ..., XN are omitted, they are assumed to be 'x1 = 1 : size
     (V, 1)', etc.  If M is specified, then the interpolation adds a
     point half way between each of the interpolation points.  This
     process is performed ...

     USE help interpn FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="intersect" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  intersect (A, B)
 -- Function File: [C, IA, IB] = intersect (A, B)
     Return the elements in both A and B, sorted in ascending order.
     If A and B are both column vectors return a column vector,
     otherwise return a row vector.  A, B may be cell arrays of
     string(s).

     Return index vectors IA and IB such that 'a(ia)==c' and 'b(ib)==c'.


   See also: unique, union, setxor, setdiff, ismember

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="intmax" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  intmax (TYPE)
     Return the largest integer that can be represented in an integer
     type.  The variable TYPE can be

    'int8'
          signed 8-bit integer.

    'int16'
          signed 16-bit integer.

    'int32'
          signed 32-bit integer.

    'int64'
          signed 64-bit integer.

    'uint8'
          unsigned 8-bit integer.

    'uint16'
          unsigned 16-bit integer.

    'uint32'
          unsigned 32-bit integer.

    'uint64'
          unsigned 64-bit integer.

     The default for TYPE is 'uint32'.

     See also: intmin, bitmax


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="intmin" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  intmin (TYPE)
     Return the smallest integer that can be represented in an integer
     type.  The variable TYPE can be

    'int8'
          signed 8-bit integer.

    'int16'
          signed 16-bit integer.

    'int32'
          signed 32-bit integer.

    'int64'
          signed 64-bit integer.

    'uint8'
          unsigned 8-bit integer.

    'uint16'
          unsigned 16-bit integer.

    'uint32'
          unsigned 32-bit integer.

    'uint64'
          unsigned 64-bit integer.

     The default for TYPE is 'uint32'.

     See also: intmax, bitmax


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="inv" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: X = inv (A)
 -- Loadable Function: [X, RCOND] = inv (A)
     Compute the inverse of the square matrix A.  Return an estimate of
     the reciprocal condition number if requested, otherwise warn of an
     ill-conditioned matrix if the reciprocal condition number is small.

     In general it is best to avoid calculating the inverse of a matrix
     directly.  For example, it is both faster and more accurate to
     solve systems of equations (A*x = b) with 'Y = A \ b', rather than
     'Y = inv (A) * b'.

     If called with a sparse matrix, then in general X will be a full
     matrix requiring significantly more storage.  Avoid forming the
     inverse of a sparse matrix if possible.

     See also: ldivide, rdivide


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="invhilb" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  invhilb (N)
     Return the inverse of the Hilbert matrix of order N.  This can be
     computed exactly using


                      (i+j)         /n+i-1\  /n+j-1\   /i+j-2\ 2
           A(i,j) = -1      (i+j-1)(       )(       ) (       )
                                    \ n-j /  \ n-i /   \ i-2 /

                  = p(i) p(j) / (i+j-1)

     where

                       k  /k+n-1\   /n\
              p(k) = -1  (       ) (   )
                          \ k-1 /   \k/

     The validity of this formula can easily be checked by expanding
     the binomial coefficients in both formulas as factorials.  It can
     be derived more directly via the theory of Cauchy matrices.  See
     J. W. Demmel, 'Applied Numerical Linear Algebra', p. 92.

     Compare this with the numerical calculation of 'inverse (hilb
     (n))', which suffers from the ill-conditioning of the Hilbert
     matrix, and the finite precision of your computer's floating point
     arithmetic.

  ...

     USE help invhilb FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="ipermute" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  ipermute (A, IPERM)
     The inverse of the 'permute' function.  The expression

          ipermute (permute (A, perm), perm)

     returns the original array A.

     See also: permute


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="iqr" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  iqr (X)
 -- Function File:  iqr (X, DIM)
     Return the interquartile range, i.e., the difference between the
     upper and lower quartile of the input data.  If X is a matrix, do
     the above for first non-singleton dimension of X.

     If the optional argument DIM is given, operate along this
     dimension.

     As a measure of dispersion, the interquartile range is less
     affected by outliers than either 'range' or 'std'.

     See also: range, std


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="is_absolute_filename" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  is_absolute_filename (FILE)
     Return true if FILE is an absolute filename.

     See also: is_rooted_relative_filename, make_absolute_filename,
     isdir


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="is_dq_string" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  is_dq_string (X)
     Return true if X is a double-quoted character string.

     See also: is_sq_string, ischar


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="is_function_handle" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  is_function_handle (X)
     Return true if X is a function handle.

     See also: isa, typeinfo, class


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="is_leap_year" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  is_leap_year ()
 -- Function File:  is_leap_year (YEAR)
     Return true if YEAR is a leap year and false otherwise.  If no
     year is specified, 'is_leap_year' uses the current year.  For
     example:

          is_leap_year (2000)
             => 1

     See also: weekday, eomday, calendar


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="is_rooted_relative_filename" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  is_rooted_relative_filename (FILE)
     Return true if FILE is a rooted-relative filename.

     See also: is_absolute_filename, make_absolute_filename, isdir


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="is_sq_string" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  is_sq_string (X)
     Return true if X is a single-quoted character string.

     See also: is_dq_string, ischar


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="is_valid_file_id" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  is_valid_file_id (FID)
     Return true if FID refers to an open file.

     See also: fopen


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="isa" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  isa (OBJ, CLASS)
     Return true if OBJ is an object from the class CLASS.

     See also: class, typeinfo


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="isalnum" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  isalnum (S)
     Return a logical array which is true where the elements of S are
     letters or digits and false where they are not.  This is
     equivalent to ('isalpha (S) | isdigit (S)').

     See also: isalpha, isdigit, ispunct, isspace, iscntrl


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="isalpha" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  isalpha (S)
     Return a logical array which is true where the elements of S are
     letters and false where they are not.  This is equivalent to
     ('islower (S) | isupper (S)').

     See also: isdigit, ispunct, isspace, iscntrl, isalnum, islower,
     isupper


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="isappdata" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: V = isappdata (H, NAME)
     Return true if the named application data, NAME, exists for the
     object with handle H.

     See also: getappdata, setappdata, rmappdata


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="isargout" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  isargout (K)
     Within a function, return a logical value indicating whether the
     argument K will be assigned on output to a variable.  If the
     result is false, the argument has been ignored during the function
     call through the use of the tilde (~) special output argument.
     Functions can use 'isargout' to avoid performing unnecessary
     calculations for outputs which are unwanted.

     If K is outside the range '1:max(nargout)', the function returns
     false.  K can also be an array, in which case the function works
     element-by-element and a logical array is returned.  At the top
     level, 'isargout' returns an error.

     See also: nargout, nargin, varargin, varargout, nthargout


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="isascii" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  isascii (S)
     Return a logical array which is true where the elements of S are
     ASCII characters (in the range 0 to 127 decimal) and false where
     they are not.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="iscell" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  iscell (X)
     Return true if X is a cell array object.

     See also: ismatrix, isstruct, iscellstr, isa


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="iscellstr" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  iscellstr (CELL)
     Return true if every element of the cell array CELL is a character
     string.

     See also: ischar


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="ischar" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  ischar (X)
     Return true if X is a character array.

     See also: isfloat, isinteger, islogical, isnumeric, iscellstr, isa


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="iscntrl" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  iscntrl (S)
     Return a logical array which is true where the elements of S are
     control characters and false where they are not.

     See also: ispunct, isspace, isalpha, isdigit


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="iscolumn" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  iscolumn (X)
     Return true if X is a column vector.

     See also: isrow, isscalar, isvector, ismatrix


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="iscomplex" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  iscomplex (X)
     Return true if X is a complex-valued numeric object.

     See also: isreal, isnumeric


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="isctrb" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [BOOL, NCON] = isctrb (SYS)
 -- Function File: [BOOL, NCON] = isctrb (SYS, TOL)
 -- Function File: [BOOL, NCON] = isctrb (A, B)
 -- Function File: [BOOL, NCON] = isctrb (A, B, E)
 -- Function File: [BOOL, NCON] = isctrb (A, B, [], TOL)
 -- Function File: [BOOL, NCON] = isctrb (A, B, E, TOL)
     Logical check for system controllability.  For numerical reasons,
     'isctrb (sys)' should be used instead of 'rank (ctrb (sys))'.

     *Inputs*
    SYS
          LTI model.  Descriptor state-space models are possible.

    A
          State transition matrix.

    B
          Input matrix.

    E
          Descriptor matrix.

    TOL
          Optional roundoff parameter.  Default value is 0.

     *Outputs*
    BOOL = 0
          System is not controllable.

    BOOL = 1
          System is controllable.

    NCON
          Number of controllable states.

     *Algorithm*
     Uses SLICOT AB01OD and TG01HD by courtesy of NICONET e.V.
     (http://www.slicot.org)

     Se...

     USE help isctrb FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="isdebugmode" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function:  isdebugmode ()
     Return true if in debugging mode, otherwise false.

     See also: dbwhere, dbstack, dbstatus


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="isdefinite" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  isdefinite (X)
 -- Function File:  isdefinite (X, TOL)
     Return 1 if X is symmetric positive definite within the tolerance
     specified by TOL or 0 if X is symmetric positive semidefinite.
     Otherwise, return -1.  If TOL is omitted, use a tolerance of '100
     * eps * norm (X, 'fro')'

     See also: issymmetric, ishermitian


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="isdeployed" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  isdeployed ()
     Return true if the current program has been compiled and is running
     separately from the Octave interpreter and false if it is running
     in the Octave interpreter.  Currently, this function always returns
     false in Octave.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="isdetectable" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: BOOL = isdetectable (SYS)
 -- Function File: BOOL = isdetectable (SYS, TOL)
 -- Function File: BOOL = isdetectable (A, C)
 -- Function File: BOOL = isdetectable (A, C, E)
 -- Function File: BOOL = isdetectable (A, C, [], TOL)
 -- Function File: BOOL = isdetectable (A, C, E, TOL)
 -- Function File: BOOL = isdetectable (A, C, [], [], DFLG)
 -- Function File: BOOL = isdetectable (A, C, E, [], DFLG)
 -- Function File: BOOL = isdetectable (A, C, [], TOL, DFLG)
 -- Function File: BOOL = isdetectable (A, C, E, TOL, DFLG)
     Logical test for system detectability.  All unstable modes must be
     observable or all unobservable states must be stable.

     *Inputs*
    SYS
          LTI system.

    A
          State transition matrix.

    C
          Measurement matrix.

    E
          Descriptor matrix.

    TOL
          Optional tolerance for stability.  Default value is 0.

    DFLG = 0
          Matrices (A, C) are part of a continuous-time system.
          Default ...

     USE help isdetectable FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="isdigit" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  isdigit (S)
     Return a logical array which is true where the elements of S are
     decimal digits (0-9) and false where they are not.

     See also: isxdigit, isalpha, isletter, ispunct, isspace, iscntrl


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="isdir" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  isdir (F)
     Return true if F is a directory.

     See also: is_absolute_filename, is_rooted_relative_filename


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="isempty" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  isempty (A)
     Return true if A is an empty matrix (any one of its dimensions is
     zero).  Otherwise, return false.

     See also: isnull


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="isequal" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  isequal (X1, X2, ...)
     Return true if all of X1, X2, ... are equal.

     See also: isequalwithequalnans


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="isequalwithequalnans" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  isequalwithequalnans (X1, X2, ...)
     Assuming NaN == NaN, return true if all of X1, X2, ...  are equal.

     See also: isequal


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="isfield" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  isfield (X, NAME)
     Return true if the X is a structure and it includes an element
     named NAME.  If NAME is a cell array of strings then a logical
     array of equal dimension is returned.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="isfigure" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  isfigure (H)
     Return true if H is a graphics handle that contains a figure
     object.

     See also: ishandle


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="isfinite" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  isfinite (X)
 -- Mapping Function:  finite (X)
     Return a logical array which is true where the elements of X are
     finite values and false where they are not.  For example:

          finite ([13, Inf, NA, NaN])
              => [ 1, 0, 0, 0 ]

     See also: isinf, isnan, isna


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="isfloat" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  isfloat (X)
     Return true if X is a floating-point numeric object.  Objects of
     class double or single are floating-point objects.

     See also: isinteger, ischar, islogical, isnumeric, isa


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="isglobal" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  isglobal (NAME)
     Return true if NAME is a globally visible variable.  For example:

          global x
          isglobal ('x')
              => 1

     See also: isvarname, exist


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="isgraph" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  isgraph (S)
     Return a logical array which is true where the elements of S are
     printable characters (but not the space character) and false where
     they are not.

     See also: isprint


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="ishandle" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  ishandle (H)
     Return true if H is a graphics handle and false otherwise.  H may
     also be a matrix of handles in which case a logical array is
     returned that is true where the elements of H are graphics handles
     and false where they are not.

     See also: isfigure


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="ishermitian" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  ishermitian (X)
 -- Function File:  ishermitian (X, TOL)
     Return true if X is Hermitian within the tolerance specified by
     TOL.  The default tolerance is zero (uses faster code).  Matrix X
     is considered symmetric if 'norm (X - X', Inf) / norm (X, Inf) &lt;
     TOL'.

     See also: issymmetric, isdefinite


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="ishghandle" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  ishghandle (H)
     Return true if H is a graphics handle and false otherwise.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="ishold" func="yes">
            <Overload retVal="">
                <Param name="
 -- Command:  ishold
 -- Function File:  ishold (H)
     Return true if the next plot will be added to the current plot, or
     false if the plot device will be cleared before drawing the next
     plot.

     Optionally, operate on the graphics handle H rather than the
     current plot.

     See also: hold


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="isieee" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  isieee ()
     Return true if your computer _claims_ to conform to the IEEE
     standard for floating point calculations.  No actual tests are
     performed.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="isindex" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  isindex (IND)
 -- Built-in Function:  isindex (IND, N)
     Return true if IND is a valid index.  Valid indices are either
     positive integers (although possibly of real data type), or logical
     arrays.  If present, N specifies the maximum extent of the
     dimension to be indexed.  When possible the internal result is
     cached so that subsequent indexing using IND will not perform the
     check again.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="isinf" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  isinf (X)
     Return a logical array which is true where the elements of X are
     are infinite and false where they are not.  For example:

          isinf ([13, Inf, NA, NaN])
              => [ 0, 1, 0, 0 ]

     See also: isfinite, isnan, isna


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="isinteger" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  isinteger (X)
     Return true if X is an integer object (int8, uint8, int16, etc.).
     Note that 'isinteger (14)' is false because numeric constants in
     Octave are double precision floating point values.

     See also: isfloat, ischar, islogical, isnumeric, isa


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="iskeyword" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  iskeyword ()
 -- Built-in Function:  iskeyword (NAME)
     Return true if NAME is an Octave keyword.  If NAME is omitted,
     return a list of keywords.

     See also: isvarname, exist


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="isletter" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  isletter (S)
     Return a logical array which is true where the elements of S are
     letters and false where they are not.  This is an alias for the
     'isalpha' function.

     See also: isalpha, isdigit, ispunct, isspace, iscntrl, isalnum


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="islogical" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  islogical (X)
 -- Built-in Function:  isbool (X)
     Return true if X is a logical object.

     See also: isfloat, isinteger, ischar, isnumeric, isa


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="islower" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  islower (S)
     Return a logical array which is true where the elements of S are
     lowercase letters and false where they are not.

     See also: isupper, isalpha, isletter, isalnum


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="ismac" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  ismac ()
     Return true if Octave is running on a Mac OS X system and false
     otherwise.

     See also: isunix, ispc


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="ismatrix" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  ismatrix (A)
     Return true if A is a numeric, logical, or character matrix.
     Scalars (1x1 matrices) and vectors (1xN or Nx1 matrices) are
     subsets of the more general N-dimensional matrix and 'ismatrix'
     will return true for these objects as well.

     See also: isscalar, isvector, iscell, isstruct, issparse


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="ismember" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: TF = ismember (A, S)
 -- Function File: [TF, S_IDX] = ismember (A, S)
 -- Function File: [TF, S_IDX] = ismember (A, S, 'rows')
     Return a logical matrix TF with the same shape as A which is true
     (1) if 'A(i,j)' is in S and false (0) if it is not.  If a second
     output argument is requested, the index into S of each of the
     matching elements is also returned.

          a = [3, 10, 1];
          s = [0:9];
          [tf, s_idx] = ismember (a, s)
               => tf = [1, 0, 1]
               => s_idx = [4, 0, 2]

     The inputs, A and S, may also be cell arrays.

          a = {'abc'};
          s = {'abc', 'def'};
          [tf, s_idx] = ismember (a, s)
               => tf = [1, 0]
               => s_idx = [1, 0]

     With the optional third argument &quot;rows&quot;, and matrices A and S
     with the same number of columns, compare rows in A with the rows
     in S.

          a = [1:3; 5:7; 4:6];
          s = [0:2; 1:3; 2:4; 3:5; 4:6];
          [tf, ...

     USE help ismember FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="ismethod" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  ismethod (X, METHOD)
     Return true if X is a class object and the string METHOD is a
     method of this class.

     See also: isobject


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="isna" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  isna (X)
     Return a logical array which is true where the elements of X are
     NA (missing) values and false where they are not.  For example:

          isna ([13, Inf, NA, NaN])
              => [ 0, 0, 1, 0 ]

     See also: isnan, isinf, isfinite


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="isnan" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  isnan (X)
     Return a logical array which is true where the elements of X are
     NaN values and false where they are not.  NA values are also
     considered NaN values.  For example:

          isnan ([13, Inf, NA, NaN])
              => [ 0, 0, 1, 1 ]

     See also: isna, isinf, isfinite


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="isnull" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  isnull (X)
     Return true if X is a special null matrix, string, or single quoted
     string.  Indexed assignment with such a value on the right-hand
     side should delete array elements.  This function should be used
     when overloading indexed assignment for user-defined classes
     instead of 'isempty', to distinguish the cases:
    'A(I) = []'
          This should delete elements if 'I' is nonempty.

    'X = []; A(I) = X'
          This should give an error if 'I' is nonempty.

     See also: isempty, isindex


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="isnumeric" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  isnumeric (X)
     Return true if X is a numeric object, i.e., an integer, real, or
     complex array.  Logical and character arrays are not considered to
     be numeric.

     See also: isinteger, isfloat, isreal, iscomplex, islogical,
     ischar, iscell, isstruct


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="isobject" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  isobject (X)
     Return true if X is a class object.

     See also: class, typeinfo, isa, ismethod


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="isobsv" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [BOOL, NOBS] = isobsv (SYS)
 -- Function File: [BOOL, NOBS] = isobsv (SYS, TOL)
 -- Function File: [BOOL, NOBS] = isobsv (A, C)
 -- Function File: [BOOL, NOBS] = isobsv (A, C, E)
 -- Function File: [BOOL, NOBS] = isobsv (A, C, [], TOL)
 -- Function File: [BOOL, NOBS] = isobsv (A, C, E, TOL)
     Logical check for system observability.  For numerical reasons,
     'isobsv (sys)' should be used instead of 'rank (obsv (sys))'.

     *Inputs*
    SYS
          LTI model.  Descriptor state-space models are possible.

    A
          State transition matrix.

    C
          Measurement matrix.

    E
          Descriptor matrix.

    TOL
          Optional roundoff parameter.  Default value is 0.

     *Outputs*
    BOOL = 0
          System is not observable.

    BOOL = 1
          System is observable.

    NOBS
          Number of observable states.

     *Algorithm*
     Uses SLICOT AB01OD and TG01HD by courtesy of NICONET e.V.
     (http://www.slicot.org)

     See ...

     USE help isobsv FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="isocolors" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [CD] = isocolors (C, V)
 -- Function File: [CD] = isocolors (X, Y, Z, C, V)
 -- Function File: [CD] = isocolors (X, Y, Z, R, G, B, V)
 -- Function File: [CD] = isocolors (R, G, B, V)
 -- Function File: [CD] = isocolors (..., P)
 -- Function File:  isocolors (...)
     If called with one output argument and the first input argument C
     is a three-dimensional array that contains color values and the
     second input argument V keeps the vertices of a geometry then
     return a matrix CD with color data information for the geometry at
     computed points '[x, y, z] = meshgrid (1:l, 1:m, 1:n)'.  The
     output argument CD can be taken to manually set FaceVertexCData of
     a patch.

     If called with further input arguments X, Y and Z which are
     three-dimensional arrays of the same size than C then the color
     data is taken at those given points.  Instead of the color data C
     this function can also be called with RGB values R, G, B.  If
     input ar...

     USE help isocolors FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="isonormals" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [N] = isonormals (VAL, V)
 -- Function File: [N] = isonormals (VAL, P)
 -- Function File: [N] = isonormals (X, Y, Z, VAL, V)
 -- Function File: [N] = isonormals (X, Y, Z, VAL, P)
 -- Function File: [N] = isonormals (..., 'negate')
 -- Function File:  isonormals (..., P)
     If called with one output argument and the first input argument
     VAL is a three-dimensional array that contains the data for an
     isosurface geometry and the second input argument V keeps the
     vertices of an isosurface then return the normals N in form of a
     matrix with the same size than V at computed points '[x, y, z] =
     meshgrid (1:l, 1:m, 1:n)'.  The output argument N can be taken to
     manually set VERTEXNORMALS of a patch.

     If called with further input arguments X, Y and Z which are
     three-dimensional arrays with the same size than VAL then the
     volume data is taken at those given points.  Instead of the
     vertices data V a patch handle P can be passed t...

     USE help isonormals FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="isosurface" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [FV] = isosurface (VAL, ISO)
 -- Function File: [FV] = isosurface (X, Y, Z, VAL, ISO)
 -- Function File: [FV] = isosurface (..., 'noshare', 'verbose')
 -- Function File: [FVC] = isosurface (..., COL)
 -- Function File: [F, V] = isosurface (X, Y, Z, VAL, ISO)
 -- Function File: [F, V, C] = isosurface (X, Y, Z, VAL, ISO, COL)
 -- Function File:  isosurface (X, Y, Z, VAL, ISO, COL, OPT)
     If called with one output argument and the first input argument
     VAL is a three-dimensional array that contains the data of an
     isosurface geometry and the second input argument ISO keeps the
     isovalue as a scalar value then return a structure array FV that
     contains the fields FACES and VERTICES at computed points '[x, y,
     z] = meshgrid (1:l, 1:m, 1:n)'.  The output argument FV can
     directly be taken as an input argument for the 'patch' function.

     If called with further input arguments X, Y and Z which are
     three-dimensional arrays with the same siz...

     USE help isosurface FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="ispc" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  ispc ()
     Return true if Octave is running on a Windows system and false
     otherwise.

     See also: isunix, ismac


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="ispref" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  ispref (GROUP, PREF)
     Return true if the named preference PREF exists in the preference
     group GROUP.

     The named preference group must be a character string.

     The preference PREF may be a character string or a cell array of
     character strings.

     If PREF is not specified, return true if the preference group
     GROUP exists.

     See also: getpref, addpref, setpref, rmpref


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="isprime" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  isprime (X)
     Return a logical array which is true where the elements of X are
     prime numbers and false where they are not.

     If the maximum value in X is very large, then you should be using
     special purpose factorization code.

          isprime (1:6)
              => [0, 1, 1, 0, 1, 0]

     See also: primes, factor, gcd, lcm


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="isprint" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  isprint (S)
     Return a logical array which is true where the elements of S are
     printable characters (including the space character) and false
     where they are not.

     See also: isgraph


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="isprop" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: RES = isprop (H, PROP)
     Return true if PROP is a property of the object with handle H.

     See also: get, set


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="ispunct" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  ispunct (S)
     Return a logical array which is true where the elements of S are
     punctuation characters and false where they are not.

     See also: isalpha, isdigit, isspace, iscntrl


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="isreal" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  isreal (X)
     Return true if X is a non-complex matrix or scalar.  For
     compatibility with MATLAB, this includes logical and character
     matrices.

     See also: iscomplex, isnumeric


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="isrow" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  isrow (X)
     Return true if X is a row vector.

     See also: iscolumn, isscalar, isvector, ismatrix


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="isscalar" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  isscalar (X)
     Return true if X is a scalar.

     See also: isvector, ismatrix


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="issorted" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  issorted (A)
 -- Built-in Function:  issorted (A, MODE)
 -- Built-in Function:  issorted (A, 'rows', MODE)
     Return true if the array is sorted according to MODE, which may be
     either 'ascending', 'descending', or 'either'.  By default, MODE
     is 'ascending'.  NaNs are treated in the same manner as 'sort'.

     If the optional argument 'rows' is supplied, check whether the
     array is sorted by rows as output by the function 'sortrows' (with
     no options).

     This function does not support sparse matrices.

     See also: sort, sortrows


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="isspace" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  isspace (S)
     Return a logical array which is true where the elements of S are
     whitespace characters (space, formfeed, newline, carriage return,
     tab, and vertical tab) and false where they are not.

     See also: iscntrl, ispunct, isalpha, isdigit


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="issparse" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function:  issparse (X)
     Return true if X is a sparse matrix.

     See also: ismatrix


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="issquare" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  issquare (X)
     Return true if X is a square matrix.

     See also: isscalar, isvector, ismatrix, size


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="isstabilizable" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: BOOL = isstabilizable (SYS)
 -- Function File: BOOL = isstabilizable (SYS, TOL)
 -- Function File: BOOL = isstabilizable (A, B)
 -- Function File: BOOL = isstabilizable (A, B, E)
 -- Function File: BOOL = isstabilizable (A, B, [], TOL)
 -- Function File: BOOL = isstabilizable (A, B, E, TOL)
 -- Function File: BOOL = isstabilizable (A, B, [], [], DFLG)
 -- Function File: BOOL = isstabilizable (A, B, E, [], DFLG)
 -- Function File: BOOL = isstabilizable (A, B, [], TOL, DFLG)
 -- Function File: BOOL = isstabilizable (A, B, E, TOL, DFLG)
     Logical check for system stabilizability.  All unstable modes must
     be controllable or all uncontrollable states must be stable.

     *Inputs*
    SYS
          LTI system.

    A
          State transition matrix.

    B
          Input matrix.

    E
          Descriptor matrix.

    TOL
          Optional tolerance for stability.  Default value is 0.

    DFLG = 0
          Matrices (A, B) are part of a continuous-time syste...

     USE help isstabilizable FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="isstrprop" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  isstrprop (STR, PROP)
     Test character string properties.  For example:

          isstrprop ('abc123', 'alpha')
          => [1, 1, 1, 0, 0, 0]

     If STR is a cell array, 'isstrpop' is applied recursively to each
     element of the cell array.

     Numeric arrays are converted to character strings.

     The second argument PROP must be one of

    'alpha'
          True for characters that are alphabetic (letters).

    'alnum'
    'alphanum'
          True for characters that are alphabetic or digits.

    'lower'
          True for lowercase letters.

    'upper'
          True for uppercase letters.

    'digit'
          True for decimal digits (0-9).

    'xdigit'
          True for hexadecimal digits (a-fA-F0-9).

    'space'
    'wspace'
          True for whitespace characters (space, formfeed, newline,
          carriage return, tab, vertical tab).

    'punct'
          True for punctuation characters (printing characters except
          space o...

     USE help isstrprop FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="isstruct" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  isstruct (X)
     Return true if X is a structure or a structure array.

     See also: ismatrix, iscell, isa


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="issymmetric" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  issymmetric (X)
 -- Function File:  issymmetric (X, TOL)
     Return true if X is a symmetric matrix within the tolerance
     specified by TOL.  The default tolerance is zero (uses faster
     code).  Matrix X is considered symmetric if 'norm (X - X.', Inf) /
     norm (X, Inf) &lt; TOL'.

     See also: ishermitian, isdefinite


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="isunix" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  isunix ()
     Return true if Octave is running on a Unix-like system and false
     otherwise.

     See also: ismac, ispc


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="isupper" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  isupper (S)
     Return a logical array which is true where the elements of S are
     uppercase letters and false where they are not.

     See also: islower, isalpha, isletter, isalnum


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="isvarname" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  isvarname (NAME)
     Return true if NAME is a valid variable name.

     See also: iskeyword, exist, who


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="isvector" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  isvector (X)
     Return true if X is a vector.  A vector is a 2-D array where one
     of the dimensions is equal to 1.  As a consequence a 1x1 array, or
     scalar, is also a vector.

     See also: isscalar, ismatrix, size, rows, columns, length


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="isxdigit" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  isxdigit (S)
     Return a logical array which is true where the elements of S are
     hexadecimal digits (0-9 and a-fA-F).

     See also: isdigit


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="jet" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: MAP = jet ()
 -- Function File: MAP = jet (N)
     Create color colormap.  This colormap ranges from dark blue
     through blue, cyan, green, yellow, red, to dark red.  The argument
     N must be a scalar.  If unspecified, the length of the current
     colormap, or 64, is used.

     See also: colormap


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="kalman" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [EST, G, X] = kalman (SYS, Q, R)
 -- Function File: [EST, G, X] = kalman (SYS, Q, R, S)
 -- Function File: [EST, G, X] = kalman (SYS, Q, R, [], SENSORS, KNOWN)
 -- Function File: [EST, G, X] = kalman (SYS, Q, R, S, SENSORS, KNOWN)
     Design Kalman estimator for LTI systems.

     *Inputs*
    SYS
          Nominal plant model.

    Q
          Covariance of white process noise.

    R
          Covariance of white measurement noise.

    S
          Optional cross term covariance.  Default value is 0.

    SENSORS
          Indices of measured output signals y from SYS.  If omitted,
          all outputs are measured.

    KNOWN
          Indices of known input signals u (deterministic) to SYS.  All
          other inputs to SYS are assumed stochastic.  If argument
          KNOWN is omitted, no inputs u are known.

     *Outputs*
    EST
          State-space model of the Kalman estimator.

    G
          Estimator gain.

    X
          Solution of the Riccati e...

     USE help kalman FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="kbhit" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  kbhit ()
     Read a single keystroke from the keyboard.  If called with one
     argument, don't wait for a keypress.  For example,

          x = kbhit ();

     will set X to the next character typed at the keyboard as soon as
     it is typed.

          x = kbhit (1);

     identical to the above example, but don't wait for a keypress,
     returning the empty string if no key is available.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="kendall" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  kendall (X)
 -- Function File:  kendall (X, Y)
     Compute Kendall's TAU.

     For two data vectors X, Y of common length N, Kendall's TAU is the
     correlation of the signs of all rank differences of X and Y; i.e.,
     if both X and Y have distinct entries, then

                   1
          tau = -------   SUM sign (q(i) - q(j)) * sign (r(i) - r(j))
                n (n-1)   i,j

     in which the Q(I) and R(I) are the ranks of X and Y, respectively.

     If X and Y are drawn from independent distributions, Kendall's TAU
     is asymptotically normal with mean 0 and variance '(2 * (2N+5)) /
     (9 * N * (N-1))'.

     'kendall (X)' is equivalent to 'kendall (X, X)'.

     See also: ranks, spearman


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="keyboard" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  keyboard ()
 -- Built-in Function:  keyboard (PROMPT)
     This function is normally used for simple debugging.  When the
     'keyboard' function is executed, Octave prints a prompt and waits
     for user input.  The input strings are then evaluated and the
     results are printed.  This makes it possible to examine the values
     of variables within a function, and to assign new values if
     necessary.  To leave the prompt and return to normal execution
     type 'return' or 'dbcont'.  The 'keyboard' function does not
     return an exit status.

     If 'keyboard' is invoked without arguments, a default prompt of
     'debug> ' is used.

     See also: dbcont, dbquit


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="kill" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: [ERR, MSG] = kill (PID, SIG)
     Send signal SIG to process PID.

     If PID is positive, then signal SIG is sent to PID.

     If PID is 0, then signal SIG is sent to every process in the
     process group of the current process.

     If PID is -1, then signal SIG is sent to every process except
     process 1.

     If PID is less than -1, then signal SIG is sent to every process
     in the process group -PID.

     If SIG is 0, then no signal is sent, but error checking is still
     performed.

     Return 0 if successful, otherwise return -1.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="kolmogorov_smirnov_cdf" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  kolmogorov_smirnov_cdf (X, TOL)
     Return the cumulative distribution function (CDF) at X of the
     Kolmogorov-Smirnov distribution,

                   Inf
          Q(x) =   SUM    (-1)^k exp (-2 k^2 x^2)
                 k = -Inf

     for X &gt; 0.

     The optional parameter TOL specifies the precision up to which the
     series should be evaluated; the default is TOL = 'eps'.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="kolmogorov_smirnov_test" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [PVAL, KS] = kolmogorov_smirnov_test (X, DIST,
          PARAMS, ALT)
     Perform a Kolmogorov-Smirnov test of the null hypothesis that the
     sample X comes from the (continuous) distribution dist.  I.e., if
     F and G are the CDFs corresponding to the sample and dist,
     respectively, then the null is that F == G.

     The optional argument PARAMS contains a list of parameters of
     DIST.  For example, to test whether a sample X comes from a
     uniform distribution on [2,4], use

          kolmogorov_smirnov_test(x, 'unif', 2, 4)

     DIST can be any string for which a function DIST_CDF that
     calculates the CDF of distribution DIST exists.

     With the optional argument string ALT, the alternative of interest
     can be selected.  If ALT is &quot;!=&quot; or &quot;&lt;%gt;&quot;, the null is tested
     against the two-sided alternative F != G.  In this case, the test
     statistic KS follows a two-sided Kolmogorov-Smirnov distribution.
     If ALT is &quot;&gt;&quot;, the one...

     USE help kolmogorov_smirnov_test FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="kolmogorov_smirnov_test_2" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [PVAL, KS, D] = kolmogorov_smirnov_test_2 (X, Y, ALT)
     Perform a 2-sample Kolmogorov-Smirnov test of the null hypothesis
     that the samples X and Y come from the same (continuous)
     distribution.  I.e., if F and G are the CDFs corresponding to the
     X and Y samples, respectively, then the null is that F == G.

     With the optional argument string ALT, the alternative of interest
     can be selected.  If ALT is &quot;!=&quot; or &quot;&lt;%gt;&quot;, the null is tested
     against the two-sided alternative F != G.  In this case, the test
     statistic KS follows a two-sided Kolmogorov-Smirnov distribution.
     If ALT is &quot;&gt;&quot;, the one-sided alternative F &gt; G is considered.
     Similarly for &quot;&lt;&quot;, the one-sided alternative F &lt; G is
     considered.  In this case, the test statistic KS has a one-sided
     Kolmogorov-Smirnov distribution.  The default is the two-sided
     case.

     The p-value of the test is returned in PVAL.

     The third returned value, D, is the ...

     USE help kolmogorov_smirnov_test_2 FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="kron" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function:  kron (A, B)
 -- Loadable Function:  kron (A1, A2, ...)
     Form the Kronecker product of two or more matrices, defined block
     by block as

          x = [a(i, j) b]

     For example:

          kron (1:4, ones (3, 1))
               =>  1  2  3  4
                   1  2  3  4
                   1  2  3  4

     If there are more than two input arguments A1, A2, ..., AN the
     Kronecker product is computed as

          kron (kron (A1, A2), ..., AN)

     Since the Kronecker product is associative, this is well-defined.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="kruskal_wallis_test" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [PVAL, K, DF] = kruskal_wallis_test (X1, ...)
     Perform a Kruskal-Wallis one-factor 'analysis of variance'.

     Suppose a variable is observed for K &gt; 1 different groups, and let
     X1, ..., XK be the corresponding data vectors.

     Under the null hypothesis that the ranks in the pooled sample are
     not affected by the group memberships, the test statistic K is
     approximately chi-square with DF = K - 1 degrees of freedom.

     If the data contains ties (some value appears more than once) K is
     divided by

     1 - SUM_TIES / (N^3 - N)

     where SUM_TIES is the sum of T^2 - T over each group of ties where
     T is the number of ties in the group and N is the total number of
     values in the input data.  For more info on this adjustment see
     'Use of Ranks in One-Criterion Variance Analysis' in Journal of
     the American Statistical Association, Vol. 47, No. 260 (Dec 1952)
     by William H. Kruskal and W. Allen Wallis.

     The p-value ...

     USE help kruskal_wallis_test FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="krylov" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [U, H, NU] = krylov (A, V, K, EPS1, PFLG)
     Construct an orthogonal basis U of block Krylov subspace

          [v a*v a^2*v ... a^(k+1)*v]

     Using Householder reflections to guard against loss of
     orthogonality.

     If V is a vector, then H contains the Hessenberg matrix such that
     a*u == u*h+rk*ek', in which 'rk = a*u(:,k)-u*h(:,k)', and ek' is
     the vector '[0, 0, ..., 1]' of length 'k'.  Otherwise, H is
     meaningless.

     If V is a vector and K is greater than 'length(A)-1', then H
     contains the Hessenberg matrix such that 'a*u == u*h'.

     The value of NU is the dimension of the span of the Krylov
     subspace (based on EPS1).

     If B is a vector and K is greater than M-1, then H contains the
     Hessenberg decomposition of A.

     The optional parameter EPS1 is the threshold for zero.  The
     default value is 1e-12.

     If the optional parameter PFLG is nonzero, row pivoting is used to
     improve numerical behavior.  T...

     USE help krylov FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="kurtosis" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  kurtosis (X)
 -- Function File:  kurtosis (X, DIM)
     Compute the kurtosis of the elements of the vector X.

          kurtosis (x) = 1/N std(x)^(-4) sum ((x - mean(x)).^4) - 3

     If X is a matrix, return the kurtosis over the first non-singleton
     dimension of the matrix.  If the optional DIM argument is given,
     operate along this dimension.

     Note: The definition of kurtosis above yields a kurtosis of zero
     for the stdnormal distribution and is sometimes referred to as
     'excess kurtosis'.  To calculate kurtosis without the
     normalization factor of -3 use 'moment (X, 4, 'c') / std (X)^4'.

     See also: var, skewness, moment


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="laplace_cdf" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  laplace_cdf (X)
     For each element of X, compute the cumulative distribution
     function (CDF) at X of the Laplace distribution.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="laplace_inv" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  laplace_inv (X)
     For each element of X, compute the quantile (the inverse of the
     CDF) at X of the Laplace distribution.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="laplace_pdf" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  laplace_pdf (X)
     For each element of X, compute the probability density function
     (PDF) at X of the Laplace distribution.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="laplace_rnd" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  laplace_rnd (R)
 -- Function File:  laplace_rnd (R, C, ...)
 -- Function File:  laplace_rnd ([SZ])
     Return a matrix of random samples from the Laplace distribution.

     When called with a single size argument, return a square matrix
     with the dimension specified.  When called with more than one
     scalar argument the first two arguments are taken as the number of
     rows and columns and any further arguments specify additional
     matrix dimensions.  The size may also be specified with a vector
     of dimensions SZ.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="lasterr" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: [MSG, MSGID] = lasterr ()
 -- Built-in Function:  lasterr (MSG)
 -- Built-in Function:  lasterr (MSG, MSGID)
     Query or set the last error message.  When called without input
     arguments, return the last error message and message identifier.
     With one argument, set the last error message to MSG.  With two
     arguments, also set the last message identifier.

     See also: lasterror


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="lasterror" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: LASTERR = lasterror ()
 -- Built-in Function:  lasterror (ERR)
 -- Built-in Function:  lasterror ('reset')
     Query or set the last error message structure.  When called without
     arguments, return a structure containing the last error message
     and other information related to this error.  The elements of the
     structure are:

    'message'
          The text of the last error message

    'identifier'
          The message identifier of this error message

    'stack'
          A structure containing information on where the message
          occurred.  This may be an empty structure if the information
          cannot be obtained.  The fields of the structure are:

         'file'
               The name of the file where the error occurred

         'name'
               The name of function in which the error occurred

         'line'
               The line number at which the error occurred

         'column'
               An optional field wit...

     USE help lasterror FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="lastwarn" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: [MSG, MSGID] = lastwarn (MSG, MSGID)
     Without any arguments, return the last warning message.  With one
     argument, set the last warning message to MSG.  With two arguments,
     also set the last message identifier.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="lcm" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  lcm (X, Y)
 -- Mapping Function:  lcm (X, Y, ...)
     Compute the least common multiple of X and Y, or of the list of
     all arguments.  All elements must be the same size or scalar.

     See also: factor, gcd


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="ldivide" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  ldivide (X, Y)
     Return the element-by-element left division of X and Y.  This
     function and x .\ y are equivalent.

     See also: rdivide, mldivide


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="le" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  le (X, Y)
     This function is equivalent to 'x &lt;= y'.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="legend" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  legend (STR1, STR2, ...)
 -- Function File:  legend (MATSTR)
 -- Function File:  legend (CELL)
 -- Function File:  legend (..., 'location', POS)
 -- Function File:  legend (..., 'orientation', ORIENT)
 -- Function File:  legend (HAX, ...)
 -- Function File:  legend (HOBJS, ...)
 -- Function File:  legend (HAX, HOBJS, ...)
 -- Function File:  legend ('OPTION')
     Display a legend for the axes with handle HAX, or the current axes,
     using the specified strings as labels.  Legend entries may be
     specified as individual character string arguments, a character
     array, or a cell array of character strings.  If the handles,
     HOBJS, are not specified then the legend's strings will be
     associated with the axes' descendants.  Legend works on line
     graphs, bar graphs, etc.  A plot must exist before legend is
     called.

     The optional parameter POS specifies the location of the legend as
     follows:

          POS        location of the legend
 ...

     USE help legend FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="legendre" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: L = legendre (N, X)
 -- Function File: L = legendre (N, X, NORMALIZATION)
     Compute the Legendre function of degree N and order M = 0 ... N.
     The optional argument, NORMALIZATION, may be one of &quot;unnorm&quot;,
     &quot;sch&quot;, or &quot;norm&quot;.  The default is &quot;unnorm&quot;.  The value of N
     must be a non-negative scalar integer.

     If the optional argument NORMALIZATION is missing or is
     &quot;unnorm&quot;, compute the Legendre function of degree N and order M
     and return all values for M = 0 ... N.  The return value has one
     dimension more than X.

     The Legendre Function of degree N and order M:

           m        m       2  m/2   d^m
          P(x) = (-1) * (1-x  )    * ----  P(x)
           n                         dx^m   n

     with Legendre polynomial of degree N:

                    1    d^n   2    n
          P(x) = ------ [----(x - 1) ]
           n     2^n n!  dx^n

     'legendre (3, [-1.0, -0.9, -0.8])' returns the matrix:

           x  |   -...

     USE help legendre FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="length" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  length (A)
     Return the 'length' of the object A.  For matrix objects, the
     length is the number of rows or columns, whichever is greater (this
     odd definition is used for compatibility with MATLAB).

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="lgamma" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  lgamma (X)
 -- Mapping Function:  gammaln (X)
     Return the natural logarithm of the gamma function of X.

     See also: gamma, gammainc


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="license" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  license
     Display the license of Octave.

 -- Function File:  license ('inuse')
     Display a list of packages currently being used.

 -- Function File: RETVAL = license ('inuse')
     Return a structure containing the fields 'feature' and 'user'.

 -- Function File: RETVAL = license ('test', FEATURE)
     Return 1 if a license exists for the product identified by the
     string FEATURE and 0 otherwise.  The argument FEATURE is case
     insensitive and only the first 27 characters are checked.

 -- Function File:  license ('test', FEATURE, TOGGLE)
     Enable or disable license testing for FEATURE, depending on
     TOGGLE, which may be one of:

    'enable'
          Future tests for the specified license of FEATURE are
          conducted as usual.

    'disable'
          Future tests for the specified license of FEATURE return 0.

 -- Function File: RETVAL = license ('checkout', FEATURE)
     Check out a license for FEATURE, returning 1 on success and 0 on...

     USE help license FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="lin2mu" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  lin2mu (X, N)
     Convert audio data from linear to mu-law.  Mu-law values use 8-bit
     unsigned integers.  Linear values use N-bit signed integers or
     floating point values in the range -1 &lt;= X &lt;= 1 if N is 0.

     If N is not specified it defaults to 0, 8, or 16 depending on the
     range of values in X.

     See also: mu2lin, loadaudio, saveaudio


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="line" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  line ()
 -- Function File:  line (X, Y)
 -- Function File:  line (X, Y, Z)
 -- Function File:  line (X, Y, Z, PROPERTY, VALUE, ...)
     Create line object from X and Y and insert in current axes object.
     Return a handle (or vector of handles) to the line objects created.

     Multiple property-value pairs may be specified for the line, but
     they must appear in pairs.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="link" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: [ERR, MSG] = link (OLD, NEW)
     Create a new link (also known as a hard link) to an existing file.

     If successful, ERR is 0 and MSG is an empty string.  Otherwise,
     ERR is nonzero and MSG contains a system-dependent error message.

     See also: symlink


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="linkprop" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: HLINK = linkprop (H, PROP)
     Link graphics object properties, such that a change in one is
     propagated to the others.  The properties to link are given as a
     string of cell string array by PROP and the objects containing
     these properties by the handle array H.

     An example of the use of linkprop is

          x = 0:0.1:10;
          subplot (1,2,1);
          h1 = plot (x, sin (x));
          subplot (1,2,2);
          h2 = plot (x, cos (x));
          hlink = linkprop ([h1, h2], {'color','linestyle'});
          set (h1, 'color', 'green');
          set (h2, 'linestyle', '--');


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="linspace" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  linspace (BASE, LIMIT)
 -- Built-in Function:  linspace (BASE, LIMIT, N)
     Return a row vector with N linearly spaced elements between BASE
     and LIMIT.  If the number of elements is greater than one, then
     the endpoints BASE and LIMIT are always included in the range.  If
     BASE is greater than LIMIT, the elements are stored in decreasing
     order.  If the number of points is not specified, a value of 100
     is used.

     The 'linspace' function always returns a row vector if both BASE
     and LIMIT are scalars.  If one, or both, of them are column
     vectors, 'linspace' returns a matrix.

     For compatibility with MATLAB, return the second argument (LIMIT)
     if fewer than two values are requested.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="list_in_columns" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  list_in_columns (ARG, WIDTH)
     Return a string containing the elements of ARG listed in columns
     with an overall maximum width of WIDTH.  The argument ARG must be
     a cell array of character strings or a character array.  If WIDTH
     is not specified, the width of the terminal screen is used.
     Newline characters are used to break the lines in the output
     string.  For example:

          list_in_columns ({'abc', 'def', 'ghijkl', 'mnop', 'qrs', 'tuv'}, 20)
              => ans = abc     mnop
                     def     qrs
                     ghijkl  tuv

          whos ans
              =>
              Variables in the current scope:

                Attr Name        Size                     Bytes  Class
                ==== ====        ====                     =====  =====
                     ans         1x37                        37  char

              Total is 37 elements using 37 bytes

     See also: terminal_size


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="list_primes" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  list_primes ()
 -- Function File:  list_primes (N)
     List the first N primes.  If N is unspecified, the first 25 primes
     are listed.

     The algorithm used is from page 218 of the TeXbook.

     See also: primes, isprime


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="load" func="yes">
            <Overload retVal="">
                <Param name="
 -- Command:  load file
 -- Command:  load options file
 -- Command:  load options file v1 v2 ...
 -- Command: S = load ('options', 'file', 'v1', 'v2', ...)
 -- Command:  load file options
 -- Command:  load file options v1 v2 ...
 -- Command: S = load ('file', 'options', 'v1', 'v2', ...)
     Load the named variables V1, V2, ..., from the file FILE.  If no
     variables are specified then all variables found in the file will
     be loaded.  As with 'save', the list of variables to extract can
     be full names or use a pattern syntax.  The format of the file is
     automatically detected but may be overridden by supplying the
     appropriate option.

     If load is invoked using the functional form

          load ('-option1', ..., 'file', 'v1', ...)

     then the OPTIONS, FILE, and variable name arguments (V1, ...) must
     be specified as character strings.

     If a variable that is not marked as global is loaded from a file
     when a global symbol with the same name alr...

     USE help load FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="loadaudio" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  loadaudio (NAME, EXT, BPS)
     Load audio data from the file 'NAME.EXT' into the vector X.

     The extension EXT determines how the data in the audio file is
     interpreted; the extensions 'lin' (default) and 'raw' correspond
     to linear, the extensions 'au', 'mu', or 'snd' to mu-law encoding.

     The argument BPS can be either 8 (default) or 16, and specifies
     the number of bits per sample used in the audio file.

     See also: lin2mu, mu2lin, saveaudio, playaudio, setaudio, record


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="loaded_graphics_toolkits" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  loaded_graphics_toolkits ()
     Return a cell array of the currently loaded graphics toolkits.

     See also: available_graphics_toolkits


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="loadobj" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: B = loadobj (A)
     Method of a class to manipulate an object after loading it from a
     file.  The function 'loadobj' is called when the object A is loaded
     using the 'load' function.  An example of the use of 'saveobj'
     might be to add fields to an object that don't make sense to be
     saved.  For example:

          function b = loadobj (a)
            b = a;
            b.addmissingfield = addfield (b);
          endfunction

     See also: saveobj, class


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="localtime" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: TM_STRUCT = localtime (T)
     Given a value returned from 'time', or any non-negative integer,
     return a time structure corresponding to the local time zone.

          localtime (time ())
              => {
                    usec = 0
                    sec = 6
                    min = 15
                    hour = 1
                    mday = 17
                    mon = 1
                    year = 97
                    wday = 1
                    yday = 47
                    isdst = 0
                    zone = CST
                  }

     See also: strftime, strptime, gmtime, mktime, time, now, date,
     clock, datenum, datestr, datevec, calendar, weekday


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="log" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  log (X)
     Compute the natural logarithm, 'ln (X)', for each element of X.
     To compute the matrix logarithm, see *note Linear Algebra::.

     See also: exp, log1p, log2, log10, logspace


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="log10" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  log10 (X)
     Compute the base-10 logarithm of each element of X.

     See also: log, log2, logspace, exp


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="log1p" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  log1p (X)
     Compute 'log (1 + X)' accurately in the neighborhood of zero.

     See also: log, exp, expm1


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="log2" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  log2 (X)
 -- Mapping Function: [F, E] = log2 (X)
     Compute the base-2 logarithm of each element of X.

     If called with two output arguments, split X into binary mantissa
     and exponent so that '1/2 &lt;= abs(f) &lt; 1' and E is an integer.  If
     'x = 0', 'f = e = 0'.

     See also: pow2, log, log10, exp


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="logical" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  logical (X)
     Convert X to logical type.

     See also: double, single, char


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="logistic_cdf" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  logistic_cdf (X)
     For each element of X, compute the cumulative distribution function
     (CDF) at X of the logistic distribution.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="logistic_inv" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  logistic_inv (X)
     For each element of X, compute the quantile (the inverse of the
     CDF) at X of the logistic distribution.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="logistic_pdf" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  logistic_pdf (X)
     For each element of X, compute the PDF at X of the logistic
     distribution.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="logistic_regression" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [THETA, BETA, DEV, DL, D2L, P] = logistic_regression
          (Y, X, PRINT, THETA, BETA)
     Perform ordinal logistic regression.

     Suppose Y takes values in K ordered categories, and let 'gamma_i
     (X)' be the cumulative probability that Y falls in one of the
     first I categories given the covariate X.  Then

          [theta, beta] = logistic_regression (y, x)

     fits the model

          logit (gamma_i (x)) = theta_i - beta' * x,   i = 1 ... k-1

     The number of ordinal categories, K, is taken to be the number of
     distinct values of 'round (Y)'.  If K equals 2, Y is binary and
     the model is ordinary logistic regression.  The matrix X is
     assumed to have full column rank.

     Given Y only, 'theta = logistic_regression (y)' fits the model
     with baseline logit odds only.

     The full form is

          [theta, beta, dev, dl, d2l, gamma]
             = logistic_regression (y, x, print, theta, beta)

     in which all output argume...

     USE help logistic_regression FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="logistic_rnd" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  logistic_rnd (R)
 -- Function File:  logistic_rnd (R, C, ...)
 -- Function File:  logistic_rnd ([SZ])
     Return a matrix of random samples from the logistic distribution.

     When called with a single size argument, return a square matrix
     with the dimension specified.  When called with more than one
     scalar argument the first two arguments are taken as the number of
     rows and columns and any further arguments specify additional
     matrix dimensions.  The size may also be specified with a vector
     of dimensions SZ.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="logit" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  logit (P)
     For each component of P, return the logit of P defined as

          logit (P) = log (P / (1-P))

     See also: logistic_cdf


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="loglog" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  loglog (Y)
 -- Function File:  loglog (X, Y)
 -- Function File:  loglog (X, Y, PROPERTY, VALUE, ...)
 -- Function File:  loglog (X, Y, FMT)
 -- Function File:  loglog (H, ...)
 -- Function File: H = loglog (...)
     Produce a two-dimensional plot using log scales for both axes.  See
     the documentation of 'plot' for a description of the arguments
     that 'loglog' will accept.

     The optional return value H is a graphics handle to the created
     plot.

     See also: plot, semilogx, semilogy


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="loglogerr" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  loglogerr (ARGS)
     Produce two-dimensional plots on double logarithm axis with
     errorbars.  Many different combinations of arguments are possible.
     The most used form is

          loglogerr (X, Y, EY, FMT)

     which produces a double logarithm plot of Y versus X with errors
     in the Y-scale defined by EY and the plot format defined by FMT.
     See errorbar for available formats and additional information.

     See also: errorbar, semilogxerr, semilogyerr


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="logm" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: S = logm (A)
 -- Function File: S = logm (A, OPT_ITERS)
 -- Function File: [S, ITERS] = logm (...)
     Compute the matrix logarithm of the square matrix A.  The
     implementation utilizes a Pade' approximant and the identity

          logm (A) = 2^k * logm (A^(1 / 2^k))

     The optional argument OPT_ITERS is the maximum number of square
     roots to compute and defaults to 100.  The optional output ITERS
     is the number of square roots actually computed.

     See also: expm, sqrtm


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="logncdf" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  logncdf (X)
 -- Function File:  logncdf (X, MU, SIGMA)
     For each element of X, compute the cumulative distribution
     function (CDF) at X of the lognormal distribution with parameters
     MU and SIGMA.  If a random variable follows this distribution, its
     logarithm is normally distributed with mean MU and standard
     deviation SIGMA.

     Default values are MU = 1, SIGMA = 1.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="logninv" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  logninv (X)
 -- Function File:  logninv (X, MU, SIGMA)
     For each element of X, compute the quantile (the inverse of the
     CDF) at X of the lognormal distribution with parameters MU and
     SIGMA.  If a random variable follows this distribution, its
     logarithm is normally distributed with mean 'log (MU)' and
     variance SIGMA.

     Default values are MU = 1, SIGMA = 1.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="lognpdf" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  lognpdf (X)
 -- Function File:  lognpdf (X, MU, SIGMA)
     For each element of X, compute the probability density function
     (PDF) at X of the lognormal distribution with parameters MU and
     SIGMA.  If a random variable follows this distribution, its
     logarithm is normally distributed with mean MU and standard
     deviation SIGMA.

     Default values are MU = 1, SIGMA = 1.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="lognrnd" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  lognrnd (MU, SIGMA)
 -- Function File:  lognrnd (MU, SIGMA, R)
 -- Function File:  lognrnd (MU, SIGMA, R, C, ...)
 -- Function File:  lognrnd (MU, SIGMA, [SZ])
     Return a matrix of random samples from the lognormal distribution
     with parameters MU and SIGMA.

     When called with a single size argument, return a square matrix
     with the dimension specified.  When called with more than one
     scalar argument the first two arguments are taken as the number of
     rows and columns and any further arguments specify additional
     matrix dimensions.  The size may also be specified with a vector
     of dimensions SZ.

     If no size arguments are given then the result matrix is the
     common size of MU and SIGMA.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="logspace" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  logspace (A, B)
 -- Function File:  logspace (A, B, N)
 -- Function File:  logspace (A, pi, N)
     Return a row vector with N elements logarithmically spaced from
     10^A to 10^B.  If N is unspecified it defaults to 50.

     If B is equal to pi, the points are between 10^A and pi, _not_
     10^A and 10^pi, in order to be compatible with the corresponding
     MATLAB function.

     Also for compatibility with MATLAB, return the second argument B
     if fewer than two values are requested.

     See also: linspace


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="lookfor" func="yes">
            <Overload retVal="">
                <Param name="
 -- Command:  lookfor STR
 -- Command:  lookfor -all STR
 -- Function File: [FUNC, HELPSTRING] = lookfor (STR)
 -- Function File: [FUNC, HELPSTRING] = lookfor ('-all', STR)
     Search for the string STR in all functions found in the current
     function search path.  By default, 'lookfor' searches for STR in
     the first sentence of the help string of each function found.  The
     entire help text of each function can be searched if the '-all'
     argument is supplied.  All searches are case insensitive.

     Called with no output arguments, 'lookfor' prints the list of
     matching functions to the terminal.  Otherwise, the output
     arguments FUNC and HELPSTRING define the matching functions and the
     first sentence of each of their help strings.

     The ability of 'lookfor' to correctly identify the first sentence
     of the help text is dependent on the format of the function's
     help.  All Octave core functions are correctly formatted, but the
     same can not ...

     USE help lookfor FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="lookup" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: IDX = lookup (TABLE, Y)
 -- Loadable Function: IDX = lookup (TABLE, Y, OPT)
     Lookup values in a sorted table.  Usually used as a prelude to
     interpolation.

     If table is increasing and 'idx = lookup (table, y)', then
     'table(idx(i)) &lt;= y(i) &lt; table(idx(i+1))' for all 'y(i)' within
     the table.  If 'y(i) &lt; table(1)' then 'idx(i)' is 0. If 'y(i) &gt;=
     table(end)' or 'isnan (y(i))' then 'idx(i)' is 'n'.

     If the table is decreasing, then the tests are reversed.  For
     non-strictly monotonic tables, empty intervals are always skipped.
     The result is undefined if TABLE is not monotonic, or if TABLE
     contains a NaN.

     The complexity of the lookup is O(M*log(N)) where N is the size of
     TABLE and M is the size of Y.  In the special case when Y is also
     sorted, the complexity is O(min(M*log(N),M+N)).

     TABLE and Y can also be cell arrays of strings (or Y can be a
     single string).  In this case, string lookup is perfo...

     USE help lookup FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="lqr" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [G, X, L] = lqr (SYS, Q, R)
 -- Function File: [G, X, L] = lqr (SYS, Q, R, S)
 -- Function File: [G, X, L] = lqr (A, B, Q, R)
 -- Function File: [G, X, L] = lqr (A, B, Q, R, S)
 -- Function File: [G, X, L] = lqr (A, B, Q, R, [], E)
 -- Function File: [G, X, L] = lqr (A, B, Q, R, S, E)
     Linear-quadratic regulator.

     *Inputs*
    SYS
          Continuous or discrete-time LTI model.

    A
          State transition matrix of continuous-time system.

    B
          Input matrix of continuous-time system.

    Q
          State weighting matrix.

    R
          Input weighting matrix.

    S
          Optional cross term matrix.  If S is not specified, a zero
          matrix is assumed.

    E
          Optional descriptor matrix.  If E is not specified, an
          identity matrix is assumed.

     *Outputs*
    G
          State feedback matrix.

    X
          Unique stabilizing solution of the continuous-time Riccati
          equation.

    L
          ...

     USE help lqr FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="ls" func="yes">
            <Overload retVal="">
                <Param name="
 -- Command:  ls options
     List directory contents.  For example:

          ls -l
               -| total 12
               -| -rw-r--r--   1 jwe  users  4488 Aug 19 04:02 foo.m
               -| -rw-r--r--   1 jwe  users  1315 Aug 17 23:14 bar.m

     The 'dir' and 'ls' commands are implemented by calling your
     system's directory listing command, so the available options may
     vary from system to system.

     See also: dir, stat, readdir, glob, filesep, ls_command


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="ls_command" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: VAL = ls_command ()
 -- Function File: OLD_VAL = ls_command (NEW_VAL)
     Query or set the shell command used by Octave's 'ls' command.

     See also: ls


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="lsim" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [Y, T, X] = lsim (SYS, U)
 -- Function File: [Y, T, X] = lsim (SYS, U, T)
 -- Function File: [Y, T, X] = lsim (SYS, U, T, X0)
 -- Function File: [Y, T, X] = lsim (SYS, U, T, [], METHOD)
 -- Function File: [Y, T, X] = lsim (SYS, U, T, X0, METHOD)
     Simulate LTI model response to arbitrary inputs.  If no output
     arguments are given, the system response is plotted on the screen.

     *Inputs*
    SYS
          LTI model.  System must be proper, i.e. it must not have more
          zeros than poles.

    U
          Vector or array of input signal.  Needs 'length(t)' rows and
          as many columns as there are inputs.  If SYS is a
          single-input system, row vectors U of length 'length(t)' are
          accepted as well.

    T
          Time vector.  Should be evenly spaced.  If SYS is a
          continuous-time system and T is a real scalar, SYS is
          discretized with sampling time 'tsam = t/(rows(u)-1)'.  If
          SYS is a discrete-time ...

     USE help lsim FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="lsode" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: [X, ISTATE, MSG] = lsode (FCN, X_0, T)
 -- Loadable Function: [X, ISTATE, MSG] = lsode (FCN, X_0, T, T_CRIT)
     Solve the set of differential equations

          dx
          -- = f(x, t)
          dt

     with

          x(t_0) = x_0

     The solution is returned in the matrix X, with each row
     corresponding to an element of the vector T.  The first element of
     T should be t_0 and should correspond to the initial state of the
     system X_0, so that the first row of the output is X_0.

     The first argument, FCN, is a string, inline, or function handle
     that names the function f to call to compute the vector of right
     hand sides for the set of equations.  The function must have the
     form

          XDOT = f (X, T)

     in which XDOT and X are vectors and T is a scalar.

     If FCN is a two-element string array or a two-element cell array
     of strings, inline functions, or function handles, the first
     element names the functio...

     USE help lsode FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="lsode_options" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function:  lsode_options ()
 -- Loadable Function: val = lsode_options (OPT)
 -- Loadable Function:  lsode_options (OPT, VAL)
     Query or set options for the function 'lsode'.  When called with
     no arguments, the names of all available options and their current
     values are displayed.  Given one argument, return the value of the
     corresponding option.  When called with two arguments,
     'lsode_options' set the option OPT to value VAL.

     Options include

    &quot;absolute tolerance&quot;
          Absolute tolerance.  May be either vector or scalar.  If a
          vector, it must match the dimension of the state vector.

    &quot;relative tolerance&quot;
          Relative tolerance parameter.  Unlike the absolute tolerance,
          this parameter may only be a scalar.

          The local error test applied at each integration step is

                abs (local error in x(i)) &lt;= ...
                    rtol * abs (y(i)) + atol(i)

    &quot;integration method&quot;
      ...

     USE help lsode_options FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="lsqnonneg" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: X = lsqnonneg (C, D)
 -- Function File: X = lsqnonneg (C, D, X0)
 -- Function File: [X, RESNORM] = lsqnonneg (...)
 -- Function File: [X, RESNORM, RESIDUAL] = lsqnonneg (...)
 -- Function File: [X, RESNORM, RESIDUAL, EXITFLAG] = lsqnonneg (...)
 -- Function File: [X, RESNORM, RESIDUAL, EXITFLAG, OUTPUT] = lsqnonneg
          (...)
 -- Function File: [X, RESNORM, RESIDUAL, EXITFLAG, OUTPUT, LAMBDA] =
lsqnonneg (...)
     Minimize 'norm (C*X - d)' subject to 'X &gt;= 0'.  C and D must be
     real.  X0 is an optional initial guess for X.

     Outputs:
        * resnorm

          The squared 2-norm of the residual: norm(C*X-D)^2

        * residual

          The residual: D-C*X

        * exitflag

          An indicator of convergence.  0 indicates that the iteration
          count was exceeded, and therefore convergence was not
          reached; >0 indicates that the algorithm converged.  (The
          algorithm is stable and will converge given enough
          it...

     USE help lsqnonneg FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="lt" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  lt (X, Y)
     This function is equivalent to 'x &lt; y'.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="lu" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: [L, U] = lu (A)
 -- Loadable Function: [L, U, P] = lu (A)
 -- Loadable Function: [L, U, P, Q] = lu (S)
 -- Loadable Function: [L, U, P, Q, R] = lu (S)
 -- Loadable Function: [...] = lu (S, THRES)
 -- Loadable Function: Y = lu (...)
 -- Loadable Function: [...] = lu (..., 'vector')
     Compute the LU decomposition of A.  If A is full subroutines from
     LAPACK are used and if A is sparse then UMFPACK is used.  The
     result is returned in a permuted form, according to the optional
     return value P.  For example, given the matrix 'a = [1, 2; 3, 4]',

          [l, u, p] = lu (A)

     returns

          l =

           1.00000  0.00000
           0.33333  1.00000

          u =

           3.00000  4.00000
           0.00000  0.66667

          p =

           0  1
           1  0

     The matrix is not required to be square.

     When called with two or three output arguments and a spare input
     matrix, 'lu' does not attempt to perform sparsity preser...

     USE help lu FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="luinc" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: [L, U, P, Q] = luinc (A, '0')
 -- Loadable Function: [L, U, P, Q] = luinc (A, DROPTOL)
 -- Loadable Function: [L, U, P, Q] = luinc (A, OPTS)
     Produce the incomplete LU factorization of the sparse matrix A.
     Two types of incomplete factorization are possible, and the type
     is determined by the second argument to 'luinc'.

     Called with a second argument of '0', the zero-level incomplete
     LU factorization is produced.  This creates a factorization of A
     where the position of the non-zero arguments correspond to the same
     positions as in the matrix A.

     Alternatively, the fill-in of the incomplete LU factorization can
     be controlled through the variable DROPTOL or the structure OPTS.
     The UMFPACK multifrontal factorization code by Tim A.  Davis is
     used for the incomplete LU factorization, (availability
     'http://www.cise.ufl.edu/research/sparse/umfpack/')

     DROPTOL determines the values below which the values in the...

     USE help luinc FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="luupdate" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: [L, U] = luupdate (L, U, X, Y)
 -- Loadable Function: [L, U, P] = luupdate (L, U, P, X, Y)
     Given an LU factorization of a real or complex matrix A = L*U,
     L lower unit trapezoidal and U upper trapezoidal, return the
     LU factorization of A + X*Y.', where X and Y are column vectors
     (rank-1 update) or matrices with equal number of columns (rank-k
     update).  Optionally, row-pivoted updating can be used by supplying
     a row permutation (pivoting) matrix P; in that case, an updated
     permutation matrix is returned.  Note that if L, U, P is a pivoted
     LU factorization as obtained by 'lu':

           [L, U, P] = lu (A);

     then a factorization of A+X*Y.' can be obtained either as

           [L1, U1] = lu (L, U, P*X, Y)

     or

           [L1, U1, P1] = lu (L, U, P, X, Y)

     The first form uses the unpivoted algorithm, which is faster, but
     less stable.  The second form uses a slower pivoted algorithm,
     which is more stabl...

     USE help luupdate FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="lyap" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: X = lyap (A, B)
 -- Function File: X = lyap (A, B, C)
 -- Function File: X = lyap (A, B, [], E)
     Solve continuous-time Lyapunov or Sylvester equations.

     *Equations*
          AX + XA' + B = 0      (Lyapunov Equation)

          AX + XB + C = 0       (Sylvester Equation)

          AXE' + EXA' + B = 0   (Generalized Lyapunov Equation)

     *Algorithm*
     Uses SLICOT SB03MD, SB04MD and SG03AD by courtesy of NICONET e.V.
     (http://www.slicot.org)

     See also: lyapchol, dlyap, dlyapchol


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="lyapchol" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: U = lyapchol (A, B)
 -- Function File: U = lyapchol (A, B, E)
     Compute Cholesky factor of continuous-time Lyapunov equations.

     *Equations*
          A U' U  +  U' U A'  +  B B'  =  0           (Lyapunov Equation)

          A U' U E'  +  E U' U A'  +  B B'  =  0      (Generalized Lyapunov Equation)

     *Algorithm*
     Uses SLICOT SB03OD and SG03BD by courtesy of NICONET e.V.
     (http://www.slicot.org)

     See also: lyap, dlyap, dlyapchol


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="Madievski" func="yes">
            <Overload retVal="">
                <Param name="
Frequency-weighted controller reduction.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="magic" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  magic (N)
     Create an N-by-N magic square.  A magic square is an arrangement
     of the integers '1:n^2' such that the row sums, column sums, and
     diagonal sums are all equal to the same value.

     Note: N must be greater than 2 for the magic square to exist.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="mahalanobis" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  mahalanobis (X, Y)
     Return the Mahalanobis' D-square distance between the multivariate
     samples X and Y, which must have the same number of components
     (columns), but may have a different number of observations (rows).

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="make_absolute_filename" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  make_absolute_filename (FILE)
     Return the full name of FILE, relative to the current directory.

     See also: is_absolute_filename, is_rooted_relative_filename, isdir


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="makeinfo_program" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: VAL = makeinfo_program ()
 -- Built-in Function: OLD_VAL = makeinfo_program (NEW_VAL)
 -- Built-in Function:  makeinfo_program (NEW_VAL, 'local')
     Query or set the internal variable that specifies the name of the
     program that Octave runs to format help text containing Texinfo
     markup commands.  The default value is 'makeinfo'.

     When called from inside a function with the 'local' option, the
     variable is changed locally for the function and any subroutines
     it calls.  The original variable value is restored when exiting
     the function.

     See also: info_file, info_program, doc, help


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="manova" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  manova (X, G)
     Perform a one-way multivariate analysis of variance (MANOVA).  The
     goal is to test whether the p-dimensional population means of data
     taken from K different groups are all equal.  All data are assumed
     drawn independently from p-dimensional normal distributions with
     the same covariance matrix.

     The data matrix is given by X.  As usual, rows are observations
     and columns are variables.  The vector G specifies the
     corresponding group labels (e.g., numbers from 1 to K).

     The LR test statistic (Wilks' Lambda) and approximate p-values are
     computed and displayed.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="margin" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [GAMMA, PHI, W_GAMMA, W_PHI] = margin (SYS)
 -- Function File: [GAMMA, PHI, W_GAMMA, W_PHI] = margin (SYS, TOL)
     Gain and phase margin of a system.  If no output arguments are
     given, both gain and phase margin are plotted on a bode diagram.
     Otherwise, the margins and their corresponding frequencies are
     computed and returned.

     *Inputs*
    SYS
          LTI model.  Must be a single-input and single-output (SISO)
          system.

    TOL
          Imaginary parts below TOL are assumed to be zero.  If not
          specified, default value 'sqrt (eps)' is taken.

     *Outputs*
    GAMMA
          Gain margin (as gain, not dBs).

    PHI
          Phase margin (in degrees).

    W_GAMMA
          Frequency for the gain margin (in rad/s).

    W_PHI
          Frequency for the phase margin (in rad/s).

     *Equations*
          CONTINUOUS SYSTEMS
          Gain Margin
                  _               _
          L(jw) = L(jw)      BTW: L(jw) =...

     USE help margin FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="mat2cell" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: C = mat2cell (A, M, N)
 -- Loadable Function: C = mat2cell (A, D1, D2, ...)
 -- Loadable Function: C = mat2cell (A, R)
     Convert the matrix A to a cell array.  If A is 2-D, then it is
     required that 'sum (M) == size (A, 1)' and 'sum (N) == size (A,
     2)'.  Similarly, if A is multi-dimensional and the number of
     dimensional arguments is equal to the dimensions of A, then it is
     required that 'sum (DI) == size (A, i)'.

     Given a single dimensional argument R, the other dimensional
     arguments are assumed to equal 'size (A,I)'.

     An example of the use of mat2cell is

          mat2cell (reshape(1:16,4,4),[3,1],[3,1])
          => {
           [1,1] =

              1   5   9
              2   6  10
              3   7  11

           [2,1] =

              4   8  12

           [1,2] =

             13
             14
             15

           [2,2] = 16
          }

     See also: num2cell, cell2mat


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="mat2str" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: S = mat2str (X, N)
 -- Function File: S = mat2str (X, N, 'class')
     Format real, complex, and logical matrices as strings.  The
     returned string may be used to reconstruct the original matrix by
     using the 'eval' function.

     The precision of the values is given by N.  If N is a scalar then
     both real and imaginary parts of the matrix are printed to the
     same precision.  Otherwise 'N(1)' defines the precision of the
     real part and 'N(2)' defines the precision of the imaginary part.
     The default for N is 15.

     If the argument 'class' is given then the class of X is included
     in the string in such a way that 'eval' will result in the
     construction of a matrix of the same class.

          mat2str ([ -1/3 + i/7; 1/3 - i/7 ], [4 2])
               => '[-0.3333+0.14i;0.3333-0.14i]'

          mat2str ([ -1/3 +i/7; 1/3 -i/7 ], [4 2])
               => '[-0.3333+0i 0+0.14i;0.3333+0i -0-0.14i]'

          mat2str (int16([1 -1]), 'cla...

     USE help mat2str FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="matlabroot" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  matlabroot ()
     Return the name of the top-level Octave installation directory.

     This is an alias for the function 'OCTAVE_HOME' provided for
     compatibility.

     See also: OCTAVE_HOME


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="matrix_type" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: TYPE = matrix_type (A)
 -- Loadable Function: TYPE = matrix_type (A, 'nocompute')
 -- Loadable Function: A = matrix_type (A, TYPE)
 -- Loadable Function: A = matrix_type (A, 'upper', PERM)
 -- Loadable Function: A = matrix_type (A, 'lower', PERM)
 -- Loadable Function: A = matrix_type (A, 'banded', NL, NU)
     Identify the matrix type or mark a matrix as a particular type.
     This allows more rapid solutions of linear equations involving A
     to be performed.  Called with a single argument, 'matrix_type'
     returns the type of the matrix and caches it for future use.
     Called with more than one argument, 'matrix_type' allows the type
     of the matrix to be defined.

     If the option 'nocompute' is given, the function will not attempt
     to guess the type if it is still unknown.  This is useful for
     debugging purposes.

     The possible matrix types depend on whether the matrix is full or
     sparse, and can be one of the following

    'unkn...

     USE help matrix_type FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="max" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function:  max (X)
 -- Loadable Function:  max (X, Y)
 -- Loadable Function:  max (X, [], DIM)
 -- Loadable Function:  max (X, Y, DIM)
 -- Loadable Function: [W, IW] = max (X)
     For a vector argument, return the maximum value.  For a matrix
     argument, return the maximum value from each column, as a row
     vector, or over the dimension DIM if defined, in which case Y
     should be set to the empty matrix (it's ignored otherwise).  For
     two matrices (or a matrix and scalar), return the pair-wise
     maximum.  Thus,

          max (max (X))

     returns the largest element of the matrix X, and

          max (2:5, pi)
             =>  3.1416  3.1416  4.0000  5.0000

     compares each element of the range '2:5' with 'pi', and returns a
     row vector of the maximum values.

     For complex arguments, the magnitude of the elements are used for
     comparison.

     If called with one input and two output arguments, 'max' also
     returns the first index of ...

     USE help max FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="max_recursion_depth" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: VAL = max_recursion_depth ()
 -- Built-in Function: OLD_VAL = max_recursion_depth (NEW_VAL)
 -- Built-in Function:  max_recursion_depth (NEW_VAL, 'local')
     Query or set the internal limit on the number of times a function
     may be called recursively.  If the limit is exceeded, an error
     message is printed and control returns to the top level.

     When called from inside a function with the 'local' option, the
     variable is changed locally for the function and any subroutines
     it calls.  The original variable value is restored when exiting
     the function.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="mcnemar_test" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [PVAL, CHISQ, DF] = mcnemar_test (X)
     For a square contingency table X of data cross-classified on the
     row and column variables, McNemar's test can be used for testing
     the null hypothesis of symmetry of the classification
     probabilities.

     Under the null, CHISQ is approximately distributed as chisquare
     with DF degrees of freedom.

     The p-value (1 minus the CDF of this distribution at CHISQ) is
     returned in PVAL.

     If no output argument is given, the p-value of the test is
     displayed.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="md5sum" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function:  md5sum (FILE)
 -- Loadable Function:  md5sum (STR, OPT)
     Calculate the MD5 sum of the file FILE.  If the second parameter
     OPT exists and is true, then calculate the MD5 sum of the string
     STR.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="MDSSystem" func="yes">
            <Overload retVal="">
                <Param name="
Robust control of a mass-damper-spring system.  Type 'which MDSSystem'
to locate, 'edit MDSSystem' to open and simply 'MDSSystem' to run the
example file.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="mean" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  mean (X)
 -- Function File:  mean (X, DIM)
 -- Function File:  mean (X, OPT)
 -- Function File:  mean (X, DIM, OPT)
     Compute the mean of the elements of the vector X.

          mean (x) = SUM_i x(i) / N

     If X is a matrix, compute the mean for each column and return them
     in a row vector.

     The optional argument OPT selects the type of mean to compute.
     The following options are recognized:

    'a'
          Compute the (ordinary) arithmetic mean.  [default]

    'g'
          Compute the geometric mean.

    'h'
          Compute the harmonic mean.

     If the optional argument DIM is given, operate along this
     dimension.

     Both DIM and OPT are optional.  If both are supplied, either may
     appear first.

     See also: median, mode


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="meansq" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  meansq (X)
 -- Function File:  meansq (X, DIM)
     Compute the mean square of the elements of the vector X.

          std (x) = 1/N SUM_i x(i)^2

     For matrix arguments, return a row vector containing the mean
     square of each column.

     If the optional argument DIM is given, operate along this
     dimension.

     See also: var, std, moment


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="median" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  median (X)
 -- Function File:  median (X, DIM)
     Compute the median value of the elements of the vector X.  If the
     elements of X are sorted, the median is defined as

                        x(ceil(N/2))             N odd
          median (x) =
                       (x(N/2) + x((N/2)+1))/2   N even

     If X is a matrix, compute the median value for each column and
     return them in a row vector.  If the optional DIM argument is
     given, operate along this dimension.

     See also: mean, mode


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="menu" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  menu (TITLE, OPT1, ...)
     Print a title string followed by a series of options.  Each option
     will be printed along with a number.  The return value is the
     number of the option selected by the user.  This function is
     useful for interactive programs.  There is no limit to the number
     of options that may be passed in, but it may be confusing to
     present more than will fit easily on one screen.

     See also: disp, printf, input


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="merge" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  merge (MASK, TVAL, FVAL)
 -- Built-in Function:  ifelse (MASK, TVAL, FVAL)
     Merge elements of TRUE_VAL and FALSE_VAL, depending on the value
     of MASK.  If MASK is a logical scalar, the other two arguments can
     be arbitrary values.  Otherwise, MASK must be a logical array, and
     TVAL, FVAL should be arrays of matching class, or cell arrays.  In
     the scalar mask case, TVAL is returned if MASK is true, otherwise
     FVAL is returned.

     In the array mask case, both TVAL and FVAL must be either scalars
     or arrays with dimensions equal to MASK.  The result is
     constructed as follows:

          result(mask) = tval(mask);
          result(! mask) = fval(! mask);

     MASK can also be arbitrary numeric type, in which case it is first
     converted to logical.

     See also: logical


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="mesh" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  mesh (X, Y, Z)
 -- Function File:  mesh (Z)
 -- Function File:  mesh (..., C)
 -- Function File:  mesh (HAX, ...)
 -- Function File: H = mesh (...)
     Plot a mesh given matrices X, and Y from 'meshgrid' and a matrix Z
     corresponding to the X and Y coordinates of the mesh.  If X and Y
     are vectors, then a typical vertex is (X(j), Y(i), Z(i,j)).  Thus,
     columns of Z correspond to different X values and rows of Z
     correspond to different Y values.

     The color of the mesh is derived from the 'colormap' and the value
     of Z.  Optionally the color of the mesh can be specified
     independent of Z, by adding a fourth matrix, C.

     The optional return value H is a graphics handle to the created
     surface object.

     See also: colormap, contour, meshgrid, surf


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="meshc" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  meshc (X, Y, Z)
     Plot a mesh and contour given matrices X, and Y from 'meshgrid'
     and a matrix Z corresponding to the X and Y coordinates of the
     mesh.  If X and Y are vectors, then a typical vertex is (X(j),
     Y(i), Z(i,j)).  Thus, columns of Z correspond to different X
     values and rows of Z correspond to different Y values.

     See also: meshgrid, mesh, contour


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="meshgrid" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [XX, YY, ZZ] = meshgrid (X, Y, Z)
 -- Function File: [XX, YY] = meshgrid (X, Y)
 -- Function File: [XX, YY] = meshgrid (X)
     Given vectors of X and Y and Z coordinates, and returning 3
     arguments, return three-dimensional arrays corresponding to the X,
     Y, and Z coordinates of a mesh.  When returning only 2 arguments,
     return matrices corresponding to the X and Y coordinates of a
     mesh.  The rows of XX are copies of X, and the columns of YY are
     copies of Y.  If Y is omitted, then it is assumed to be the same
     as X, and Z is assumed the same as Y.

     See also: mesh, contour


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="meshz" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  meshz (X, Y, Z)
     Plot a curtain mesh given matrices X, and Y from 'meshgrid' and a
     matrix Z corresponding to the X and Y coordinates of the mesh.  If
     X and Y are vectors, then a typical vertex is (X(j), Y(i),
     Z(i,j)).  Thus, columns of Z correspond to different X values and
     rows of Z correspond to different Y values.

     See also: meshgrid, mesh, contour


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="methods" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  methods (X)
 -- Built-in Function:  methods ('classname')
     Return a cell array containing the names of the methods for the
     object X or the named class.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="mex" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  mex [options] file ...
     Compile source code written in C, C++, or Fortran, to a MEX file.
     This is equivalent to 'mkoctfile --mex [options] file'.

     See also: mkoctfile


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="mexext" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  mexext ()
     Return the filename extension used for MEX files.

     See also: mex


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="mfilename" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  mfilename ()
 -- Built-in Function:  mfilename ('fullpath')
 -- Built-in Function:  mfilename ('fullpathext')
     Return the name of the currently executing file.  At the top-level,
     return the empty string.  Given the argument &quot;fullpath&quot;, include
     the directory part of the file name, but not the extension.  Given
     the argument &quot;fullpathext&quot;, include the directory part of the
     file name and the extension.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="mgorth" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: [Y, H] = mgorth (X, V)
     Orthogonalize a given column vector X with respect to a given
     orthonormal basis V using a modified Gram-Schmidt
     orthogonalization.  On exit, Y is a unit vector such that:

           norm (Y) = 1
           V' * Y = 0
           X = H*[V, Y]


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="min" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function:  min (X)
 -- Loadable Function:  min (X, Y)
 -- Loadable Function:  min (X, [], DIM)
 -- Loadable Function:  min (X, Y, DIM)
 -- Loadable Function: [W, IW] = min (X)
     For a vector argument, return the minimum value.  For a matrix
     argument, return the minimum value from each column, as a row
     vector, or over the dimension DIM if defined, in which case Y
     should be set to the empty matrix (it's ignored otherwise).  For
     two matrices (or a matrix and scalar), return the pair-wise
     minimum.  Thus,

          min (min (X))

     returns the smallest element of X, and

          min (2:5, pi)
             =>  2.0000  3.0000  3.1416  3.1416

     compares each element of the range '2:5' with 'pi', and returns a
     row vector of the minimum values.

     For complex arguments, the magnitude of the elements are used for
     comparison.

     If called with one input and two output arguments, 'min' also
     returns the first index of the minimu...

     USE help min FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="minus" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  minus (X, Y)
     This function and x - y are equivalent.

     See also: plus


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="mislocked" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  mislocked ()
 -- Built-in Function:  mislocked (FCN)
     Return true if the named function FCN is locked.  If no function is
     named then return true if the current function is locked.

     See also: mlock, munlock, persistent


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="missing_function_hook" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: VAL = missing_function_hook ()
 -- Built-in Function: OLD_VAL = missing_function_hook (NEW_VAL)
 -- Built-in Function:  missing_function_hook (NEW_VAL, 'local')
     Query or set the internal variable that specifies the function to
     call when an unknown identifier is requested.

     When called from inside a function with the 'local' option, the
     variable is changed locally for the function and any subroutines
     it calls.  The original variable value is restored when exiting
     the function.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="mixsyn" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [K, N, GAMMA, RCOND] = mixsyn (G, W1, W2, W3, ...)
     Solve stacked S/KS/T H-infinity problem.  Bound the largest
     singular values of S (for performance), K S (to penalize large
     inputs) and T (for robustness and to avoid sensitivity to noise).
     In other words, the inputs r are excited by a harmonic test signal.
     Then the algorithm tries to find a controller K which minimizes
     the H-infinity norm calculated from the outputs z.

     *Inputs*
    G
          LTI model of plant.

    W1
          LTI model of performance weight.  Bounds the largest singular
          values of sensitivity S.  Model must be empty '[]', SISO or
          of appropriate size.

    W2
          LTI model to penalize large control inputs.  Bounds the
          largest singular values of KS.  Model must be empty '[]',
          SISO or of appropriate size.

    W3
          LTI model of robustness and noise sensitivity weight.  Bounds
          the largest singular valu...

     USE help mixsyn FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="mkdir" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: [STATUS, MSG, MSGID] = mkdir (DIR)
 -- Built-in Function: [STATUS, MSG, MSGID] = mkdir (PARENT, DIR)
     Create a directory named DIR in the directory PARENT.

     If successful, STATUS is 1, with MSG and MSGID empty character
     strings.  Otherwise, STATUS is 0, MSG contains a system-dependent
     error message, and MSGID contains a unique message identifier.

     See also: rmdir


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="mkfifo" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: [ERR, MSG] = mkfifo (NAME, MODE)
     Create a FIFO special file named NAME with file mode MODE

     If successful, ERR is 0 and MSG is an empty string.  Otherwise,
     ERR is nonzero and MSG contains a system-dependent error message.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="mkoctfile" func="yes">
            <Overload retVal="">
                <Param name="
 -- Command:  mkoctfile [-options] file ...
 -- Function File: [OUTPUT, STATUS = mkoctfile (...)
     The 'mkoctfile' function compiles source code written in C, C++,
     or Fortran.  Depending on the options used with 'mkoctfile', the
     compiled code can be called within Octave or can be used as a
     stand-alone application.

     'mkoctfile' can be called from the shell prompt or from the Octave
     prompt.  Calling it from the Octave prompt simply delegates the
     call to the shell prompt.  The output is stored in the OUTPUT
     variable and the exit status in the STATUS variable.

     'mkoctfile' accepts the following options, all of which are
     optional except for the file name of the code you wish to compile:

    '-I DIR'
          Add the include directory DIR to compile commands.

    '-D DEF'
          Add the definition DEF to the compiler call.

    '-l LIB'
          Add the library LIB to the link command.

    '-L DIR'
          Add the library directory DI...

     USE help mkoctfile FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="mkpp" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: PP = mkpp (BREAKS, COEFS)
 -- Function File: PP = mkpp (BREAKS, COEFS, D)
     Construct a piecewise polynomial (pp) structure from sample points
     BREAKS and coefficients COEFS.  BREAKS must be a vector of
     strictly increasing values.  The number of intervals is given by
     'NI = length (BREAKS) - 1'.  When M is the polynomial order COEFS
     must be of size: NI x M + 1.

     The i-th row of COEFS, 'COEFS (I,:)', contains the coefficients
     for the polynomial over the I-th interval, ordered from highest
     (M) to lowest (0).

     COEFS may also be a multi-dimensional array, specifying a
     vector-valued or array-valued polynomial.  In that case the
     polynomial order is defined by the length of the last dimension of
     COEFS.  The size of first dimension(s) are given by the scalar or
     vector D.  If D is not given it is set to '1'.  In any case COEFS
     is reshaped to a 2-D matrix of size '[NI*prod(D M)] '

     See also: unmkpp, ppval, ...

     USE help mkpp FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="mkstemp" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: [FID, NAME, MSG] = mkstemp (TEMPLATE, DELETE)
     Return the file ID corresponding to a new temporary file with a
     unique name created from TEMPLATE.  The last six characters of
     TEMPLATE must be 'XXXXXX' and these are replaced with a string
     that makes the filename unique.  The file is then created with
     mode read/write and permissions that are system dependent (on
     GNU/Linux systems, the permissions will be 0600 for versions of
     glibc 2.0.7 and later).  The file is opened in binary mode and
     with the 'O_EXCL' flag.

     If the optional argument DELETE is supplied and is true, the file
     will be deleted automatically when Octave exits, or when the
     function 'purge_tmp_files' is called.

     If successful, FID is a valid file ID, NAME is the name of the
     file, and MSG is an empty string.  Otherwise, FID is -1, NAME is
     empty, and MSG contains a system-dependent error message.

     See also: tmpfile, tmpnam, P_tmpdir
...

     USE help mkstemp FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="mktime" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: SECONDS = mktime (TM_STRUCT)
     Convert a time structure corresponding to the local time to the
     number of seconds since the epoch.  For example:

          mktime (localtime (time ()))
              => 856163706

     See also: strftime, strptime, localtime, gmtime, time, now, date,
     clock, datenum, datestr, datevec, calendar, weekday


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="mldivide" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  mldivide (X, Y)
     Return the matrix left division of X and Y.  This function and
     x \ y are equivalent.

     See also: mrdivide, ldivide


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="mlock" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  mlock ()
     Lock the current function into memory so that it can't be cleared.

     See also: munlock, mislocked, persistent


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="mod" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  mod (X, Y)
     Compute the modulo of X and Y.  Conceptually this is given by

          x - y .* floor (x ./ y)

     and is written such that the correct modulus is returned for
     integer types.  This function handles negative values correctly.
     That is, 'mod (-1, 3)' is 2, not -1, as 'rem (-1, 3)' returns.
     'mod (X, 0)' returns X.

     An error results if the dimensions of the arguments do not agree,
     or if either of the arguments is complex.

     See also: rem


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="mode" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  mode (X)
 -- Function File:  mode (X, DIM)
 -- Function File: [M, F, C] = mode (...)
     Compute the most frequently occurring value in a dataset (mode).
     'mode' determines the frequency of values along the first
     non-singleton dimension and returns the value with the highest
     frequency.  If two, or more, values have the same frequency 'mode'
     returns the smallest.

     If the optional argument DIM is given, operate along this
     dimension.

     The return variable F is the number of occurrences of the mode in
     in the dataset.  The cell array C contains all of the elements
     with the maximum frequency.

     See also: mean, median


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="moment" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  moment (X, P)
 -- Function File:  moment (X, P, TYPE)
 -- Function File:  moment (X, P, DIM)
 -- Function File:  moment (X, P, TYPE, DIM)
 -- Function File:  moment (X, P, DIM, TYPE)
     Compute the P-th moment of the vector X about zero.

          moment (x) = 1/N SUM_i x(i)^p

     If X is a matrix, return the row vector containing the P-th moment
     of each column.

     The optional string TYPE specifies the type of moment to be
     computed.  Valid options are:

    'c'
          Central Moment.  The moment about the mean defined as

               1/N SUM_i (x(i) - mean(x))^p

    'a'
          Absolute Moment.  The moment about zero ignoring sign defined
          as

               1/N SUM_i ( abs (x(i)) )^p

    'ac'
          Absolute Central Moment.  Defined as

               1/N SUM_i ( abs (x(i) - mean(x)) )^p


     If the optional argument DIM is given, operate along this
     dimension.

     If both TYPE and DIM are given they may appear in an...

     USE help moment FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="more" func="yes">
            <Overload retVal="">
                <Param name="
 -- Command:  more
 -- Command:  more on
 -- Command:  more off
     Turn output pagination on or off.  Without an argument, 'more'
     toggles the current state.  The current state can be determined
     via 'page_screen_output'.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="mouse_wheel_zoom" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: SPEED = mouse_wheel_zoom ()
 -- Built-in Function:  mouse_wheel_zoom (SPEED)
     Query or set the mouse wheel zoom factor.

     This function is currently implemented only for the FLTK graphics
     toolkit.

     See also: gui_mode


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="movefile" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [STATUS, MSG, MSGID] = movefile (F1, F2)
 -- Function File: [STATUS, MSG, MSGID] = movefile (F1, F2, 'f')
     Move the file F1 to the new name F2.  The name F1 may contain
     globbing patterns.  If F1 expands to multiple file names, F2 must
     be a directory.  If the force flag 'f' is given then any existing
     files will be overwritten without prompting.

     If successful, STATUS is 1, with MSG and MSGID empty character
     strings.  Otherwise, STATUS is 0, MSG contains a system-dependent
     error message, and MSGID contains a unique message identifier.

     See also: rename, copyfile


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="mpoles" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [MULTP, IDXP] = mpoles (P)
 -- Function File: [MULTP, IDXP] = mpoles (P, TOL)
 -- Function File: [MULTP, IDXP] = mpoles (P, TOL, REORDER)
     Identify unique poles in P and their associated multiplicity.  The
     output is ordered from largest pole to smallest pole.

     If the relative difference of two poles is less than TOL then they
     are considered to be multiples.  The default value for TOL is
     0.001.

     If the optional parameter REORDER is zero, poles are not sorted.

     The output MULTP is a vector specifying the multiplicity of the
     poles.  'MULTP(n)' refers to the multiplicity of the Nth pole
     'P(IDXP(n))'.

     For example:

          p = [2 3 1 1 2];
          [m, n] = mpoles (p)
             => m = [1; 1; 2; 1; 2]
             => n = [2; 5; 1; 4; 3]
             => p(n) = [3, 2, 2, 1, 1]

     See also: residue, poly, roots, conv, deconv


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="mpower" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  mpower (X, Y)
     Return the matrix power operation of X raised to the Y power.
     This function and x ^ y are equivalent.

     See also: power


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="mrdivide" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  mrdivide (X, Y)
     Return the matrix right division of X and Y.  This function and
     x / y are equivalent.

     See also: mldivide, rdivide


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="mtimes" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  mtimes (X, Y)
 -- Built-in Function:  mtimes (X1, X2, ...)
     Return the matrix multiplication product of inputs.  This function
     and x * y are equivalent.  If more arguments are given, the
     multiplication is applied cumulatively from left to right:

           (...((x1 * x2) * x3) * ...)

     At least one argument is required.

     See also: times


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="mu2lin" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  mu2lin (X, N)
     Convert audio data from mu-law to linear.  Mu-law values are 8-bit
     unsigned integers.  Linear values use N-bit signed integers or
     floating point values in the range -1&lt;=y&lt;=1 if N is 0.

     If N is not specified it defaults to 0.

     See also: lin2mu, loadaudio, saveaudio


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="munlock" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  munlock ()
 -- Built-in Function:  munlock (FCN)
     Unlock the named function FCN.  If no function is named then
     unlock the current function.

     See also: mlock, mislocked, persistent


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="NA" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  NA
 -- Built-in Function:  NA (N)
 -- Built-in Function:  NA (N, M)
 -- Built-in Function:  NA (N, M, K, ...)
 -- Built-in Function:  NA (..., CLASS)
     Return a scalar, matrix, or N-dimensional array whose elements are
     all equal to the special constant used to designate missing values.

     Note that NA always compares not equal to NA (NA != NA).  To find
     NA values, use the 'isna' function.

     When called with no arguments, return a scalar with the value 'NA'.
     When called with a single argument, return a square matrix with
     the dimension specified.  When called with more than one scalar
     argument the first two arguments are taken as the number of rows
     and columns and any further arguments specify additional matrix
     dimensions.  The optional argument CLASS specifies the return type
     and may be either 'double' or 'single'.

     See also: isna


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="namelengthmax" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  namelengthmax ()
     Return the MATLAB compatible maximum variable name length.  Octave
     is capable of storing strings up to 2^31 - 1 in length.  However
     for MATLAB compatibility all variable, function, and structure
     field names should be shorter than the length supplied by
     'namelengthmax'.  In particular variables stored to a MATLAB file
     format will have their names truncated to this length.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="NaN" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  NaN
 -- Built-in Function:  NaN (N)
 -- Built-in Function:  NaN (N, M)
 -- Built-in Function:  NaN (N, M, K, ...)
 -- Built-in Function:  NaN (..., CLASS)
     Return a scalar, matrix, or N-dimensional array whose elements are
     all equal to the IEEE symbol NaN (Not a Number).  NaN is the
     result of operations which do not produce a well defined numerical
     result.  Common operations which produce a NaN are arithmetic with
     infinity (Inf - Inf), zero divided by zero (0/0), and any
     operation involving another NaN value (5 + NaN).

     Note that NaN always compares not equal to NaN (NaN != NaN).  This
     behavior is specified by the IEEE standard for floating point
     arithmetic.  To find NaN values, use the 'isnan' function.

     When called with no arguments, return a scalar with the value
     'NaN'.  When called with a single argument, return a square matrix
     with the dimension specified.  When called with more than one
     scalar...

     USE help NaN FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="nargchk" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: MSGSTR = nargchk (MINARGS, MAXARGS, NARGS)
 -- Function File: MSGSTR = nargchk (MINARGS, MAXARGS, NARGS, 'string')
 -- Function File: MSGSTRUCT = nargchk (MINARGS, MAXARGS, NARGS,
          'struct')
     Return an appropriate error message string (or structure) if the
     number of inputs requested is invalid.

     This is useful for checking to see that the number of input
     arguments supplied to a function is within an acceptable range.

     See also: nargoutchk, narginchk, error, nargin, nargout


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="nargin" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  nargin ()
 -- Built-in Function:  nargin (FCN_NAME)
     Within a function, return the number of arguments passed to the
     function.  At the top level, return the number of command line
     arguments passed to Octave.  If called with the optional argument
     FCN_NAME, return the maximum number of arguments the named
     function can accept, or -1 if the function accepts a variable
     number of arguments.

     See also: nargout, varargin, isargout, varargout, nthargout


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="narginchk" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  narginchk (MINARGS, MAXARGS)
     Check for correct number of arguments or generate an error message
     if the number of arguments in the calling function is outside the
     range MINARGS and MAXARGS.  Otherwise, do nothing.

     Both MINARGS and MAXARGS need to be scalar numeric values.  Zero,
     Inf and negative values are all allowed, and MINARGS and MAXARGS
     may be equal.

     Note that this function evaluates 'nargin' on the caller.

     See also: nargchk, nargoutchk, error, nargout, nargin


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="nargout" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  nargout ()
 -- Built-in Function:  nargout (FCN_NAME)
     Within a function, return the number of values the caller expects
     to receive.  If called with the optional argument FCN_NAME, return
     the maximum number of values the named function can produce, or -1
     if the function can produce a variable number of values.

     For example,

          f ()

     will cause 'nargout' to return 0 inside the function 'f' and

          [s, t] = f ()

     will cause 'nargout' to return 2 inside the function 'f'.

     At the top level, 'nargout' is undefined.

     See also: nargin, varargin, isargout, varargout, nthargout


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="nargoutchk" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  nargoutchk (MINARGS, MAXARGS)
 -- Function File: MSGSTR = nargoutchk (MINARGS, MAXARGS, NARGS)
 -- Function File: MSGSTR = nargoutchk (MINARGS, MAXARGS, NARGS,
          'string')
 -- Function File: MSGSTRUCT = nargoutchk (MINARGS, MAXARGS, NARGS,
          'struct')
     Check for correct number of output arguments.

     On the first form, returns an error unless the number of arguments
     in its caller is between the values of MINARGS and MAXARGS.  It
     does nothing otherwise.  Note that this function evaluates the
     value of 'nargout' on the caller so its value must have not been
     tampered with.

     Both MINARGS and MAXARGS need to be a numeric scalar.  Zero, Inf
     and negative are all valid, and they can have the same value.

     For backward compatibility reasons, the other forms return an
     appropriate error message string (or structure) if the number of
     outputs requested is invalid.

     This is useful for checking to see that the ...

     USE help nargoutchk FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="native_float_format" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  native_float_format ()
     Return the native floating point format as a string

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="nbincdf" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  nbincdf (X, N, P)
     For each element of X, compute the cumulative distribution function
     (CDF) at X of the negative binomial distribution with parameters N
     and P.

     When N is integer this is the Pascal distribution.  When N is
     extended to real numbers this is the Polya distribution.

     The number of failures in a Bernoulli experiment with success
     probability P before the N-th success follows this distribution.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="nbininv" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  nbininv (X, N, P)
     For each element of X, compute the quantile (the inverse of the
     CDF) at X of the negative binomial distribution with parameters N
     and P.

     When N is integer this is the Pascal distribution.  When N is
     extended to real numbers this is the Polya distribution.

     The number of failures in a Bernoulli experiment with success
     probability P before the N-th success follows this distribution.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="nbinpdf" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  nbinpdf (X, N, P)
     For each element of X, compute the probability density function
     (PDF) at X of the negative binomial distribution with parameters N
     and P.

     When N is integer this is the Pascal distribution.  When N is
     extended to real numbers this is the Polya distribution.

     The number of failures in a Bernoulli experiment with success
     probability P before the N-th success follows this distribution.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="nbinrnd" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  nbinrnd (N, P)
 -- Function File:  nbinrnd (N, P, R)
 -- Function File:  nbinrnd (N, P, R, C, ...)
 -- Function File:  nbinrnd (N, P, [SZ])
     Return a matrix of random samples from the negative binomial
     distribution with parameters N and P.

     When called with a single size argument, return a square matrix
     with the dimension specified.  When called with more than one
     scalar argument the first two arguments are taken as the number of
     rows and columns and any further arguments specify additional
     matrix dimensions.  The size may also be specified with a vector
     of dimensions SZ.

     If no size arguments are given then the result matrix is the
     common size of N and P.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="ncfsyn" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [K, N, GAMMA, INFO] = ncfsyn (G, W1, W2, FACTOR)
     Loop shaping H-infinity synthesis.  Compute positive feedback
     controller using the McFarlane/Glover normalized coprime factor
     (NCF) loop shaping design procedure.

     *Inputs*
    G
          LTI model of plant.

    W1
          LTI model of precompensator.  Model must be SISO or of
          appropriate size.  An identity matrix is taken if W1 is not
          specified or if an empty model '[]' is passed.

    W2
          LTI model of postcompensator.  Model must be SISO or of
          appropriate size.  An identity matrix is taken if W2 is not
          specified or if an empty model '[]' is passed.

    FACTOR
          'factor = 1' implies that an optimal controller is required.
          'factor &gt; 1' implies that a suboptimal controller is required,
          achieving a performance that is FACTOR times less than
          optimal.  Default value is 1.

     *Outputs*
    K
          State-spa...

     USE help ncfsyn FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="nchoosek" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: C = nchoosek (N, K)
 -- Function File: C = nchoosek (SET, K)
     Compute the binomial coefficient or all combinations of a set of
     items.

     If N is a scalar then calculate the binomial coefficient of N and
     K which is defined as

           /   \
           | n |    n (n-1) (n-2) ... (n-k+1)       n!
           |   |  = ------------------------- =  ---------
           | k |               k!                k! (n-k)!
           \   /

     This is the number of combinations of N items taken in groups of
     size K.

     If the first argument is a vector, SET, then generate all
     combinations of the elements of SET, taken K at a time, with one
     row per combination.  The result C has K columns and
     'nchoosek (length (SET), K)' rows.

     For example:

     How many ways can three items be grouped into pairs?

          nchoosek (3, 2)
             => 3

     What are the possible pairs?

          nchoosek (1:3, 2)
             =>  1   2
     ...

     USE help nchoosek FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="ndgrid" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [Y1, Y2, ..., Yn] = ndgrid (X1, X2, ..., Xn)
 -- Function File: [Y1, Y2, ..., Yn] = ndgrid (X)
     Given n vectors X1, ... Xn, 'ndgrid' returns n arrays of dimension
     n. The elements of the i-th output argument contains the elements
     of the vector Xi repeated over all dimensions different from the
     i-th dimension.  Calling ndgrid with only one input argument X is
     equivalent of calling ndgrid with all n input arguments equal to X:

     [Y1, Y2, ...,  Yn] = ndgrid (X, ..., X)

     See also: meshgrid


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="ndims" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  ndims (A)
     Return the number of dimensions of A.  For any array, the result
     will always be larger than or equal to 2.  Trailing singleton
     dimensions are not counted.

           ndims (ones (4, 1, 2, 1))
              => 3

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="ne" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  ne (X, Y)
     Return true if the two inputs are not equal.  This function is
     equivalent to 'x != y'.

     See also: eq, isequal


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="newplot" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  newplot ()
     Prepare graphics engine to produce a new plot.  This function is
     called at the beginning of all high-level plotting functions.  It
     is not normally required in user programs.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="news" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  news (PACKAGE)
     Display the current NEWS file for Octave or installed package.

     If PACKAGE is the name of an installed package, display the current
     NEWS file for that package.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="nextpow2" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  nextpow2 (X)
     If X is a scalar, return the first integer N such that 2^n &gt;= abs
     (x).

     If X is a vector, return 'nextpow2 (length (X))'.

     See also: pow2, log2


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="nfields" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  nfields (S)
     Return the number of fields of the structure S.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="nichols" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [MAG, PHA, W] = nichols (SYS)
 -- Function File: [MAG, PHA, W] = nichols (SYS, W)
     Nichols chart of frequency response.  If no output arguments are
     given, the response is printed on the screen.

     *Inputs*
    SYS
          LTI system.  Must be a single-input and single-output (SISO)
          system.

    W
          Optional vector of frequency values.  If W is not specified,
          it is calculated by the zeros and poles of the system.
          Alternatively, the cell '{wmin, wmax}' specifies a frequency
          range, where WMIN and WMAX denote minimum and maximum
          frequencies in rad/s.

     *Outputs*
    MAG
          Vector of magnitude.  Has length of frequency vector W.

    PHA
          Vector of phase.  Has length of frequency vector W.

    W
          Vector of frequency values used.

     See also: bode, nyquist, sigma


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="nnz" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: SCALAR = nnz (A)
     Return the number of non zero elements in A.

     See also: sparse


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="nonzeros" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  nonzeros (S)
     Return a vector of the non-zero values of the sparse matrix S.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="norm" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  norm (A)
 -- Built-in Function:  norm (A, P)
 -- Built-in Function:  norm (A, P, OPT)
     Compute the p-norm of the matrix A.  If the second argument is
     missing, 'p = 2' is assumed.

     If A is a matrix (or sparse matrix):

    P = '1'
          1-norm, the largest column sum of the absolute values of A.

    P = '2'
          Largest singular value of A.

    P = 'Inf' or &quot;inf&quot;
          Infinity norm, the largest row sum of the absolute values of
          A.

    P = &quot;fro&quot;
          Frobenius norm of A, 'sqrt (sum (diag (A' * A)))'.

    other P, 'P &gt; 1'
          maximum 'norm (A*x, p)' such that 'norm (x, p) == 1'

     If A is a vector or a scalar:

    P = 'Inf' or &quot;inf&quot;
          'max (abs (A))'.

    P = '-Inf'
          'min (abs (A))'.

    P = &quot;fro&quot;
          Frobenius norm of A, 'sqrt (sumsq (abs (A)))'.

    P = 0
          Hamming norm - the number of nonzero elements.

    other P, 'P &gt; 1'
          p-norm of A, '(sum (abs (A) .^ ...

     USE help norm FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="normcdf" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  normcdf (X)
 -- Function File:  normcdf (X, MU, SIGMA)
     For each element of X, compute the cumulative distribution
     function (CDF) at X of the normal distribution with mean MU and
     standard deviation SIGMA.

     Default values are MU = 0, SIGMA = 1.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="normest" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: N = normest (A)
 -- Function File: N = normest (A, TOL)
 -- Function File: [N, C] = normest (...)
     Estimate the 2-norm of the matrix A using a power series analysis.
     This is typically used for large matrices, where the cost of
     calculating 'norm (A)' is prohibitive and an approximation to the
     2-norm is acceptable.

     TOL is the tolerance to which the 2-norm is calculated.  By default
     TOL is 1e-6.  C returns the number of iterations needed for
     'normest' to converge.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="norminv" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  norminv (X)
 -- Function File:  norminv (X, MU, SIGMA)
     For each element of X, compute the quantile (the inverse of the
     CDF) at X of the normal distribution with mean MU and standard
     deviation SIGMA.

     Default values are MU = 0, SIGMA = 1.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="normpdf" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  normpdf (X)
 -- Function File:  normpdf (X, MU, SIGMA)
     For each element of X, compute the probability density function
     (PDF) at X of the normal distribution with mean MU and standard
     deviation SIGMA.

     Default values are MU = 0, SIGMA = 1.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="normrnd" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  normrnd (MU, SIGMA)
 -- Function File:  normrnd (MU, SIGMA, R)
 -- Function File:  normrnd (MU, SIGMA, R, C, ...)
 -- Function File:  normrnd (MU, SIGMA, [SZ])
     Return a matrix of random samples from the normal distribution with
     parameters mean MU and standard deviation SIGMA.

     When called with a single size argument, return a square matrix
     with the dimension specified.  When called with more than one
     scalar argument the first two arguments are taken as the number of
     rows and columns and any further arguments specify additional
     matrix dimensions.  The size may also be specified with a vector
     of dimensions SZ.

     If no size arguments are given then the result matrix is the
     common size of MU and SIGMA.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="not" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  not (X)
     Return the logical NOT of X.  This function is equivalent to '! x'.

     See also: and, or, xor


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="now" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: t = now ()
     Return the current local date/time as a serial day number (see
     'datenum').

     The integral part, 'floor (now)' corresponds to the number of days
     between today and Jan 1, 0000.

     The fractional part, 'rem (now, 1)' corresponds to the current
     time.

     See also: clock, date, datenum


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="nproc" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function:  nproc ()
 -- Loadable Function:  nproc (QUERY)
     Return the current number of available processors.

     If called with the optional argument QUERY, modify how processors
     are counted as follows:
    'all'
          total number of processors.

    'current'
          processors available to the current process.

    'overridable'
          likewise, but overridable through the 'OMP_NUM_THREADS'
          environment variable.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="nth_element" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  nth_element (X, N)
 -- Built-in Function:  nth_element (X, N, DIM)
     Select the n-th smallest element of a vector, using the ordering
     defined by 'sort'.  In other words, the result is equivalent to
     'sort(X)(N)'.  N can also be a contiguous range, either ascending
     'l:u' or descending 'u:-1:l', in which case a range of elements is
     returned.  If X is an array, 'nth_element' operates along the
     dimension defined by DIM, or the first non-singleton dimension if
     DIM is not given.

     nth_element encapsulates the C++ standard library algorithms
     nth_element and partial_sort.  On average, the complexity of the
     operation is O(M*log(K)), where 'M = size (X, DIM)' and
     'K = length (N)'.  This function is intended for cases where the
     ratio K/M is small; otherwise, it may be better to use 'sort'.

     See also: sort, min, max


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="nthargout" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  nthargout (N, FUNC, ...)
 -- Function File:  nthargout (N, NTOT, FUNC, ...)
     Return the Nth output argument of function given by the function
     handle or string FUNC.  Any arguments after FUNC are passed to
     FUNC.  The total number of arguments to call FUNC with can be
     passed in NTOT; by default NTOT is N.  The input N can also be a
     vector of indices of the output, in which case the output will be
     a cell array of the requested output arguments.

     The intended use 'nthargout' is to avoid intermediate variables.
     For example, when finding the indices of the maximum entry of a
     matrix, the following two compositions of nthargout

          M = magic (5);
          cell2mat (nthargout ([1, 2], @ind2sub, size(M),
                               nthargout (2, @max, M(:))))
          => 5   3

     are completely equivalent to the following lines:

          M = magic(5);
          [~, idx] = max (M(:));
          [i, j] = ind2sub (size...

     USE help nthargout FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="nthroot" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  nthroot (X, N)
     Compute the n-th root of X, returning real results for real
     components of X.  For example:

          nthroot (-1, 3)
          => -1
          (-1) ^ (1 / 3)
          => 0.50000 - 0.86603i

     X must have all real entries.  N must be a scalar.  If N is an
     even integer and X has negative entries, an error is produced.

     See also: realsqrt, sqrt, cbrt


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="ntsc2rgb" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  ntsc2rgb (YIQ)
     Transform a colormap or image from NTSC to RGB.

     See also: rgb2ntsc


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="null" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  null (A)
 -- Function File:  null (A, TOL)
     Return an orthonormal basis of the null space of A.

     The dimension of the null space is taken as the number of singular
     values of A not greater than TOL.  If the argument TOL is missing,
     it is computed as

          max (size (A)) * max (svd (A)) * eps

     See also: orth


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="num2cell" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: C = num2cell (A)
 -- Loadable Function: C = num2cell (A, DIM)
     Convert the numeric matrix A to a cell array.  If DIM is defined,
     the value C is of dimension 1 in this dimension and the elements
     of A are placed into C in slices.  For example:

          num2cell([1,2;3,4])
              => ans =
                 {
                   [1,1] =  1
                   [2,1] =  3
                   [1,2] =  2
                   [2,2] =  4
                 }
          num2cell([1,2;3,4],1)
              => ans =
                 {
                   [1,1] =
                      1
                      3
                   [1,2] =
                      2
                      4
                 }

     See also: mat2cell


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="num2hex" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: S = num2hex (N)
     Typecast a double precision number or vector to a 16 character
     hexadecimal string of the IEEE 754 representation of the number.
     For example:

          num2hex ([-1, 1, e, Inf, NaN, NA]);
          => 'bff0000000000000
             3ff0000000000000
             4005bf0a8b145769
             7ff0000000000000
             fff8000000000000
             7ff00000000007a2'

     See also: hex2num, hex2dec, dec2hex


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="num2str" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  num2str (X)
 -- Function File:  num2str (X, PRECISION)
 -- Function File:  num2str (X, FORMAT)
     Convert a number (or array) to a string (or a character array).
     The optional second argument may either give the number of
     significant digits (PRECISION) to be used in the output or a format
     template string (FORMAT) as in 'sprintf' (*note Formatted
     Output::).  'num2str' can also handle complex numbers.  For
     example:

          num2str (123.456)
               => '123.46'

          num2str (123.456, 4)
               => '123.5'

          s = num2str ([1, 1.34; 3, 3.56], '%5.1f')
               => s =
                  1.0  1.3
                  3.0  3.6
          whos s
               =>
                Attr Name        Size                     Bytes  Class
                ==== ====        ====                     =====  =====
                     s           2x8                         16  char

          num2str (1.234 + 27.3i)
            ...

     USE help num2str FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="numel" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  numel (A)
 -- Built-in Function:  numel (A, IDX1, IDX2, ...)
     Return the number of elements in the object A.  Optionally, if
     indices IDX1, IDX2, ... are supplied, return the number of
     elements that would result from the indexing

           A(IDX1, IDX2, ...)

     Note that the indices do not have to be numerical.  For example,

           A = 1;
           B = ones (2, 3);
           numel (A, B);

     will return 6, as this is the number of ways to index with B.

     This method is also called when an object appears as lvalue with
     cs-list indexing, i.e., 'object{...}' or 'object(...).field'.

     See also: size


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="nyquist" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [RE, IM, W] = nyquist (SYS)
 -- Function File: [RE, IM, W] = nyquist (SYS, W)
     Nyquist diagram of frequency response.  If no output arguments are
     given, the response is printed on the screen.

     *Inputs*
    SYS
          LTI system.  Must be a single-input and single-output (SISO)
          system.

    W
          Optional vector of frequency values.  If W is not specified,
          it is calculated by the zeros and poles of the system.
          Alternatively, the cell '{wmin, wmax}' specifies a frequency
          range, where WMIN and WMAX denote minimum and maximum
          frequencies in rad/s.

     *Outputs*
    RE
          Vector of real parts.  Has length of frequency vector W.

    IM
          Vector of imaginary parts.  Has length of frequency vector W.

    W
          Vector of frequency values used.

     See also: bode, nichols, sigma


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="nzmax" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: SCALAR = nzmax (SM)
     Return the amount of storage allocated to the sparse matrix SM.
     Note that Octave tends to crop unused memory at the first
     opportunity for sparse objects.  There are some cases of user
     created sparse objects where the value returned by 'nzmax' will
     not be the same as 'nnz', but in general they will give the same
     result.

     See also: sparse, spalloc


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="obsv" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: OB = obsv (SYS)
 -- Function File: OB = obsv (A, C)
     Return observability matrix.

     *Inputs*
    SYS
          LTI model.

    A
          State transition matrix (n-by-n).

    C
          Measurement matrix (p-by-n).

     *Outputs*
    OB
          Observability matrix.

     *Equation*
               | C        |
               | CA       |
          Ob = | CA^2     |
               | ...      |
               | CA^(n-1) |

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="obsvf" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [SYSBAR, T, K] = obsvf (SYS)
 -- Function File: [SYSBAR, T, K] = obsvf (SYS, TOL)
 -- Function File: [ABAR, BBAR, CBAR, T, K] = obsvf (A, B, C)
 -- Function File: [ABAR, BBAR, CBAR, T, K] = obsvf (A, B, C, TOL)
     If Ob=obsv(A,C) has rank r &lt;= n = SIZE(A,1), then there is a
     similarity transformation Tc such that To = [t1;t2] where t1 is c
     and t2 is orthogonal to t1

          Abar = To \ A * To ,  Bbar = To \ B ,  Cbar = C * To

     and the transformed system has the form

                 | Ao     0 |           | Bo  |
          Abar = |----------|,   Bbar = | --- |,  Cbar = [Co | 0 ].
                 | A21   Ano|           | Bno |

     where (Ao,Bo) is observable, and Co(sI-Ao)^(-1)Bo = C(sI-A)^(-1)B.
     And system is detectable if Ano has no eigenvalues in the right
     half plane. The last output K is a vector of length n containing
     the number of observable states.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="ocean" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: MAP = ocean ()
 -- Function File: MAP = ocean (N)
     Create color colormap.  This colormap varies from black to white
     with shades of blue.  The argument N must be a scalar.  If
     unspecified, the length of the current colormap, or 64, is used.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="octave_config_info" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  octave_config_info ()
 -- Built-in Function:  octave_config_info (OPTION)
     Return a structure containing configuration and installation
     information for Octave.

     If OPTION is a string, return the configuration information for the
     specified option.


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="octave_core_file_limit" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: VAL = octave_core_file_limit ()
 -- Built-in Function: OLD_VAL = octave_core_file_limit (NEW_VAL)
 -- Built-in Function:  octave_core_file_limit (NEW_VAL, 'local')
     Query or set the internal variable that specifies the maximum
     amount of memory (in kilobytes) of the top-level workspace that
     Octave will attempt to save when writing data to the crash dump
     file (the name of the file is specified by OCTAVE_CORE_FILE_NAME).
     If OCTAVE_CORE_FILE_OPTIONS flags specify a binary format, then
     OCTAVE_CORE_FILE_LIMIT will be approximately the maximum size of
     the file.  If a text file format is used, then the file could be
     much larger than the limit.  The default value is -1 (unlimited)

     When called from inside a function with the 'local' option, the
     variable is changed locally for the function and any subroutines
     it calls.  The original variable value is restored when exiting
     the function.

     See also: crash_dumps_o...

     USE help octave_core_file_limit FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="octave_core_file_name" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: VAL = octave_core_file_name ()
 -- Built-in Function: OLD_VAL = octave_core_file_name (NEW_VAL)
 -- Built-in Function:  octave_core_file_name (NEW_VAL, 'local')
     Query or set the internal variable that specifies the name of the
     file used for saving data from the top-level workspace if Octave
     aborts.  The default value is &quot;octave-core&quot;

     When called from inside a function with the 'local' option, the
     variable is changed locally for the function and any subroutines
     it calls.  The original variable value is restored when exiting
     the function.

     See also: crash_dumps_octave_core, octave_core_file_name,
     octave_core_file_options


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="octave_core_file_options" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: VAL = octave_core_file_options ()
 -- Built-in Function: OLD_VAL = octave_core_file_options (NEW_VAL)
 -- Built-in Function:  octave_core_file_options (NEW_VAL, 'local')
     Query or set the internal variable that specifies the options used
     for saving the workspace data if Octave aborts.  The value of
     'octave_core_file_options' should follow the same format as the
     options for the 'save' function.  The default value is Octave's
     binary format.

     When called from inside a function with the 'local' option, the
     variable is changed locally for the function and any subroutines
     it calls.  The original variable value is restored when exiting
     the function.

     See also: crash_dumps_octave_core, octave_core_file_name,
     octave_core_file_limit


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="OCTAVE_HOME" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  OCTAVE_HOME ()
     Return the name of the top-level Octave installation directory.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="OCTAVE_VERSION" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  OCTAVE_VERSION ()
     Return the version number of Octave, as a string.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="ols" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [BETA, SIGMA, R] = ols (Y, X)
     Ordinary least squares estimation for the multivariate model
     y = x*b + e with mean (e) = 0 and cov (vec (e)) = kron (s, I).
     where y is a t by p matrix, x is a t by k matrix, b is a k by p
     matrix, and e is a t by p matrix.

     Each row of Y and X is an observation and each column a variable.

     The return values BETA, SIGMA, and R are defined as follows.

    BETA
          The OLS estimator for b.  BETA is calculated directly via
          'inv (x'*x) * x' * y' if the matrix 'x'*x' is of full rank.
          Otherwise, 'BETA = pinv (X) * Y' where 'pinv (X)' denotes the
          pseudoinverse of X.

    SIGMA
          The OLS estimator for the matrix S,

               SIGMA = (Y-X*BETA)'
                 * (Y-X*BETA)
                 / (T-rank(X))

    R
          The matrix of OLS residuals, 'R = Y - X*BETA'.

     See also: gls, pinv


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="onCleanup" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: C = onCleanup (ACTION)
     Create a special object that executes a given function upon
     destruction.  If the object is copied to multiple variables (or
     cell or struct array elements) or returned from a function, ACTION
     will be executed after clearing the last copy of the object.  Note
     that if multiple local onCleanup variables are created, the order
     in which they are called is unspecified.  For similar
     functionality *Note The 'unwind_protect' Statement::.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="onenormest" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [EST, V, W, ITER] = onenormest (A, T)
 -- Function File: [EST, V, W, ITER] = onenormest (APPLY, APPLY_T, N, T)
     Apply Higham and Tisseur's randomized block 1-norm estimator to
     matrix A using T test vectors.  If T exceeds 5, then only 5 test
     vectors are used.

     If the matrix is not explicit, e.g., when estimating the norm of
     'inv (A)' given an LU factorization, 'onenormest' applies A and
     its conjugate transpose through a pair of functions APPLY and
     APPLY_T, respectively, to a dense matrix of size N by T.  The
     implicit version requires an explicit dimension N.

     Returns the norm estimate EST, two vectors V and W related by norm
     '(W, 1) = EST * norm (V, 1)', and the number of iterations ITER.
     The number of iterations is limited to 10 and is at least 2.

     References:
        * N.J. Higham and F. Tisseur, 'A Block Algorithm for Matrix
          1-Norm Estimation, with an Application to 1-Norm
          Pseudospectra'...

     USE help onenormest FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="ones" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  ones (N)
 -- Built-in Function:  ones (M, N)
 -- Built-in Function:  ones (M, N, K, ...)
 -- Built-in Function:  ones ([M N ...])
 -- Built-in Function:  ones (..., CLASS)
     Return a matrix or N-dimensional array whose elements are all 1.
     If invoked with a single scalar integer argument N, return a square
     NxN matrix.  If invoked with two or more scalar integer arguments,
     or a vector of integer values, return an array with the given
     dimensions.

     If you need to create a matrix whose values are all the same, you
     should use an expression like

          val_matrix = val * ones (m, n)

     The optional argument CLASS specifies the class of the return array
     and defaults to double.  For example:

          val = ones (m,n, 'uint8')

     See also: zeros


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="optimget" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  optimget (OPTIONS, PARNAME)
 -- Function File:  optimget (OPTIONS, PARNAME, DEFAULT)
     Return a specific option from a structure created by 'optimset'.
     If PARNAME is not a field of the OPTIONS structure, return DEFAULT
     if supplied, otherwise return an empty matrix.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="optimize_subsasgn_calls" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: VAL = optimize_subsasgn_calls ()
 -- Built-in Function: OLD_VAL = optimize_subsasgn_calls (NEW_VAL)
 -- Built-in Function:  optimize_subsasgn_calls (NEW_VAL, 'local')
     Query or set the internal flag for subsasgn method call
     optimizations.  If true, Octave will attempt to eliminate the
     redundant copying when calling subsasgn method of a user-defined
     class.

     When called from inside a function with the 'local' option, the
     variable is changed locally for the function and any subroutines
     it calls.  The original variable value is restored when exiting
     the function.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="optimset" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  optimset ()
 -- Function File:  optimset (PAR, VAL, ...)
 -- Function File:  optimset (OLD, PAR, VAL, ...)
 -- Function File:  optimset (OLD, NEW)
     Create options struct for optimization functions.

     Valid parameters are:
        * AutoScaling

        * ComplexEqn

        * FinDiffType

        * FunValCheck When enabled, display an error if the objective
          function returns a complex value or NaN.  Must be set to 'on'
          or 'off' [default].

        * GradObj When set to 'on', the function to be minimized must
          return a second argument which is the gradient, or first
          derivative, of the function at the point X.  If set to 'off'
          [default], the gradient is computed via finite differences.

        * Jacobian When set to 'on', the function to be minimized must
          return a second argument which is the Jacobian, or first
          derivative, of the function at the point X.  If set to 'off'
          [default], ...

     USE help optimset FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="options" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: OPT = options ('KEY1', VALUE1, 'KEY2', VALUE2, ...)
     Create options struct OPT from a number of key and value pairs.
     For use with order reduction commands.

     *Inputs*
    KEY, PROPERTY
          The name of the property.

    VALUE
          The value of the property.

     *Outputs*
    OPT
          Struct with fields for each key.

     *Example*
          octave:1> opt = options ('method', 'spa', 'tol', 1e-6)
          opt =

            scalar structure containing the fields:

              method = spa
              tol =  1.0000e-06

          octave:2> save filename opt
          octave:3> # save the struct 'opt' to file 'filename' for later use
          octave:4> load filename
          octave:5> # load struct 'opt' from file 'filename'


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="optiPID" func="yes">
            <Overload retVal="">
                <Param name="
Numerical optimization of a PID controller using an objective function.
The objective function is located in the file 'optiPIDfun'.  Type
'which optiPID' to locate, 'edit optiPID' to open and simply 'optiPID'
to run the example file.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="or" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  or (X, Y)
 -- Built-in Function:  or (X1, X2, ...)
     Return the logical OR of X and Y.  This function is equivalent to
     'x | y'.  If more arguments are given, the logical or is applied
     cumulatively from left to right:

           (...((x1 | x2) | x3) | ...)

     At least one argument is required.

     See also: and, not, xor


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="orderfields" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [T, P] = orderfields (S1)
 -- Function File: [T, P] = orderfields (S1, S2)
     Return a copy of S1 with fields arranged alphabetically or as
     specified by S2.

     Given one struct, arrange field names in S1 alphabetically.

     If the second argument is a struct, arrange field names in S1 as
     they appear in S2.  The second argument may also specify the order
     in a permutation vector or a cell array of strings containing the
     fieldnames of S1 in the desired order.

     The optional second output argument P is assigned the permutation
     vector which converts the original name order into the new name
     order.

     Examples:

          s = struct('d', 4, 'b', 2, 'a', 1, 'c', 3);
          t1 = orderfields (s)
               => t1 =
                  {
                    a =  1
                    b =  2
                    c =  3
                    d =  4
                  }
          t = struct('d', {}, 'c', {}, 'b', 'a', {});
          t2 ...

     USE help orderfields FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="orient" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  orient (ORIENTATION)
     Set the default print orientation.  Valid values for ORIENTATION
     include &quot;landscape&quot;, &quot;portrait&quot;, and &quot;tall&quot;.

     The &quot;tall&quot; option sets the orientation to portait and fills the
     page with the plot, while leaving a 0.25in border.

     If called with no arguments, return the default print orientation.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="orth" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  orth (A)
 -- Function File:  orth (A, TOL)
     Return an orthonormal basis of the range space of A.

     The dimension of the range space is taken as the number of singular
     values of A greater than TOL.  If the argument TOL is missing, it
     is computed as

          max (size (A)) * max (svd (A)) * eps

     See also: null


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="output_max_field_width" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: VAL = output_max_field_width ()
 -- Built-in Function: OLD_VAL = output_max_field_width (NEW_VAL)
 -- Built-in Function:  output_max_field_width (NEW_VAL, 'local')
     Query or set the internal variable that specifies the maximum width
     of a numeric output field.

     When called from inside a function with the 'local' option, the
     variable is changed locally for the function and any subroutines
     it calls.  The original variable value is restored when exiting
     the function.

     See also: format, fixed_point_format, output_precision


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="output_precision" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: VAL = output_precision ()
 -- Built-in Function: OLD_VAL = output_precision (NEW_VAL)
 -- Built-in Function:  output_precision (NEW_VAL, 'local')
     Query or set the internal variable that specifies the minimum
     number of significant figures to display for numeric output.

     When called from inside a function with the 'local' option, the
     variable is changed locally for the function and any subroutines
     it calls.  The original variable value is restored when exiting
     the function.

     See also: format, fixed_point_format, output_max_field_width


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="P_tmpdir" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  P_tmpdir ()
     Return the default name of the directory for temporary files on
     this system.  The name of this directory is system dependent.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="pack" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  pack ()
     Consolidate workspace memory in MATLAB.  This function is provided
     for compatibility, but does nothing in Octave.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="page_output_immediately" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: VAL = page_output_immediately ()
 -- Built-in Function: OLD_VAL = page_output_immediately (NEW_VAL)
 -- Built-in Function:  page_output_immediately (NEW_VAL, 'local')
     Query or set the internal variable that controls whether Octave
     sends output to the pager as soon as it is available.  Otherwise,
     Octave buffers its output and waits until just before the prompt
     is printed to flush it to the pager.

     When called from inside a function with the 'local' option, the
     variable is changed locally for the function and any subroutines
     it calls.  The original variable value is restored when exiting
     the function.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="page_screen_output" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: VAL = page_screen_output ()
 -- Built-in Function: OLD_VAL = page_screen_output (NEW_VAL)
 -- Built-in Function:  page_screen_output (NEW_VAL, 'local')
     Query or set the internal variable that controls whether output
     intended for the terminal window that is longer than one page is
     sent through a pager.  This allows you to view one screenful at a
     time.  Some pagers (such as 'less'--see *note Installation::) are
     also capable of moving backward on the output.

     When called from inside a function with the 'local' option, the
     variable is changed locally for the function and any subroutines
     it calls.  The original variable value is restored when exiting
     the function.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="PAGER" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: VAL = PAGER ()
 -- Built-in Function: OLD_VAL = PAGER (NEW_VAL)
 -- Built-in Function:  PAGER (NEW_VAL, 'local')
     Query or set the internal variable that specifies the program to
     use to display terminal output on your system.  The default value
     is normally &quot;less&quot;, &quot;more&quot;, or &quot;pg&quot;, depending on what
     programs are installed on your system.  *Note Installation::.

     When called from inside a function with the 'local' option, the
     variable is changed locally for the function and any subroutines
     it calls.  The original variable value is restored when exiting
     the function.

     See also: more, page_screen_output, page_output_immediately,
     PAGER_FLAGS


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="PAGER_FLAGS" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: VAL = PAGER_FLAGS ()
 -- Built-in Function: OLD_VAL = PAGER_FLAGS (NEW_VAL)
 -- Built-in Function:  PAGER_FLAGS (NEW_VAL, 'local')
     Query or set the internal variable that specifies the options to
     pass to the pager.

     When called from inside a function with the 'local' option, the
     variable is changed locally for the function and any subroutines
     it calls.  The original variable value is restored when exiting
     the function.

     See also: PAGER


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="pareto" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  pareto (X)
 -- Function File:  pareto (X, Y)
 -- Function File:  pareto (H, ...)
 -- Function File: H = pareto (...)
     Draw a Pareto chart, also called ABC chart.  A Pareto chart is a
     bar graph used to arrange information in such a way that
     priorities for process improvement can be established.  It
     organizes and displays information to show the relative importance
     of data.  The chart is similar to the histogram or bar chart,
     except that the bars are arranged in decreasing order from left to
     right along the abscissa.

     The fundamental idea (Pareto principle) behind the use of Pareto
     diagrams is that the majority of an effect is due to a small
     subset of the causes, so for quality improvement the first few (as
     presented on the diagram) contributing causes to a problem usually
     account for the majority of the result.  Thus, targeting these
     'major causes' for elimination results in the most cost-effective
     ...

     USE help pareto FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="parseparams" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [REG, PROP] = parseparams (PARAMS)
 -- Function File: [REG, VAR1, ...] = parseparams (PARAMS, NAME1,
          DEFAULT1, ...)
     Return in REG the cell elements of PARAM up to the first string
     element and in PROP all remaining elements beginning with the
     first string element.  For example:

          [reg, prop] = parseparams ({1, 2, 'linewidth', 10})
          reg =
          {
            [1,1] = 1
            [1,2] = 2
          }
          prop =
          {
            [1,1] = linewidth
            [1,2] = 10
          }

     The parseparams function may be used to separate 'regular'
     arguments and additional arguments given as property/value pairs of
     the VARARGIN cell array.

     In the second form of the call, available options are specified
     directly with their default values given as name-value pairs.  If
     PARAMS do not form name-value pairs, or if an option occurs that
     does not match any of the available options, an error...

     USE help parseparams FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="pascal" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  pascal (N)
 -- Function File:  pascal (N, T)
     Return the Pascal matrix of order N if 'T = 0'.  T defaults to 0.
     Return the pseudo-lower triangular Cholesky factor of the Pascal
     matrix if 'T = 1' (The sign of some columns may be negative).
     This matrix is its own inverse, that is 'pascal (N, 1) ^ 2 == eye
     (N)'.  If 'T = -1', return the true Cholesky factor with strictly
     positive values on the diagonal.  If 'T = 2', return a transposed
     and permuted version of 'pascal (N, 1)', which is the cube root of
     the identity matrix.  That is, 'pascal (N, 2) ^ 3 == eye (N)'.

     See also: chol


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="patch" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  patch ()
 -- Function File:  patch (X, Y, C)
 -- Function File:  patch (X, Y, Z, C)
 -- Function File:  patch (FV)
 -- Function File:  patch ('Faces', F, 'Vertices', V, ...)
 -- Function File:  patch (..., PROP, VAL)
 -- Function File:  patch (H, ...)
 -- Function File: H = patch (...)
     Create patch object from X and Y with color C and insert in the
     current axes object.  Return handle to patch object.

     For a uniform colored patch, C can be given as an RGB vector,
     scalar value referring to the current colormap, or string value
     (for example, 'r' or 'red').

     If passed a structure FV contain the fields 'vertices', 'faces'
     and optionally 'facevertexcdata', create the patch based on these
     properties.

     The optional return value H is a graphics handle to the created
     patch object.

     See also: fill


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="path" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  path (...)
     Modify or display Octave's load path.

     If NARGIN and NARGOUT are zero, display the elements of Octave's
     load path in an easy to read format.

     If NARGIN is zero and nargout is greater than zero, return the
     current load path.

     If NARGIN is greater than zero, concatenate the arguments,
     separating them with 'pathsep'.  Set the internal search path to
     the result and return it.

     No checks are made for duplicate elements.

     See also: addpath, rmpath, genpath, pathdef, savepath, pathsep


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="pathdef" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: VAL = pathdef ()
     Return the default path for Octave.  The path information is
     extracted from one of three sources.  In order of preference,
     those are;

       1. '~/.octaverc'

       2. '&lt;octave-home&gt;/.../&lt;version&gt;/m/startup/octaverc'

       3. Octave's path prior to changes by any octaverc.

     See also: path, addpath, rmpath, genpath, savepath, pathsep


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="pathsep" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: VAL = pathsep ()
 -- Built-in Function: OLD_VAL = pathsep (NEW_VAL)
     Query or set the character used to separate directories in a path.

     See also: filesep


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="pause" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  pause (SECONDS)
     Suspend the execution of the program.  If invoked without any
     arguments, Octave waits until you type a character.  With a
     numeric argument, it pauses for the given number of seconds.  For
     example, the following statement prints a message and then waits 5
     seconds before clearing the screen.

          fprintf (stderr, 'wait please...\n');
          pause (5);
          clc;

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="pbaspect" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  pbaspect (PLOT_BOX_ASPECT_RATIO)
     Set the plot box aspect ratio of the current axes.  The aspect
     ratio is a normalized 3-element vector representing the rendered
     lengths of the x, y, and z-axes.

 -- Function File: PLOT_BOX_ASPECT_RATIO = pbaspect ( )
     Return the plot box aspect ratio of the current axes.

 -- Function File:  pbaspect (MODE)
     Set the plot box aspect ratio mode of the current axes.

 -- Function File: PLOT_BOX_ASPECT_RATIO_MODE = pbaspect ('mode')
     Return the plot box aspect ratio mode of the current axes.

 -- Function File:  pbaspect (HAX, ...)
     Use the axes, with handle HAX, instead of the current axes.

     See also: axis, daspect, xlim, ylim, zlim


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="pcg" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: X = pcg (A, B, TOL, MAXIT, M1, M2, X0, ...)
 -- Function File: [X, FLAG, RELRES, ITER, RESVEC, EIGEST] = pcg (...)
     Solve the linear system of equations 'A * X = B' by means of the
     Preconditioned Conjugate Gradient iterative method.  The input
     arguments are

        * A can be either a square (preferably sparse) matrix or a
          function handle, inline function or string containing the name
          of a function which computes 'A * X'.  In principle A should
          be symmetric and positive definite; if 'pcg' finds A to not
          be positive definite, you will get a warning message and the
          FLAG output parameter will be set.

        * B is the right hand side vector.

        * TOL is the required relative tolerance for the residual error,
          'B - A * X'.  The iteration stops if 'norm (B - A * X) &lt;=
           TOL * norm (B - A * X0)'.  If TOL is empty or is omitted,
          the function sets 'TOL = 1e-6' by default.

  ...

     USE help pcg FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="pchip" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: PP = pchip (X, Y)
 -- Function File: YI = pchip (X, Y, XI)
     Return the Piecewise Cubic Hermite Interpolating Polynomial
     (pchip) of points X and Y.

     If called with two arguments, return the piecewise polynomial PP
     that may be used with 'ppval' to evaluate the polynomial at
     specific points.  When called with a third input argument, 'pchip'
     evaluates the pchip polynomial at the points XI.  The third
     calling form is equivalent to 'ppval (pchip (X, Y), XI)'.

     The variable X must be a strictly monotonic vector (either
     increasing or decreasing) of length N.  Y can be either a vector
     or array.  If Y is a vector then it must be the same length N as
     X.  If Y is an array then the size of Y must have the form '[S1,
     S2, ..., SK, N]' The array is reshaped internally to a matrix
     where the leading dimension is given by 'S1 * S2 * ... * SK' and
     each row of this matrix is then treated separately.  Note that this
    ...

     USE help pchip FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="pclose" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  pclose (FID)
     Close a file identifier that was opened by 'popen'.  You may also
     use 'fclose' for the same purpose.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="pcolor" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  pcolor (X, Y, C)
 -- Function File:  pcolor (C)
     Density plot for given matrices X, and Y from 'meshgrid' and a
     matrix C corresponding to the X and Y coordinates of the mesh's
     vertices.  If X and Y are vectors, then a typical vertex is (X(j),
     Y(i), C(i,j)).  Thus, columns of C correspond to different X
     values and rows of C correspond to different Y values.

     The 'colormap' is scaled to the extents of C.  Limits may be
     placed on the color axis by the command 'caxis', or by setting the
     'clim' property of the parent axis.

     The face color of each cell of the mesh is determined by
     interpolating the values of C for the cell's vertices.  Contrast
     this with 'imagesc' which renders one cell for each element of C.

     'shading' modifies an attribute determining the manner by which the
     face color of each cell is interpolated from the values of C, and
     the visibility of the cells' edges.  By default the attribute i...

     USE help pcolor FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="pcr" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: X = pcr (A, B, TOL, MAXIT, M, X0, ...)
 -- Function File: [X, FLAG, RELRES, ITER, RESVEC] = pcr (...)
     Solve the linear system of equations 'A * X = B' by means of the
     Preconditioned Conjugate Residuals iterative method.  The input
     arguments are

        * A can be either a square (preferably sparse) matrix or a
          function handle, inline function or string containing the name
          of a function which computes 'A * X'.  In principle A should
          be symmetric and non-singular; if 'pcr' finds A to be
          numerically singular, you will get a warning message and the
          FLAG output parameter will be set.

        * B is the right hand side vector.

        * TOL is the required relative tolerance for the residual error,
          'B - A * X'.  The iteration stops if 'norm (B - A * X) &lt;=
           TOL * norm (B - A * X0)'.  If TOL is empty or is omitted,
          the function sets 'TOL = 1e-6' by default.

        * MAXIT is t...

     USE help pcr FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="peaks" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  peaks ()
 -- Function File:  peaks (N)
 -- Function File:  peaks (X, Y)
 -- Function File: Z = peaks (...)
 -- Function File: [X, Y, Z] = peaks (...)
     Generate a function with lots of local maxima and minima.  The
     function has the form

     f(x,y) = 3*(1-x)^2*exp(-x^2 - (y+1)^2) ...
              - 10*(x/5 - x^3 - y^5)*exp(-x^2-y^2) ...
              - 1/3*exp(-(x+1)^2 - y^2)

     Called without a return argument, 'peaks' plots the surface of the
     above function using 'mesh'.  If N is a scalar, the 'peaks'
     returns the values of the above function on a N-by-N mesh over the
     range '[-3,3]'.  The default value for N is 49.

     If N is a vector, then it represents the X and Y values of the
     grid on which to calculate the above function.  The X and Y values
     can be specified separately.

     See also: surf, mesh, meshgrid


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="periodogram" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [Pxx, W] = periodogram (X)
     For a data matrix X from a sample of size N, return the
     periodogram.  The angular frequency is returned in W.

     [Pxx,w] = periodogram (X).

     [Pxx,w] = periodogram (X,win).

     [Pxx,w] = periodogram (X,win,nfft).

     [Pxx,f] = periodogram (X,win,nfft,Fs).

     [Pxx,f] = periodogram (X,win,nfft,Fs,'range').

        * x: data; if real-valued a one-sided spectrum is estimated, if
          complex-valued or range indicates 'twosided', the full
          spectrum is estimated.

        * win: weight data with window, x.*win is used for further
          computation, if window is empty, a rectangular window is used.

        * nfft: number of frequency bins, default max(256,
          2.^ceil(log2(length(x)))).

        * Fs: sampling rate, default 1.

        * range: 'onesided' computes spectrum from [0..nfft/2+1].
          'twosided' computes spectrum from [0..nfft-1].  These strings
          can appear at any positio...

     USE help periodogram FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="perl" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [OUTPUT, STATUS] = perl (SCRIPTFILE)
 -- Function File: [OUTPUT, STATUS] = perl (SCRIPTFILE, ARGUMENT1,
          ARGUMENT2, ...)
     Invoke Perl script SCRIPTFILE with possibly a list of command line
     arguments.  Returns output in OUTPUT and status in STATUS.

     See also: system


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="perms" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  perms (V)
     Generate all permutations of V, one row per permutation.  The
     result has size 'factorial (N) * N', where N is the length of V.

     As an example, 'perms([1, 2, 3])' returns the matrix

            1   2   3
            2   1   3
            1   3   2
            2   3   1
            3   1   2
            3   2   1

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="permute" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  permute (A, PERM)
     Return the generalized transpose for an N-D array object A.  The
     permutation vector PERM must contain the elements '1:ndims(A)' (in
     any order, but each element must appear only once).

     See also: ipermute


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="pi" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  pi
 -- Built-in Function:  pi (N)
 -- Built-in Function:  pi (N, M)
 -- Built-in Function:  pi (N, M, K, ...)
 -- Built-in Function:  pi (..., CLASS)
     Return a scalar, matrix, or N-dimensional array whose elements are
     all equal to the ratio of the circumference of a circle to its
     diameter.  Internally, 'pi' is computed as '4.0 * atan (1.0)'.

     When called with no arguments, return a scalar with the value of
     pi.  When called with a single argument, return a square matrix
     with the dimension specified.  When called with more than one
     scalar argument the first two arguments are taken as the number of
     rows and columns and any further arguments specify additional
     matrix dimensions.  The optional argument CLASS specifies the
     return type and may be either 'double' or 'single'.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="pie" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  pie (X)
 -- Function File:  pie (X, EXPLODE)
 -- Function File:  pie (..., LABELS)
 -- Function File:  pie (H, ...);
 -- Function File: H = pie (...);
     Produce a 2-D pie chart.

     Called with a single vector argument, produces a pie chart of the
     elements in X, with the size of the slice determined by percentage
     size of the values of X.

     The variable EXPLODE is a vector of the same length as X that if
     non zero 'explodes' the slice from the pie chart.

     If given LABELS is a cell array of strings of the same length as
     X, giving the labels of each of the slices of the pie chart.

     The optional return value H is a list of handles to the patch and
     text objects generating the plot.

     See also: pie3, bar, stem


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="pie3" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  pie3 (X)
 -- Function File:  pie3 (X, EXPLODE)
 -- Function File:  pie3 (..., LABELS)
 -- Function File:  pie3 (H, ...);
 -- Function File: H = pie3 (...);
     Draw a 3-D pie chart.

     Called with a single vector argument, produces a 3-D pie chart of
     the elements in X, with the size of the slice determined by
     percentage size of the values of X.

     The variable EXPLODE is a vector of the same length as X that if
     non zero 'explodes' the slice from the pie chart.

     If given LABELS is a cell array of strings of the same length as
     X, giving the labels of each of the slices of the pie chart.

     The optional return value H is a list of graphics handles to the
     patch, surface, and text objects generating the plot.

     See also: pie, bar, stem


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="pink" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: MAP = pink ()
 -- Function File: MAP = pink (N)
     Create color colormap.  This colormap varies from black to white
     with shades of gray-pink.  It gives a sepia tone when used on
     grayscale images.  The argument N must be a scalar.  If
     unspecified, the length of the current colormap, or 64, is used.

     See also: colormap


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="pinv" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function:  pinv (X)
 -- Loadable Function:  pinv (X, TOL)
     Return the pseudoinverse of X.  Singular values less than TOL are
     ignored.

     If the second argument is omitted, it is taken to be

          tol = max (size (X)) * sigma_max (X) * eps,

     where 'sigma_max (X)' is the maximal singular value of X.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="pipe" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: [READ_FD, WRITE_FD, ERR, MSG] = pipe ()
     Create a pipe and return the reading and writing ends of the pipe
     into READ_FD and WRITE_FD respectively.

     If successful, ERR is 0 and MSG is an empty string.  Otherwise,
     ERR is nonzero and MSG contains a system-dependent error message.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="pkg" func="yes">
            <Overload retVal="">
                <Param name="
 -- Command:  pkg COMMAND PKG_NAME
 -- Command:  pkg COMMAND OPTION PKG_NAME
     Manage packages (groups of add-on functions) for Octave.
     Different actions are available depending on the value of COMMAND.

     Available commands:

    'install'
          Install named packages.  For example,

               pkg install image-1.0.0.tar.gz

          installs the package found in the file 'image-1.0.0.tar.gz'.

          The OPTION variable can contain options that affect the manner
          in which a package is installed.  These options can be one or
          more of

         '-nodeps'
               The package manager will disable dependency checking.
               With this option it is possible to install a package
               even when it depends on another package which is not
               installed on the system.  *Use this option with care.*

         '-noauto'
               The package manager will not automatically load the
               installed package wh...

     USE help pkg FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="place" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: F = place (SYS, P)
 -- Function File: F = place (A, B, P)
 -- Function File: [F, INFO] = place (SYS, P, ALPHA)
 -- Function File: [F, INFO] = place (A, B, P, ALPHA)
     Pole assignment for a given matrix pair (A,B) such that 'p = eig
     (A-B*F)'.  If parameter ALPHA is specified, poles with real parts
     (continuous-time) or moduli (discrete-time) below ALPHA are left
     untouched.

     *Inputs*
    SYS
          LTI system.

    A
          State transition matrix (n-by-n) of a continuous-time system.

    B
          Input matrix (n-by-m) of a continuous-time system.

    P
          Desired eigenvalues of the closed-loop system state-matrix
          A-B*F.  'length (p) &lt;= rows (A)'.

    ALPHA
          Specifies the maximum admissible value, either for real parts
          or for moduli, of the eigenvalues of A which will not be
          modified by the eigenvalue assignment algorithm.  'alpha &gt;=
          0' for discrete-time systems.

     *Outputs*
 ...

     USE help place FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="planerot" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [G, Y] = planerot (X)
     Given a two-element column vector, returns the 2 by 2 orthogonal
     matrix G such that 'Y = G * X' and 'Y(2) = 0'.

     See also: givens


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="playaudio" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  playaudio (NAME, EXT)
 -- Function File:  playaudio (X)
     Play the audio file 'NAME.EXT' or the audio data stored in the
     vector X.

     See also: lin2mu, mu2lin, loadaudio, saveaudio, setaudio, record


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="plot" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  plot (Y)
 -- Function File:  plot (X, Y)
 -- Function File:  plot (X, Y, PROPERTY, VALUE, ...)
 -- Function File:  plot (X, Y, FMT)
 -- Function File:  plot (H, ...)
 -- Function File: H = plot (...)
     Produce two-dimensional plots.

     Many different combinations of arguments are possible.  The
     simplest form is

          plot (Y)

     where the argument is taken as the set of Y coordinates and the X
     coordinates are taken to be the indices of the elements starting
     with 1.

     To save a plot, in one of several image formats such as PostScript
     or PNG, use the 'print' command.

     If more than one argument is given, they are interpreted as

          plot (Y, PROPERTY, VALUE, ...)

     or

          plot (X, Y, PROPERTY, VALUE, ...)

     or

          plot (X, Y, FMT, ...)

     and so on.  Any number of argument sets may appear.  The X and Y
     values are interpreted as follows:

        * If a single data argument is supplied, it is...

     USE help plot FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="plot3" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  plot3 (ARGS)
     Produce three-dimensional plots.  Many different combinations of
     arguments are possible.  The simplest form is

          plot3 (X, Y, Z)

     in which the arguments are taken to be the vertices of the points
     to be plotted in three dimensions.  If all arguments are vectors
     of the same length, then a single continuous line is drawn.  If
     all arguments are matrices, then each column of the matrices is
     treated as a separate line.  No attempt is made to transpose the
     arguments to make the number of rows match.

     If only two arguments are given, as

          plot3 (X, C)

     the real and imaginary parts of the second argument are used as
     the Y and Z coordinates, respectively.

     If only one argument is given, as

          plot3 (C)

     the real and imaginary parts of the argument are used as the Y and
     Z values, and they are plotted versus their index.

     Arguments may also be given in groups of thr...

     USE help plot3 FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="plotmatrix" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  plotmatrix (X, Y)
 -- Function File:  plotmatrix (X)
 -- Function File:  plotmatrix (..., STYLE)
 -- Function File:  plotmatrix (H, ...)
 -- Function File: [H, AX, BIGAX, P, PAX] = plotmatrix (...)
     Scatter plot of the columns of one matrix against another.  Given
     the arguments X and Y, that have a matching number of rows,
     'plotmatrix' plots a set of axes corresponding to

          plot (X (:, i), Y (:, j)

     Given a single argument X, then this is equivalent to

          plotmatrix (X, X)

     except that the diagonal of the set of axes will be replaced with
     the histogram 'hist (X (:, i))'.

     The marker to use can be changed with the STYLE argument, that is a
     string defining a marker in the same manner as the 'plot' command.
     If a leading axes handle H is passed to 'plotmatrix', then this
     axis will be used for the plot.

     The optional return value H provides handles to the individual
     graphics objects in the scatte...

     USE help plotmatrix FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="plotyy" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  plotyy (X1, Y1, X2, Y2)
 -- Function File:  plotyy (..., FUN)
 -- Function File:  plotyy (..., FUN1, FUN2)
 -- Function File:  plotyy (H, ...)
 -- Function File: [AX, H1, H2] = plotyy (...)
     Plot two sets of data with independent y-axes.  The arguments X1
     and Y1 define the arguments for the first plot and X1 and Y2 for
     the second.

     By default the arguments are evaluated with 'feval (@plot, X, Y)'.
     However the type of plot can be modified with the FUN argument, in
     which case the plots are generated by 'feval (FUN, X, Y)'.  FUN
     can be a function handle, an inline function or a string of a
     function name.

     The function to use for each of the plots can be independently
     defined with FUN1 and FUN2.

     If given, H defines the principal axis in which to plot the X1 and
     Y1 data.  The return value AX is a two element vector with the
     axis handles of the two plots.  H1 and H2 are handles to the
     objects generated ...

     USE help plotyy FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="plus" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  plus (X, Y)
 -- Built-in Function:  plus (X1, X2, ...)
     This function and x + y are equivalent.  If more arguments are
     given, the summation is applied cumulatively from left to right:

           (...((x1 + x2) + x3) + ...)

     At least one argument is required.

     See also: minus


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="poisscdf" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  poisscdf (X, LAMBDA)
     For each element of X, compute the cumulative distribution
     function (CDF) at X of the Poisson distribution with parameter
     lambda.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="poissinv" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  poissinv (X, LAMBDA)
     For each element of X, compute the quantile (the inverse of the
     CDF) at X of the Poisson distribution with parameter LAMBDA.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="poisspdf" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  poisspdf (X, LAMBDA)
     For each element of X, compute the probability density function
     (PDF) at X of the Poisson distribution with parameter LAMBDA.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="poissrnd" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  poissrnd (LAMBDA)
 -- Function File:  poissrnd (LAMBDA, R)
 -- Function File:  poissrnd (LAMBDA, R, C, ...)
 -- Function File:  poissrnd (LAMBDA, [SZ])
     Return a matrix of random samples from the Poisson distribution
     with parameter LAMBDA.

     When called with a single size argument, return a square matrix
     with the dimension specified.  When called with more than one
     scalar argument the first two arguments are taken as the number of
     rows and columns and any further arguments specify additional
     matrix dimensions.  The size may also be specified with a vector
     of dimensions SZ.

     If no size arguments are given then the result matrix is the size
     of LAMBDA.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="pol2cart" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [X, Y] = pol2cart (THETA, R)
 -- Function File: [X, Y, Z] = pol2cart (THETA, R, Z)
 -- Function File: [X, Y] = pol2cart (P)
 -- Function File: [X, Y, Z] = pol2cart (P)
 -- Function File: C = pol2cart (...)
     Transform polar or cylindrical to Cartesian coordinates.

     THETA, R, (and Z) must be the same shape, or scalar.  THETA
     describes the angle relative to the positive x-axis.  R is the
     distance to the z-axis (0, 0, z).  If called with a single matrix
     argument then each row of P represents the polar/(cylindrical)
     coordinate (X, Y (, Z)).

     If only a single return argument is requested then return a matrix
     C where each row represents one Cartesian coordinate (X, Y (, Z)).

     See also: cart2pol, sph2cart, cart2sph


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="polar" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  polar (THETA, RHO)
 -- Function File:  polar (THETA, RHO, FMT)
 -- Function File:  polar (H, ...)
 -- Function File: H = polar (...)
     Create a two-dimensional plot from polar coordinates THETA and RHO.

     The optional argument FMT specifies the line format.

     The optional return value H is a graphics handle to the created
     plot.

     See also: plot


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="poly" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  poly (A)
 -- Function File:  poly (X)
     If A is a square N-by-N matrix, 'poly (A)' is the row vector of
     the coefficients of 'det (z * eye (N) - A)', the characteristic
     polynomial of A.  For example, the following code finds the
     eigenvalues of A which are the roots of 'poly (A)'.

          roots (poly (eye (3)))
              => 1.00001 + 0.00001i
                 1.00001 - 0.00001i
                 0.99999 + 0.00000i

     In fact, all three eigenvalues are exactly 1 which emphasizes that
     for numerical performance the 'eig' function should be used to
     compute eigenvalues.

     If X is a vector, 'poly (X)' is a vector of the coefficients of
     the polynomial whose roots are the elements of X.  That is, if C
     is a polynomial, then the elements of 'D = roots (poly (C))' are
     contained in C.  The vectors C and D are not identical, however,
     due to sorting and numerical errors.

     See also: roots, eig


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="polyaffine" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  polyaffine (F, MU)
     Return the coefficients of the polynomial vector F after an affine
     transformation.  If F is the vector representing the polynomial
     f(x), then 'G = polyaffine (F, MU)' is the vector representing:

          g(x) = f( (x - MU(1)) / MU(2) )

     See also: polyval, polyfit


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="polyarea" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  polyarea (X, Y)
 -- Function File:  polyarea (X, Y, DIM)
     Determine area of a polygon by triangle method.  The variables X
     and Y define the vertex pairs, and must therefore have the same
     shape.  They can be either vectors or arrays.  If they are arrays
     then the columns of X and Y are treated separately and an area
     returned for each.

     If the optional DIM argument is given, then 'polyarea' works along
     this dimension of the arrays X and Y.


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="polyder" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  polyder (P)
 -- Function File: [K] = polyder (A, B)
 -- Function File: [Q, D] = polyder (B, A)
     Return the coefficients of the derivative of the polynomial whose
     coefficients are given by the vector P.  If a pair of polynomials
     is given, return the derivative of the product A*B.  If two inputs
     and two outputs are given, return the derivative of the polynomial
     quotient B/A.  The quotient numerator is in Q and the denominator
     in D.

     See also: polyint, polyval, polyreduce


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="polyfit" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: P = polyfit (X, Y, N)
 -- Function File: [P, S] = polyfit (X, Y, N)
 -- Function File: [P, S, MU] = polyfit (X, Y, N)
     Return the coefficients of a polynomial P(X) of degree N that
     minimizes the least-squares-error of the fit to the points '[X,
     Y]'.

     The polynomial coefficients are returned in a row vector.

     The optional output S is a structure containing the following
     fields:

    'R'
          Triangular factor R from the QR decomposition.

    'X'
          The Vandermonde matrix used to compute the polynomial
          coefficients.

    'df'
          The degrees of freedom.

    'normr'
          The norm of the residuals.

    'yf'
          The values of the polynomial for each value of X.

     The second output may be used by 'polyval' to calculate the
     statistical error limits of the predicted values.

     When the third output, MU, is present the coefficients, P, are
     associated with a polynomial in XHAT = (X-MU(1))/M...

     USE help polyfit FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="polygcd" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: Q = polygcd (B, A)
 -- Function File: Q = polygcd (B, A, TOL)
     Find the greatest common divisor of two polynomials.  This is
     equivalent to the polynomial found by multiplying together all the
     common roots.  Together with deconv, you can reduce a ratio of two
     polynomials.  The tolerance TOL defaults to 'sqrt(eps)'.

     *Caution:* This is a numerically unstable algorithm and should not
     be used on large polynomials.

     Example code:

          polygcd (poly (1:8), poly (3:12)) - poly (3:8)
          => [ 0, 0, 0, 0, 0, 0, 0 ]
          deconv (poly (1:8), polygcd (poly (1:8), poly (3:12))) - poly(1:2)
          => [ 0, 0, 0 ]

     See also: poly, roots, conv, deconv, residue


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="polyint" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  polyint (P)
 -- Function File:  polyint (P, K)
     Return the coefficients of the integral of the polynomial whose
     coefficients are represented by the vector P.  The variable K is
     the constant of integration, which by default is set to zero.

     See also: polyder, polyval


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="polyout" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  polyout (C)
 -- Function File:  polyout (C, X)
 -- Function File: STR = polyout (...)
     Write formatted polynomial

          c(x) = c(1) * x^n + ... + c(n) x + c(n+1)

     and return it as a string or write it to the screen (if NARGOUT is
     zero).  X defaults to the string &quot;s&quot;.

     See also: polyreduce


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="polyreduce" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  polyreduce (C)
     Reduce a polynomial coefficient vector to a minimum number of
     terms by stripping off any leading zeros.

     See also: polyout


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="polyval" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: Y = polyval (P, X)
 -- Function File: Y = polyval (P, X, [], MU)
     Evaluate the polynomial P at the specified values of X.  When MU
     is present, evaluate the polynomial for (X-MU(1))/MU(2).  If X is
     a vector or matrix, the polynomial is evaluated for each of the
     elements of X.

 -- Function File: [Y, DY] = polyval (P, X, S)
 -- Function File: [Y, DY] = polyval (P, X, S, MU)
     In addition to evaluating the polynomial, the second output
     represents the prediction interval, Y +/- DY, which contains at
     least 50% of the future predictions.  To calculate the prediction
     interval, the structured variable S, originating from 'polyfit',
     must be supplied.

     See also: polyvalm, polyaffine, polyfit, roots, poly


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="polyvalm" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  polyvalm (C, X)
     Evaluate a polynomial in the matrix sense.

     'polyvalm (C, X)' will evaluate the polynomial in the matrix
     sense, i.e., matrix multiplication is used instead of element by
     element multiplication as used in 'polyval'.

     The argument X must be a square matrix.

     See also: polyval, roots, poly


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="popen" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: FID = popen (COMMAND, MODE)
     Start a process and create a pipe.  The name of the command to run
     is given by COMMAND.  The file identifier corresponding to the
     input or output stream of the process is returned in FID.  The
     argument MODE may be

    &quot;r&quot;
          The pipe will be connected to the standard output of the
          process, and open for reading.

    &quot;w&quot;
          The pipe will be connected to the standard input of the
          process, and open for writing.

     For example:

          fid = popen ('ls -ltr / | tail -3', 'r');
          while (ischar (s = fgets (fid)))
           fputs (stdout, s);
          endwhile
              -| drwxr-xr-x  33 root  root  3072 Feb 15 13:28 etc
              -| drwxr-xr-x   3 root  root  1024 Feb 15 13:28 lib
              -| drwxrwxrwt  15 root  root  2048 Feb 17 14:53 tmp

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="popen2" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: [IN, OUT, PID] = popen2 (COMMAND, ARGS)
     Start a subprocess with two-way communication.  The name of the
     process is given by COMMAND, and ARGS is an array of strings
     containing options for the command.  The file identifiers for the
     input and output streams of the subprocess are returned in IN and
     OUT.  If execution of the command is successful, PID contains the
     process ID of the subprocess.  Otherwise, PID is -1.

     For example:

          [in, out, pid] = popen2 ('sort', '-r');
          fputs (in, 'these\nare\nsome\nstrings\n');
          fclose (in);
          EAGAIN = errno ('EAGAIN');
          done = false;
          do
           s = fgets (out);
           if (ischar (s))
             fputs (stdout, s);
           elseif (errno () == EAGAIN)
             sleep (0.1);
             fclear (out);
           else
             done = true;
           endif
          until (done)
          fclose (out);
          waitpid (pid);
 ...

     USE help popen2 FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="postpad" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  postpad (X, L)
 -- Function File:  postpad (X, L, C)
 -- Function File:  postpad (X, L, C, DIM)
     Append the scalar value C to the vector X until it is of length L.
     If C is not given, a value of 0 is used.

     If 'length (X) &gt; L', elements from the end of X are removed until
     a vector of length L is obtained.

     If X is a matrix, elements are appended or removed from each row.

     If the optional argument DIM is given, operate along this
     dimension.

     See also: prepad, cat, resize


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="pow2" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  pow2 (X)
 -- Mapping Function:  pow2 (F, E)
     With one argument, computes 2 .^ x for each element of X.

     With two arguments, returns f .* (2 .^ e).

     See also: log2, nextpow2


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="power" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  power (X, Y)
     Return the element-by-element operation of X raised to the Y
     power.  If several complex results are possible, returns the one
     with smallest non-negative argument (angle).  Use 'realpow',
     'realsqrt', 'cbrt', or 'nthroot' if a real result is preferred.

     This function and x .^ y are equivalent.

     See also: mpower, realpow, realsqrt, cbrt, nthroot


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="powerset" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  powerset (A)
 -- Function File:  powerset (A, 'rows')
     Return a cell array containing all subsets of the set A.


   See also: unique, union, setxor, setdiff, ismember

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="ppder" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: ppd = ppder (pp)
 -- Function File: ppd = ppder (pp, m)
     Compute the piecewise M-th derivative of a piecewise polynomial
     struct PP.  If M is omitted the first derivative is calculated.

     See also: mkpp, ppval, ppint


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="ppint" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: PPI = ppint (PP)
 -- Function File: PPI = ppint (PP, C)
     Compute the integral of the piecewise polynomial struct PP.  C, if
     given, is the constant of integration.

     See also: mkpp, ppval, ppder


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="ppjumps" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: JUMPS = ppjumps (PP)
     Evaluate the boundary jumps of a piecewise polynomial.  If there
     are n intervals, and the dimensionality of PP is d, the resulting
     array has dimensions '[d, n-1]'.

     See also: mkpp


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="ppplot" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [P, Y] = ppplot (X, DIST, PARAMS)
     Perform a PP-plot (probability plot).

     If F is the CDF of the distribution DIST with parameters PARAMS
     and X a sample vector of length N, the PP-plot graphs ordinate
     Y(I) = F (I-th largest element of X) versus abscissa P(I) = (I -
     0.5)/N.  If the sample comes from F, the pairs will approximately
     follow a straight line.

     The default for DIST is the standard normal distribution.  The
     optional argument PARAMS contains a list of parameters of DIST.
     For example, for a probability plot of the uniform distribution on
     [2,4] and X, use

          ppplot (x, 'unif', 2, 4)

     DIST can be any string for which a function DIST_CDF that
     calculates the CDF of distribution DIST exists.

     If no output arguments are given, the data are plotted directly.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="ppval" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: YI = ppval (PP, XI)
     Evaluate the piecewise polynomial structure PP at the points XI.
     If PP describes a scalar polynomial function, the result is an
     array of the same shape as XI.  Otherwise, the size of the result
     is '[pp.dim, length(XI)]' if XI is a vector, or '[pp.dim,
     size(XI)]' if it is a multi-dimensional array.

     See also: mkpp, unmkpp, spline, pchip


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="pqpnonneg" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: X = pqpnonneg (C, D)
 -- Function File: X = pqpnonneg (C, D, X0)
 -- Function File: [X, MINVAL] = pqpnonneg (...)
 -- Function File: [X, MINVAL, EXITFLAG] = pqpnonneg (...)
 -- Function File: [X, MINVAL, EXITFLAG, OUTPUT] = pqpnonneg (...)
 -- Function File: [X, MINVAL, EXITFLAG, OUTPUT, LAMBDA] = pqpnonneg
          (...)
     Minimize '1/2*x'*c*x + d'*x' subject to 'X &gt;= 0'.  C and D must be
     real, and C must be symmetric and positive definite.  X0 is an
     optional initial guess for X.

     Outputs:
        * minval

          The minimum attained model value, 1/2*xmin'*c*xmin + d'*xmin

        * exitflag

          An indicator of convergence.  0 indicates that the iteration
          count was exceeded, and therefore convergence was not
          reached; >0 indicates that the algorithm converged.  (The
          algorithm is stable and will converge given enough
          iterations.)

        * output

          A structure with two fields:
           ...

     USE help pqpnonneg FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="prctile" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: Q = prctile (X)
 -- Function File: Q = prctile (X, P)
 -- Function File: Q = prctile (X, P, DIM)
     For a sample X, compute the quantiles, Q, corresponding to the
     cumulative probability values, P, in percent.  All non-numeric
     values (NaNs) of X are ignored.

     If X is a matrix, compute the percentiles for each column and
     return them in a matrix, such that the i-th row of Y contains the
     P(i)th percentiles of each column of X.

     If P is unspecified, return the quantiles for '[0 25 50 75 100]'.
     The optional argument DIM determines the dimension along which the
     percentiles are calculated.  If DIM is omitted, and X is a vector
     or matrix, it defaults to 1 (column-wise quantiles).  When X is an
     N-D array, DIM defaults to the first non-singleton dimension.

     See also: quantile


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="prepad" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  prepad (X, L)
 -- Function File:  prepad (X, L, C)
 -- Function File:  prepad (X, L, C, DIM)
     Prepend the scalar value C to the vector X until it is of length
     L.  If C is not given, a value of 0 is used.

     If 'length (X) &gt; L', elements from the beginning of X are removed
     until a vector of length L is obtained.

     If X is a matrix, elements are prepended or removed from each row.

     If the optional argument DIM is given, operate along this
     dimension.

     See also: postpad, cat, resize


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="primes" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  primes (N)
     Return all primes up to N.

     The algorithm used is the Sieve of Eratosthenes.

     Note that if you need a specific number of primes you can use the
     fact that the distance from one prime to the next is, on average,
     proportional to the logarithm of the prime.  Integrating, one finds
     that there are about k primes less than k*log(5*k).

     See also: list_primes, isprime


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="print" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  print ()
 -- Function File:  print (OPTIONS)
 -- Function File:  print (FILENAME, OPTIONS)
 -- Function File:  print (H, FILENAME, OPTIONS)
     Print a graph, or save it to a file

     FILENAME defines the file name of the output file.  If the file
     name has no suffix, one is inferred from the specified device and
     appended to the file name.  If no filename is specified, the
     output is sent to the printer.

     H specifies the figure handle.  If no handle is specified the
     handle for the current figure is used.

     OPTIONS:

    '-fH'
          Specify the handle, H, of the figure to be printed.  The
          default is the current figure.

    '-PPRINTER'
          Set the PRINTER name to which the graph is sent if no
          FILENAME is specified.

    '-GGHOSTSCRIPT_COMMAND'
          Specify the command for calling Ghostscript.  For Unix and
          Windows, the defaults are 'gs' and 'gswin32c', respectively.

    '-color'
    '-mono'
 ...

     USE help print FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="print_empty_dimensions" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: VAL = print_empty_dimensions ()
 -- Built-in Function: OLD_VAL = print_empty_dimensions (NEW_VAL)
 -- Built-in Function:  print_empty_dimensions (NEW_VAL, 'local')
     Query or set the internal variable that controls whether the
     dimensions of empty matrices are printed along with the empty
     matrix symbol, '[]'.  For example, the expression

          zeros (3, 0)

     will print

          ans = [](3x0)

     When called from inside a function with the 'local' option, the
     variable is changed locally for the function and any subroutines
     it calls.  The original variable value is restored when exiting
     the function.

     See also: format


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="print_struct_array_contents" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: VAL = print_struct_array_contents ()
 -- Built-in Function: OLD_VAL = print_struct_array_contents (NEW_VAL)
 -- Built-in Function:  print_struct_array_contents (NEW_VAL, 'local')
     Query or set the internal variable that specifies whether to print
     struct array contents.  If true, values of struct array elements
     are printed.  This variable does not affect scalar structures.
     Their elements are always printed.  In both cases, however,
     printing will be limited to the number of levels specified by
     STRUCT_LEVELS_TO_PRINT.

     When called from inside a function with the 'local' option, the
     variable is changed locally for the function and any subroutines
     it calls.  The original variable value is restored when exiting
     the function.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="print_usage" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  print_usage ()
 -- Function File:  print_usage (NAME)
     Print the usage message for a function.  When called with no input
     arguments the 'print_usage' function displays the usage message of
     the currently executing function.

     See also: help


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="printf" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  printf (TEMPLATE, ...)
     Print optional arguments under the control of the template string
     TEMPLATE to the stream 'stdout' and return the number of
     characters printed.

     See the Formatted Output section of the GNU Octave manual for a
     complete description of the syntax of the template string.

     See also: fprintf, sprintf, scanf


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="prism" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: MAP = prism ()
 -- Function File: MAP = prism (N)
     Create color colormap.  This colormap cycles through red, orange,
     yellow, green, blue and violet with each index change.  The
     argument N must be a scalar.  If unspecified, the length of the
     current colormap, or 64, is used.

     See also: colormap


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="probit" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  probit (P)
     For each component of P, return the probit (the quantile of the
     standard normal distribution) of P.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="prod" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  prod (X)
 -- Built-in Function:  prod (X, DIM)
     Product of elements along dimension DIM.  If DIM is omitted, it
     defaults to the first non-singleton dimension.

     See also: cumprod, sum


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="profexplore" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  profexplore (DATA)
     Interactively explore hierarchical profiler output.

     Assuming DATA is the structure with profile data returned by
     'profile ('info')', this command opens an interactive prompt that
     can be used to explore the call-tree.  Type 'help' to get a list
     of possible commands.

     See also: profile, profshow


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="profile" func="yes">
            <Overload retVal="">
                <Param name="
 -- Command:  profile on
 -- Command:  profile off
 -- Command:  profile resume
 -- Command:  profile clear
 -- Function File: S = profile ('status')
 -- Function File: T = profile ('info')
     Control the built-in profiler.

    'profile on'
          Start the profiler, clearing all previously collected data if
          there is any.

    'profile off'
          Stop profiling.  The collected data can later be retrieved
          and examined with calls like 'S = profile ('info')'.

    'profile clear'
          Clear all collected profiler data.

    'profile resume'
          Restart profiling without cleaning up the old data and instead
          all newly collected statistics are added to the already
          existing ones.

    'S = profile ('status')'
          Return a structure filled with certain information about the
          current status of the profiler.  At the moment, the only
          field is 'ProfilerStatus' which is either 'on' or 'off'.

    'T = profile ('in...

     USE help profile FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="profshow" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  profshow (DATA)
 -- Function File:  profshow (DATA, N)
     Show flat profiler results.

     This command prints out profiler data as a flat profile.  DATA is
     the structure returned by 'profile ('info')'.  If N is given, it
     specifies the number of functions to show in the profile;
     functions are sorted in descending order by total time spent in
     them.  If there are more than N included in the profile, those
     will not be shown.  N defaults to 20.

     The attribute column shows 'R' for recursive functions and nothing
     otherwise.

     See also: profexplore, profile


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="program_invocation_name" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  program_invocation_name ()
     Return the name that was typed at the shell prompt to run Octave.

     If executing a script from the command line (e.g., 'octave foo.m')
     or using an executable Octave script, the program name is set to
     the name of the script.  *Note Executable Octave Programs::, for
     an example of how to create an executable Octave script.

     See also: program_name


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="program_name" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  program_name ()
     Return the last component of the value returned by
     'program_invocation_name'.

     See also: program_invocation_name


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="prop_test_2" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [PVAL, Z] = prop_test_2 (X1, N1, X2, N2, ALT)
     If X1 and N1 are the counts of successes and trials in one sample,
     and X2 and N2 those in a second one, test the null hypothesis that
     the success probabilities P1 and P2 are the same.  Under the null,
     the test statistic Z approximately follows a standard normal
     distribution.

     With the optional argument string ALT, the alternative of interest
     can be selected.  If ALT is &quot;!=&quot; or &quot;&lt;%gt;&quot;, the null is tested
     against the two-sided alternative P1 != P2.  If ALT is &quot;&gt;&quot;, the
     one-sided alternative P1 &gt; P2 is used.  Similarly for &quot;&lt;&quot;, the
     one-sided alternative P1 &lt; P2 is used.  The default is the
     two-sided case.

     The p-value of the test is returned in PVAL.

     If no output argument is given, the p-value of the test is
     displayed.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="PS1" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: VAL = PS1 ()
 -- Built-in Function: OLD_VAL = PS1 (NEW_VAL)
 -- Built-in Function:  PS1 (NEW_VAL, 'local')
     Query or set the primary prompt string.  When executing
     interactively, Octave displays the primary prompt when it is ready
     to read a command.

     The default value of the primary prompt string is &quot;\s:\#> &quot;.  To
     change it, use a command like

          PS1 ('\\u@\\H> ')

     which will result in the prompt 'boris@kremvax> ' for the user
     'boris' logged in on the host 'kremvax.kgb.su'.  Note that two
     backslashes are required to enter a backslash into a double-quoted
     character string.  *Note Strings::.

     You can also use ANSI escape sequences if your terminal supports
     them.  This can be useful for coloring the prompt.  For example,

          PS1 ('\\[\\033[01;31m\\]\\s:\\#> \\[\\033[0m\]')

     will give the default Octave prompt a red coloring.

     When called from inside a function with the 'local' option, t...

     USE help PS1 FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="PS2" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: VAL = PS2 ()
 -- Built-in Function: OLD_VAL = PS2 (NEW_VAL)
 -- Built-in Function:  PS2 (NEW_VAL, 'local')
     Query or set the secondary prompt string.  The secondary prompt is
     printed when Octave is expecting additional input to complete a
     command.  For example, if you are typing a 'for' loop that spans
     several lines, Octave will print the secondary prompt at the
     beginning of each line after the first.  The default value of the
     secondary prompt string is &quot;&gt; &quot;.

     When called from inside a function with the 'local' option, the
     variable is changed locally for the function and any subroutines
     it calls.  The original variable value is restored when exiting
     the function.

     See also: PS1, PS4


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="PS4" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: VAL = PS4 ()
 -- Built-in Function: OLD_VAL = PS4 (NEW_VAL)
 -- Built-in Function:  PS4 (NEW_VAL, 'local')
     Query or set the character string used to prefix output produced
     when echoing commands is enabled.  The default value is &quot;+ &quot;.
     *Note Diary and Echo Commands::, for a description of echoing
     commands.

     When called from inside a function with the 'local' option, the
     variable is changed locally for the function and any subroutines
     it calls.  The original variable value is restored when exiting
     the function.

     See also: echo, echo_executing_commands, PS1, PS2


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="putenv" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  putenv (VAR, VALUE)
 -- Built-in Function:  setenv (VAR, VALUE)
     Set the value of the environment variable VAR to VALUE.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="puts" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  puts (STRING)
     Write a string to the standard output with no formatting.

     Return a non-negative number on success and EOF on error.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="pwd" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  pwd ()
     Return the current working directory.

     See also: dir, ls


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="python" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [OUTPUT, STATUS] = python (SCRIPTFILE)
 -- Function File: [OUTPUT, STATUS] = python (SCRIPTFILE, ARGUMENT1,
          ARGUMENT2, ...)
     Invoke python script SCRIPTFILE with possibly a list of command
     line arguments.  Returns output in OUTPUT and status in STATUS.

     See also: system


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="pzmap" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: pzmap (SYS)
 -- Function File: [P, Z] = pzmap (SYS)
     Plot the poles and zeros of an LTI system in the complex plane.
     If no output arguments are given, the result is plotted on the
     screen.  Otherwise, the poles and zeros are computed and returned.

     *Inputs*
    SYS
          LTI model.

     *Outputs*
    P
          Poles of SYS.

    Z
          Transmission zeros of SYS.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="qp" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [X, OBJ, INFO, LAMBDA] = qp (X0, H)
 -- Function File: [X, OBJ, INFO, LAMBDA] = qp (X0, H, Q)
 -- Function File: [X, OBJ, INFO, LAMBDA] = qp (X0, H, Q, A, B)
 -- Function File: [X, OBJ, INFO, LAMBDA] = qp (X0, H, Q, A, B, LB, UB)
 -- Function File: [X, OBJ, INFO, LAMBDA] = qp (X0, H, Q, A, B, LB, UB,
          A_LB, A_IN, A_UB)
 -- Function File: [X, OBJ, INFO, LAMBDA] = qp (..., OPTIONS)
     Solve the quadratic program

          min 0.5 x'*H*x + x'*q
           x

     subject to

          A*x = b
          lb &lt;= x &lt;= ub
          A_lb &lt;= A_in*x &lt;= A_ub

     using a null-space active-set method.

     Any bound (A, B, LB, UB, A_LB, A_UB) may be set to the empty
     matrix ('[]') if not present.  If the initial guess is feasible
     the algorithm is faster.

    OPTIONS
          An optional structure containing the following parameter(s)
          used to define the behavior of the solver.  Missing elements
          in the structure take on default values, so...

     USE help qp FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="qqplot" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [Q, S] = qqplot (X)
 -- Function File: [Q, S] = qqplot (X, DIST)
 -- Function File: [Q, S] = qqplot (X, DIST, PARAMS)
 -- Function File:  qqplot (...)
     Perform a QQ-plot (quantile plot).

     If F is the CDF of the distribution DIST with parameters PARAMS
     and G its inverse, and X a sample vector of length N, the QQ-plot
     graphs ordinate S(I) = I-th largest element of x versus abscissa
     Q(If) = G((I - 0.5)/N).

     If the sample comes from F, except for a transformation of location
     and scale, the pairs will approximately follow a straight line.

     The default for DIST is the standard normal distribution.  The
     optional argument PARAMS contains a list of parameters of DIST.
     For example, for a quantile plot of the uniform distribution on
     [2,4] and X, use

          qqplot (x, 'unif', 2, 4)

     DIST can be any string for which a function DISTINV or DIST_INV
     exists that calculates the inverse CDF of distribution DIST.

     ...

     USE help qqplot FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="qr" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: [Q, R, P] = qr (A)
 -- Loadable Function: [Q, R, P] = qr (A, '0')
 -- Loadable Function: [C, R] = qr (A, B)
 -- Loadable Function: [C, R] = qr (A, B, '0')
     Compute the QR factorization of A, using standard LAPACK
     subroutines.  For example, given the matrix 'A = [1, 2; 3, 4]',

          [Q, R] = qr (A)

     returns

          Q =

           -0.31623  -0.94868
           -0.94868   0.31623

          R =

           -3.16228  -4.42719
            0.00000  -0.63246

     The 'qr' factorization has applications in the solution of least
     squares problems

          'min norm(A x - b)'

     for overdetermined systems of equations (i.e., A is a tall, thin
     matrix).  The QR factorization is 'Q * Q = A' where Q is an
     orthogonal matrix and R is upper triangular.

     If given a second argument of '0', 'qr' returns an economy-sized
     QR factorization, omitting zero rows of R and the corresponding
     columns of Q.

     If the matrix A is full...

     USE help qr FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="qrdelete" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: [Q1, R1] = qrdelete (Q, R, J, ORIENT)
     Given a QR factorization of a real or complex matrix A = Q*R,
     Q unitary and R upper trapezoidal, return the QR factorization of
     [A(:,1:j-1) A(:,j+1:n)], i.e., A with one column deleted (if
     ORIENT is 'col'), or the QR factorization of
     [A(1:j-1,:);A(j+1:n,:)], i.e., A with one row deleted (if   ORIENT
     is 'row').

     The default value of ORIENT is 'col'.

     If ORIENT is &quot;col&quot;, J may be an index vector resulting in the
     QR factorization of a matrix B such that A(:,J) = [] gives B.
     Notice that the latter case is done as a sequence of k deletions;
     thus, for k large enough, it will be both faster and more accurate
     to recompute the factorization from scratch.

     If ORIENT is &quot;col&quot;, the QR factorization supplied may be either
     full (Q is square) or economized (R is square).

     If ORIENT is &quot;row&quot;, full factorization is needed.

     See also: qr, qrinsert, qrupdate

...

     USE help qrdelete FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="qrinsert" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: [Q1, R1] = qrinsert (Q, R, J, X, ORIENT)
     Given a QR factorization of a real or complex matrix A = Q*R,
     Q unitary and R upper trapezoidal, return the QR factorization of
     [A(:,1:j-1) x A(:,j:n)], where U is a column vector to be inserted
     into A (if ORIENT is &quot;col&quot;), or the QR factorization of
     [A(1:j-1,:);x;A(:,j:n)], where X is a row vector to be inserted
     into A (if ORIENT is &quot;row&quot;).

     The default value of ORIENT is &quot;col&quot;.  If ORIENT is &quot;col&quot;, U
     may be a matrix and J an index vector resulting in the
     QR factorization of a matrix B such that B(:,J) gives U and
     B(:,J) = [] gives A.  Notice that the latter case is done as a
     sequence of k insertions; thus, for k large enough, it will be
     both faster and more accurate to recompute the factorization from
     scratch.

     If ORIENT is &quot;col&quot;, the QR factorization supplied may be either
     full (Q is square) or economized (R is square).

     If ORIENT ...

     USE help qrinsert FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="qrshift" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: [Q1, R1] = qrshift (Q, R, I, J)
     Given a QR factorization of a real or complex matrix A = Q*R,
     Q unitary and R upper trapezoidal, return the QR factorization of
     A(:,p), where p is the permutation
     'p = [1:i-1, shift(i:j, 1), j+1:n]' if I &lt; J
     or
     'p = [1:j-1, shift(j:i,-1), i+1:n]' if J &lt; I.
     See also: qr, qrinsert, qrdelete


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="qrupdate" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: [Q1, R1] = qrupdate (Q, R, U, V)
     Given a QR factorization of a real or complex matrix A = Q*R,
     Q unitary and R upper trapezoidal, return the QR factorization of
     A + U*V', where U and V are column vectors (rank-1 update) or
     matrices with equal number of columns (rank-k update).  Notice
     that the latter case is done as a sequence of rank-1 updates;
     thus, for k large enough, it will be both faster and more accurate
     to recompute the factorization from scratch.

     The QR factorization supplied may be either full (Q is square) or
     economized (R is square).

     See also: qr, qrinsert, qrdelete


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="quad" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: Q = quad (F, A, B)
 -- Loadable Function: Q = quad (F, A, B, TOL)
 -- Loadable Function: Q = quad (F, A, B, TOL, SING)
 -- Loadable Function: [Q, IER, NFUN, ERR] = quad (...)
     Numerically evaluate the integral of F from A to B using Fortran
     routines from QUADPACK.  F is a function handle, inline function,
     or a string containing the name of the function to evaluate.  The
     function must have the form 'y = f (x)' where Y and X are scalars.

     A and B are the lower and upper limits of integration.  Either or
     both may be infinite.

     The optional argument TOL is a vector that specifies the desired
     accuracy of the result.  The first element of the vector is the
     desired absolute tolerance, and the second element is the desired
     relative tolerance.  To choose a relative test only, set the
     absolute tolerance to zero.  To choose an absolute test only, set
     the relative tolerance to zero.  Both tolerances default to
     '...

     USE help quad FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="quad_options" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function:  quad_options ()
 -- Loadable Function: val = quad_options (OPT)
 -- Loadable Function:  quad_options (OPT, VAL)
     Query or set options for the function 'quad'.  When called with no
     arguments, the names of all available options and their current
     values are displayed.  Given one argument, return the value of the
     corresponding option.  When called with two arguments,
     'quad_options' set the option OPT to value VAL.

     Options include

    &quot;absolute tolerance&quot;
          Absolute tolerance; may be zero for pure relative error test.

    &quot;relative tolerance&quot;
          Non-negative relative tolerance.  If the absolute tolerance
          is zero, the relative tolerance must be greater than or equal
          to 'max (50*eps, 0.5e-28)'.

    &quot;single precision absolute tolerance&quot;
          Absolute tolerance for single precision; may be zero for pure
          relative error test.

    &quot;single precision relative tolerance&quot;
          Non-n...

     USE help quad_options FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="quadcc" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: Q = quadcc (F, A, B)
 -- Function File: Q = quadcc (F, A, B, TOL)
 -- Function File: Q = quadcc (F, A, B, TOL, SING)
 -- Function File: [Q, ERR, NR_POINTS] = quadcc (...)
     Numerically evaluate the integral of F from A to B using the
     doubly-adaptive Clenshaw-Curtis quadrature described by P. Gonnet
     in 'Increasing the Reliability of Adaptive Quadrature Using
     Explicit Interpolants'.  F is a function handle, inline function,
     or string containing the name of the function to evaluate.  The
     function F must be vectorized and must return a vector of output
     values if given a vector of input values.  For example,

            f = @(x) x .* sin (1./x) .* sqrt (abs (1 - x));

     which uses the element-by-element 'dot' form for all operators.

     A and B are the lower and upper limits of integration.  Either or
     both limits may be infinite.  'quadcc' handles an inifinite limit
     by substituting the variable of integration with 'x=tan(pi...

     USE help quadcc FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="quadgk" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: Q = quadgk (F, A, B)
 -- Function File: Q = quadgk (F, A, B, ABSTOL)
 -- Function File: Q = quadgk (F, A, B, ABSTOL, TRACE)
 -- Function File: Q = quadgk (F, A, B, PROP, VAL, ...)
 -- Function File: [Q, ERR] = quadgk (...)
     Numerically evaluate the integral of F from A to B using adaptive
     Gauss-Konrod quadrature.  F is a function handle, inline function,
     or string containing the name of the function to evaluate.  The
     formulation is based on a proposal by L.F. Shampine, &quot;Vectorized
     adaptive quadrature in MATLAB', Journal of Computational and
     Applied Mathematics, pp131-140, Vol 211, Issue 2, Feb 2008' where
     all function evaluations at an iteration are calculated with a
     single call to F.  Therefore, the function F must be vectorized
     and must accept a vector of input values X and return an output
     vector representing the function evaluations at the given values
     of X.

     A and B are the lower and upper limits of int...

     USE help quadgk FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="quadl" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: Q = quadl (F, A, B)
 -- Function File: Q = quadl (F, A, B, TOL)
 -- Function File: Q = quadl (F, A, B, TOL, TRACE)
 -- Function File: Q = quadl (F, A, B, TOL, TRACE, P1, P2, ...)
     Numerically evaluate the integral of F from A to B using an
     adaptive Lobatto rule.  F is a function handle, inline function,
     or string containing the name of the function to evaluate.  The
     function F must be vectorized and return a vector of output values
     if given a vector of input values.

     A and B are the lower and upper limits of integration.  Both
     limits must be finite.

     The optional argument TOL defines the relative tolerance with which
     to perform the integration.  The default value is 'eps'.

     The algorithm used by 'quadl' involves recursively subdividing the
     integration interval.  If TRACE is defined then for each
     subinterval display: (1) the left end of the subinterval, (2) the
     length of the subinterval, (3) the approxima...

     USE help quadl FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="quadv" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: Q = quadv (F, A, B)
 -- Function File: Q = quadv (F, A, B, TOL)
 -- Function File: Q = quadv (F, A, B, TOL, TRACE)
 -- Function File: Q = quadv (F, A, B, TOL, TRACE, P1, P2, ...)
 -- Function File: [Q, NFUN] = quadv (...)
     Numerically evaluate the integral of F from A to B using an
     adaptive Simpson's rule.  F is a function handle, inline function,
     or string containing the name of the function to evaluate.
     'quadv' is a vectorized version of 'quad' and the function defined
     by F must accept a scalar or vector as input and return a scalar,
     vector, or array as output.

     A and B are the lower and upper limits of integration.  Both
     limits must be finite.

     The optional argument TOL defines the tolerance used to stop the
     adaptation procedure.  The default value is 1e^-6.

     The algorithm used by 'quadv' involves recursively subdividing the
     integration interval and applying Simpson's rule on each
     subinterval.  If TRA...

     USE help quadv FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="quantile" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: Q = quantile (X, P)
 -- Function File: Q = quantile (X, P, DIM)
 -- Function File: Q = quantile (X, P, DIM, METHOD)
     For a sample, X, calculate the quantiles, Q, corresponding to the
     cumulative probability values in P.  All non-numeric values (NaNs)
     of X are ignored.

     If X is a matrix, compute the quantiles for each column and return
     them in a matrix, such that the i-th row of Q contains the P(i)th
     quantiles of each column of X.

     The optional argument DIM determines the dimension along which the
     quantiles are calculated.  If DIM is omitted, and X is a vector or
     matrix, it defaults to 1 (column-wise quantiles).  If X is an N-D
     array, DIM defaults to the first non-singleton dimension.

     The methods available to calculate sample quantiles are the nine
     methods used by R (http://www.r-project.org/).  The default value
     is METHOD = 5.

     Discontinuous sample quantile methods 1, 2, and 3

       1. Method 1: I...

     USE help quantile FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="quit" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  exit (STATUS)
 -- Built-in Function:  quit (STATUS)
     Exit the current Octave session.  If the optional integer value
     STATUS is supplied, pass that value to the operating system as the
     Octave's exit status.  The default value is zero.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="quiver" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  quiver (U, V)
 -- Function File:  quiver (X, Y, U, V)
 -- Function File:  quiver (..., S)
 -- Function File:  quiver (..., STYLE)
 -- Function File:  quiver (..., 'filled')
 -- Function File:  quiver (H, ...)
 -- Function File: H = quiver (...)
     Plot the '(U, V)' components of a vector field in an '(X, Y)'
     meshgrid.  If the grid is uniform, you can specify X and Y as
     vectors.

     If X and Y are undefined they are assumed to be '(1:M, 1:N)' where
     '[M, N] = size(U)'.

     The variable S is a scalar defining a scaling factor to use for
     the arrows of the field relative to the mesh spacing.  A value of 0
     disables all scaling.  The default value is 1.

     The style to use for the plot can be defined with a line style
     STYLE in a similar manner to the line styles used with the 'plot'
     command.  If a marker is specified then markers at the grid points
     of the vectors are printed rather than arrows.  If the argument
     'filled'...

     USE help quiver FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="quiver3" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  quiver3 (U, V, W)
 -- Function File:  quiver3 (X, Y, Z, U, V, W)
 -- Function File:  quiver3 (..., S)
 -- Function File:  quiver3 (..., STYLE)
 -- Function File:  quiver3 (..., 'filled')
 -- Function File:  quiver3 (H, ...)
 -- Function File: H = quiver3 (...)
     Plot the '(U, V, W)' components of a vector field in an '(X, Y),
     Z' meshgrid.  If the grid is uniform, you can specify X, Y Z as
     vectors.

     If X, Y and Z are undefined they are assumed to be '(1:M, 1:N,
     1:P)' where '[M, N] = size(U)' and 'P = max (size (W))'.

     The variable S is a scalar defining a scaling factor to use for
     the arrows of the field relative to the mesh spacing.  A value of 0
     disables all scaling.  The default value is 1.

     The style to use for the plot can be defined with a line style
     STYLE in a similar manner to the line styles used with the 'plot'
     command.  If a marker is specified then markers at the grid points
     of the vectors are prin...

     USE help quiver3 FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="qz" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: LAMBDA = qz (A, B)
 -- Loadable Function: LAMBDA = qz (A, B, OPT)
     QZ decomposition of the generalized eigenvalue problem (A x = s B
     x).  There are three ways to call this function:
       1. 'LAMBDA = qz (A, B)'

          Computes the generalized eigenvalues LAMBDA of (A - s B).

       2. '[AA, BB, Q, Z, V, W, LAMBDA] = qz (A, B)'

          Computes QZ decomposition, generalized eigenvectors, and
          generalized eigenvalues of (A - s B)


                  A * V = B * V * diag (LAMBDA)
                  W' * A = diag (LAMBDA) * W' * B
                  AA = Q * A * Z, BB = Q * B * Z

          with Q and Z orthogonal (unitary)= I

       3. '[AA,BB,Z{, LAMBDA}] = qz (A, B, OPT)'

          As in form [2], but allows ordering of generalized eigenpairs
          for (e.g.) solution of discrete time algebraic Riccati
          equations.  Form 3 is not available for complex matrices, and
          does not compute the generalized eigenvectors V, W...

     USE help qz FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="qzhess" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [AA, BB, Q, Z] = qzhess (A, B)
     Compute the Hessenberg-triangular decomposition of the matrix
     pencil '(A, B)', returning 'AA = Q * A * Z', 'BB = Q * B * Z',
     with Q and Z orthogonal.  For example:

          [aa, bb, q, z] = qzhess ([1, 2; 3, 4], [5, 6; 7, 8])
               => aa = [ -3.02244, -4.41741;  0.92998,  0.69749 ]
               => bb = [ -8.60233, -9.99730;  0.00000, -0.23250 ]
               =>  q = [ -0.58124, -0.81373; -0.81373,  0.58124 ]
               =>  z = [ 1, 0; 0, 1 ]

     The Hessenberg-triangular decomposition is the first step in Moler
     and Stewart's QZ decomposition algorithm.

     Algorithm taken from Golub and Van Loan, 'Matrix Computations, 2nd
     edition'.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="rainbow" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: MAP = rainbow ()
 -- Function File: MAP = rainbow (N)
     Create color colormap.  This colormap ranges from red through
     orange, yellow, green, blue, to violet.  The argument N must be a
     scalar.  If unspecified, the length of the current colormap, or
     64, is used.

     See also: colormap


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="rand" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function:  rand (N)
 -- Loadable Function:  rand (N, M, ...)
 -- Loadable Function:  rand ([N M ...])
 -- Loadable Function: V = rand ('state')
 -- Loadable Function:  rand ('state', V)
 -- Loadable Function:  rand ('state', 'reset')
 -- Loadable Function: V = rand ('seed')
 -- Loadable Function:  rand ('seed', V)
 -- Loadable Function:  rand ('seed', 'reset')
     Return a matrix with random elements uniformly distributed on the
     interval (0, 1).  The arguments are handled the same as the
     arguments for 'eye'.

     You can query the state of the random number generator using the
     form

          v = rand ('state')

     This returns a column vector V of length 625.  Later, you can
     restore the random number generator to the state V using the form

          rand ('state', v)

     You may also initialize the state vector from an arbitrary vector
     of length &lt;= 625 for V.  This new state will be a hash based on the
     value of V, not V itself.

     B...

     USE help rand FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="rande" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function:  rande (N)
 -- Loadable Function:  rande (N, M, ...)
 -- Loadable Function:  rande ([N M ...])
 -- Loadable Function: V = rande ('state')
 -- Loadable Function:  rande ('state', V)
 -- Loadable Function:  rande ('state', 'reset')
 -- Loadable Function: V = rande ('seed')
 -- Loadable Function:  rande ('seed', V)
 -- Loadable Function:  rande ('seed', 'reset')
     Return a matrix with exponentially distributed random elements.
     The arguments are handled the same as the arguments for 'rand'.

     By default, 'randn' uses the Marsaglia and Tsang 'Ziggurat
     technique' to transform from a uniform to an exponential
     distribution.

     Reference: G. Marsaglia and W.W. Tsang, 'Ziggurat Method for
     Generating Random Variables', J. Statistical Software, vol 5, 2000,
     'http://www.jstatsoft.org/v05/i08/')

     See also: rand, randn, randg, randp


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="randg" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function:  randg (N)
 -- Loadable Function:  randg (N, M, ...)
 -- Loadable Function:  randg ([N M ...])
 -- Loadable Function: V = randg ('state')
 -- Loadable Function:  randg ('state', V)
 -- Loadable Function:  randg ('state', 'reset')
 -- Loadable Function: V = randg ('seed')
 -- Loadable Function:  randg ('seed', V)
 -- Loadable Function:  randg ('seed', 'reset')
     Return a matrix with 'gamma(A,1)' distributed random elements.
     The arguments are handled the same as the arguments for 'rand',
     except for the argument A.

     This can be used to generate many distributions:

    'gamma (a, b)' for 'a &gt; -1', 'b &gt; 0'
               r = b * randg (a)

    'beta (a, b)' for 'a &gt; -1', 'b &gt; -1'
               r1 = randg (a, 1)
               r = r1 / (r1 + randg (b, 1))

    'Erlang (a, n)'
               r = a * randg (n)

    'chisq (df)' for 'df &gt; 0'
               r = 2 * randg (df / 2)

    't (df)' for '0 &lt; df &lt; inf' (use randn if df is infinite)
           ...

     USE help randg FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="randi" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  randi (IMAX)
 -- Function File:  randi (IMAX, N)
 -- Function File:  randi (IMAX, M, N, ...)
 -- Function File:  randi ([IMIN IMAX], ...)
 -- Function File:  randi (..., 'CLASS')
     Return random integers in the range 1:IMAX.

     Additional arguments determine the shape of the return matrix.
     When no arguments are specified a single random integer is
     returned.  If one argument N is specified then a square matrix
     (N x N) is returned.  Two or more arguments will return a
     multi-dimensional matrix (M x N x ...).

     The integer range may optionally be described by a two element
     matrix with a lower and upper bound in which case the returned
     integers will be on the interval [IMIN, IMAX].

     The optional argument 'CLASS' will return a matrix of the requested
     type.  The default is 'double'.

     The following example returns 150 integers in the range 1-10.

          ri = randi (10, 150, 1)

     Implementation Note: 'randi' relie...

     USE help randi FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="randn" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function:  randn (N)
 -- Loadable Function:  randn (N, M, ...)
 -- Loadable Function:  randn ([N M ...])
 -- Loadable Function: V = randn ('state')
 -- Loadable Function:  randn ('state', V)
 -- Loadable Function:  randn ('state', 'reset')
 -- Loadable Function: V = randn ('seed')
 -- Loadable Function:  randn ('seed', V)
 -- Loadable Function:  randn ('seed', 'reset')
     Return a matrix with normally distributed random elements having
     zero mean and variance one.  The arguments are handled the same as
     the arguments for 'rand'.

     By default, 'randn' uses the Marsaglia and Tsang 'Ziggurat
     technique' to transform from a uniform to a normal distribution.

     Reference: G. Marsaglia and W.W. Tsang, 'Ziggurat Method for
     Generating Random Variables', J. Statistical Software, vol 5, 2000,
     'http://www.jstatsoft.org/v05/i08/')

     See also: rand, rande, randg, randp


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="randp" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function:  randp (L, N)
 -- Loadable Function:  randp (L, N, M, ...)
 -- Loadable Function:  randp (L, [N M ...])
 -- Loadable Function: V = randp ('state')
 -- Loadable Function:  randp ('state', V)
 -- Loadable Function:  randp ('state', 'reset')
 -- Loadable Function: V = randp ('seed')
 -- Loadable Function:  randp ('seed', V)
 -- Loadable Function:  randp ('seed', 'reset')
     Return a matrix with Poisson distributed random elements with mean
     value parameter given by the first argument, L.  The arguments are
     handled the same as the arguments for 'rand', except for the
     argument L.

     Five different algorithms are used depending on the range of L and
     whether or not L is a scalar or a matrix.

    For scalar L &lt;= 12, use direct method.
          W.H. Press, et al., 'Numerical Recipes in C', Cambridge
          University Press, 1992.

    For scalar L &gt; 12, use rejection method.[1]
          W.H. Press, et al., 'Numerical Recipes in C', Cambridge
...

     USE help randp FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="randperm" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function:  randperm (N)
 -- Loadable Function:  randperm (N, M)
     Return a row vector containing a random permutation of '1:N'.  If
     M is supplied, return M unique entries, sampled without
     replacement from '1:N'.  The complexity is O(N) in memory and O(M)
     in time, unless M &lt; N/5, in which case O(M) memory is used as
     well.  The randomization is performed using rand(). All
     permutations are equally likely.

     See also: perms


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="range" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  range (X)
 -- Function File:  range (X, DIM)
     Return the range, i.e., the difference between the maximum and the
     minimum of the input data.  If X is a vector, the range is
     calculated over the elements of X.  If X is a matrix, the range is
     calculated over each column of X.

     If the optional argument DIM is given, operate along this
     dimension.

     The range is a quickly computed measure of the dispersion of a
     data set, but is less accurate than 'iqr' if there are outlying
     data points.

     See also: iqr, std


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="rank" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  rank (A)
 -- Function File:  rank (A, TOL)
     Compute the rank of A, using the singular value decomposition.
     The rank is taken to be the number of singular values of A that
     are greater than the specified tolerance TOL.  If the second
     argument is omitted, it is taken to be

          tol = max (size (A)) * sigma(1) * eps;

     where 'eps' is machine precision and 'sigma(1)' is the largest
     singular value of A.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="ranks" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  ranks (X, DIM)
     Return the ranks of X along the first non-singleton dimension
     adjusted for ties.  If the optional argument DIM is given, operate
     along this dimension.

     See also: spearman, kendall


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="rat" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: S = rat (X, TOL)
 -- Function File: [N, D] = rat (X, TOL)
     Find a rational approximation to X within the tolerance defined by
     TOL using a continued fraction expansion.  For example:

          rat (pi) = 3 + 1/(7 + 1/16) = 355/113
          rat (e) = 3 + 1/(-4 + 1/(2 + 1/(5 + 1/(-2 + 1/(-7)))))
                  = 1457/536

     Called with two arguments returns the numerator and denominator
     separately as two matrices.

     See also: rats


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="rats" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  rats (X, LEN)
     Convert X into a rational approximation represented as a string.
     You can convert the string back into a matrix as follows:

            r = rats(hilb(4));
            x = str2num(r)

     The optional second argument defines the maximum length of the
     string representing the elements of X.  By default LEN is 9.

     See also: format, rat


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="rcond" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: C = rcond (A)
     Compute the 1-norm estimate of the reciprocal condition number as
     returned by LAPACK.  If the matrix is well-conditioned then C will
     be near 1 and if the matrix is poorly conditioned it will be close
     to zero.

     The matrix A must not be sparse.  If the matrix is sparse then
     'condest (A)' or 'rcond (full (A))' should be used instead.

     See also: cond, condest


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="rdivide" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  rdivide (X, Y)
     Return the element-by-element right division of X and Y.  This
     function and x ./ y are equivalent.

     See also: ldivide, mrdivide


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="re_read_readline_init_file" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  re_read_readline_init_file ()
     Re-read the last readline library initialization file that was
     read.  *Note Readline Init File: (readline)Readline Init File, for
     details.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="read_readline_init_file" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  read_readline_init_file (FILE)
     Read the readline library initialization file FILE.  If FILE is
     omitted, read the default initialization file (normally
     '~/.inputrc').

     *Note Readline Init File: (readline)Readline Init File, for
     details.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="readdir" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: [FILES, ERR, MSG] = readdir (DIR)
     Return names of the files in the directory DIR as a cell array of
     strings.  If an error occurs, return an empty cell array in FILES.

     If successful, ERR is 0 and MSG is an empty string.  Otherwise,
     ERR is nonzero and MSG contains a system-dependent error message.

     See also: ls, dir, glob


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="readlink" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: [RESULT, ERR, MSG] = readlink (SYMLINK)
     Read the value of the symbolic link SYMLINK.

     If successful, RESULT contains the contents of the symbolic link
     SYMLINK, ERR is 0 and MSG is an empty string.  Otherwise, ERR is
     nonzero and MSG contains a system-dependent error message.

     See also: link, symlink


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="real" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  real (Z)
     Return the real part of Z.

     See also: imag, conj


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="reallog" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  reallog (X)
     Return the real-valued natural logarithm of each element of X.
     Report an error if any element results in a complex return value.

     See also: log, realpow, realsqrt


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="realmax" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  realmax
 -- Built-in Function:  realmax (N)
 -- Built-in Function:  realmax (N, M)
 -- Built-in Function:  realmax (N, M, K, ...)
 -- Built-in Function:  realmax (..., CLASS)
     Return a scalar, matrix or N-dimensional array whose elements are
     all equal to the largest floating point number that is
     representable.  The actual value is system dependent.  On machines
     that support IEEE floating point arithmetic, 'realmax' is
     approximately 1.7977e+308 for double precision and 3.4028e+38 for
     single precision.

     When called with no arguments, return a scalar with the value
     'realmax('double')'.  When called with a single argument, return a
     square matrix with the dimension specified.  When called with more
     than one scalar argument the first two arguments are taken as the
     number of rows and columns and any further arguments specify
     additional matrix dimensions.  The optional argument CLASS
     specifies the return ty...

     USE help realmax FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="realmin" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  realmin
 -- Built-in Function:  realmin (N)
 -- Built-in Function:  realmin (N, M)
 -- Built-in Function:  realmin (N, M, K, ...)
 -- Built-in Function:  realmin (..., CLASS)
     Return a scalar, matrix or N-dimensional array whose elements are
     all equal to the smallest normalized floating point number that is
     representable.  The actual value is system dependent.  On machines
     that support IEEE floating point arithmetic, 'realmin' is
     approximately 2.2251e-308 for double precision and 1.1755e-38 for
     single precision.

     When called with no arguments, return a scalar with the value
     'realmin('double')'.  When called with a single argument, return a
     square matrix with the dimension specified.  When called with more
     than one scalar argument the first two arguments are taken as the
     number of rows and columns and any further arguments specify
     additional matrix dimensions.  The optional argument CLASS
     specifies t...

     USE help realmin FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="realpow" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  realpow (X, Y)
     Compute the real-valued, element-by-element power operator.  This
     is equivalent to 'X .^ Y', except that 'realpow' reports an error
     if any return value is complex.

     See also: reallog, realsqrt


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="realsqrt" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  realsqrt (X)
     Return the real-valued square root of each element of X.  Report an
     error if any element results in a complex return value.

     See also: sqrt, realpow, reallog


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="record" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  record (SEC, SAMPLING_RATE)
     Record SEC seconds of audio input into the vector X.  The default
     value for SAMPLING_RATE is 8000 samples per second, or 8kHz.  The
     program waits until the user types &lt;RET&gt; and then immediately
     starts to record.

     See also: lin2mu, mu2lin, loadaudio, saveaudio, playaudio, setaudio


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="rectangle" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  rectangle ()
 -- Function File:  rectangle (..., 'Position', POS)
 -- Function File:  rectangle (..., 'Curvature', CURV)
 -- Function File:  rectangle (..., 'EdgeColor', EC)
 -- Function File:  rectangle (..., 'FaceColor', FC)
 -- Function File: H = rectangle (...)
     Draw rectangular patch defined by POS and CURV.  The variable
     'POS(1:2)' defines the lower left-hand corner of the patch and
     'POS(3:4)' defines its width and height.  By default, the value of
     POS is '[0, 0, 1, 1]'.

     The variable CURV defines the curvature of the sides of the
     rectangle and may be a scalar or two-element vector with values
     between 0 and 1.  A value of 0 represents no curvature of the
     side, whereas a value of 1 means that the side is entirely curved
     into the arc of a circle.  If CURV is a two-element vector, then
     the first element is the curvature along the x-axis of the patch
     and the second along y-axis.

     If CURV is a scalar, it re...

     USE help rectangle FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="rectint" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: AREA = rectint (A, B)
     Compute the area of intersection of rectangles in A and rectangles
     in B.  Rectangles are defined as [x y width height] where x and y
     are the minimum values of the two orthogonal dimensions.

     If A or B are matrices, then the output, AREA, is a matrix where
     the i-th row corresponds to the i-th row of a and the j-th column
     corresponds to the j-th row of b.

     See also: polyarea


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="recycle" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: CURRENT_STATE recycle ()
 -- Function File: OLD_STATE recycle (NEW_STATE)
     Query or set the preference for recycling deleted files.

     Recycling files instead of permanently deleting them is currently
     not implemented in Octave.  To help avoid accidental data loss it
     is an error to attempt enable file recycling.

     See also: delete


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="refresh" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  refresh ()
 -- Function File:  refresh (H)
     Refresh a figure, forcing it to be redrawn.  Called without an
     argument the current figure is redrawn, otherwise the figure
     pointed to by H is redrawn.

     See also: drawnow


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="refreshdata" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  refreshdata ()
 -- Function File:  refreshdata (H)
 -- Function File:  refreshdata (H, WORKSPACE)
     Evaluate any 'datasource' properties of the current figure and
     update the plot if the corresponding data has changed.  If called
     with one or more arguments H is a scalar or array of figure
     handles to refresh.  The optional second argument WORKSPACE can
     take the following values.

    'base'
          Evaluate the datasource properties in the base workspace.
          (default).

    'caller'
          Evaluate the datasource properties in the workspace of the
          function that called 'refreshdata'.

     An example of the use of 'refreshdata' is:

          x = 0:0.1:10;
          y = sin (x);
          plot (x, y, 'ydatasource', 'y');
          for i = 1 : 100
            pause (0.1);
            y = sin (x + 0.1*i);
            refreshdata ();
          endfor

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="regexp" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: [S, E, TE, M, T, NM] = regexp (STR, PAT)
 -- Loadable Function: [...] = regexp (STR, PAT, 'OPT1', ...)
     Regular expression string matching.  Search for PAT in STR and
     return the positions and substrings of any matches, or empty
     values if there are none.

     The matched pattern PAT can include any of the standard regex
     operators, including:

    '.'
          Match any character

    '* + ? {}'
          Repetition operators, representing
         '*'
               Match zero or more times

         '+'
               Match one or more times

         '?'
               Match zero or one times

         '{N}'
               Match exactly N times

         '{N,}'
               Match N or more times

         '{M,N}'
               Match between M and N times

    '[...] [^...]'
          List operators.  The pattern will match any character listed
          between '[' and ']'.  If the first character is '^' then the
          pattern is inve...

     USE help regexp FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="regexpi" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: [S, E, TE, M, T, NM] = regexpi (STR, PAT)
 -- Loadable Function: [...] = regexpi (STR, PAT, 'OPT1', ...)
     Case insensitive regular expression string matching.  Search for
     PAT in STR and return the positions and substrings of any matches,
     or empty values if there are none.  *Note regexp: doc-regexp, for
     details on the syntax of the search pattern.

     See also: regexp


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="regexprep" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: OUTSTR = regexprep (STRING, PAT, REPSTR)
 -- Loadable Function: OUTSTR = regexprep (STRING, PAT, REPSTR, 'OPT1',
          ...)
     Replace occurrences of pattern PAT in STRING with REPSTR.

     The pattern is a regular expression as documented for 'regexp'.
     *Note regexp: doc-regexp.

     The replacement string may contain '$i', which substitutes for the
     ith set of parentheses in the match string.  For example,

          regexprep('Bill Dunn','(\w+) (\w+)','$2, $1')

     returns 'Dunn, Bill'

     Options in addition to those of 'regexp' are

    'once'
          Replace only the first occurrence of PAT in the result.

    'warnings'
          This option is present for compatibility but is ignored.


     See also: regexp, regexpi, strrep


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="regexptranslate" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  regexptranslate (OP, S)
     Translate a string for use in a regular expression.  This may
     include either wildcard replacement or special character escaping.
     The behavior is controlled by OP which can take the following
     values

    'wildcard'
          The wildcard characters '.', '*', and '?' are replaced with
          wildcards that are appropriate for a regular expression.  For
          example:

               regexptranslate ('wildcard', '*.m')
                    => '.*\.m'

    'escape'
          The characters '$.?[]', that have special meaning for regular
          expressions are escaped so that they are treated literally.
          For example:

               regexptranslate ('escape', '12.5')
                    => '12\.5'


     See also: regexp, regexpi, regexprep


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="register_graphics_toolkit" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  register_graphics_toolkit (TOOLKIT)
     List TOOLKIT as an available graphics toolkit.

     See also: available_graphics_toolkits


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="rehash" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  rehash ()
     Reinitialize Octave's load path directory cache.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="rem" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  rem (X, Y)
 -- Mapping Function:  fmod (X, Y)
     Return the remainder of the division 'X / Y', computed using the
     expression

          x - y .* fix (x ./ y)

     An error message is printed if the dimensions of the arguments do
     not agree, or if either of the arguments is complex.

     See also: mod


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="remove_input_event_hook" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  remove_input_event_hook (FCN)
     Remove the named function FCN from the list of functions to call
     periodically when Octave is waiting for input.

     See also: add_input_event_hook


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="rename" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: [ERR, MSG] = rename (OLD, NEW)
     Change the name of file OLD to NEW.

     If successful, ERR is 0 and MSG is an empty string.  Otherwise,
     ERR is nonzero and MSG contains a system-dependent error message.

     See also: ls, dir


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="repelems" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  repelems (X, R)
     Construct a vector of repeated elements from X.  R is a 2xN
     integer matrix specifying which elements to repeat and how often
     to repeat each element.

     Entries in the first row, R(1,j), select an element to repeat.
     The corresponding entry in the second row, R(2,j), specifies the
     repeat count.  If X is a matrix then the columns of X are imagined
     to be stacked on top of each other for purposes of the selection
     index.  A row vector is always returned.

     Conceptually the result is calculated as follows:

          y = [];
          for i = 1:columns (R)
           y = [y, X(R(1,i)*ones(1, R(2,i)))];
          endfor

     See also: repmat


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="repmat" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  repmat (A, M)
 -- Function File:  repmat (A, M, N)
 -- Function File:  repmat (A, M, N, P, ...)
 -- Function File:  repmat (A, [M N])
 -- Function File:  repmat (A, [M N P ...])
     Form a block matrix of size M by N, with a copy of matrix A as
     each element.  If N is not specified, form an M by M block matrix.

     See also: repelems


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="reset" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  reset (H, PROPERTY)
     Remove any defaults set for the handle H.  The default figure
     properties of 'position', 'units', 'windowstyle' and 'paperunits'
     and the default axes properties of 'position' and 'units' are not
     reset.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="reshape" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  reshape (A, M, N, ...)
 -- Built-in Function:  reshape (A, [M N ...])
 -- Built-in Function:  reshape (A, ..., [], ...)
 -- Built-in Function:  reshape (A, SIZE)
     Return a matrix with the specified dimensions (M, N, ...)  whose
     elements are taken from the matrix A.  The elements of the matrix
     are accessed in column-major order (like Fortran arrays are
     stored).

     The following code demonstrates reshaping a 1x4 row vector into a
     2x2 square matrix.

          reshape ([1, 2, 3, 4], 2, 2)
              =>  1  3
                  2  4

     Note that the total number of elements in the original matrix
     ('prod (size (A))') must match the total number of elements in the
     new matrix ('prod ([M N ...])').

     A single dimension of the return matrix may be left unspecified
     and Octave will determine its size automatically.  An empty matrix
     ([]) is used to flag the unspecified dimension.

     See also: resize


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="residue" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [R, P, K, E] = residue (B, A)
 -- Function File: [B, A] = residue (R, P, K)
 -- Function File: [B, A] = residue (R, P, K, E)
     The first calling form computes the partial fraction expansion for
     the quotient of the polynomials, B and A.

          B(s)    M       r(m)         N
          ---- = SUM -------------  + SUM k(i)*s^(N-i)
          A(s)   m=1 (s-p(m))^e(m)    i=1

     where M is the number of poles (the length of the R, P, and E),
     the K vector is a polynomial of order N-1 representing the direct
     contribution, and the E vector specifies the multiplicity of the
     m-th residue's pole.

     For example,

          b = [1, 1, 1];
          a = [1, -5, 8, -4];
          [r, p, k, e] = residue (b, a)
             => r = [-2; 7; 3]
             => p = [2; 2; 1]
             => k = [](0x0)
             => e = [1; 2; 1]

     which represents the following partial fraction expansion

                  s^2 + s + 1       -2        7        3
     ...

     USE help residue FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="resize" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  resize (X, M)
 -- Built-in Function:  resize (X, M, N, ...)
 -- Built-in Function:  resize (X, [M N ...])
     Resize X cutting off elements as necessary.

     In the result, element with certain indices is equal to the
     corresponding element of X if the indices are within the bounds of
     X; otherwise, the element is set to zero.

     In other words, the statement

           y = resize (x, dv);

     is equivalent to the following code:

           y = zeros (dv, class (x));
           sz = min (dv, size (x));
           for i = 1:length (sz), idx{i} = 1:sz(i); endfor
           y(idx{:}) = x(idx{:});

     but is performed more efficiently.

     If only M is supplied, and it is a scalar, the dimension of the
     result is M-by-M.  If M, N, ... are all scalars, then the
     dimensions of the result are M-by-N-by-....  If given a vector as
     input, then the dimensions of the result are given by the elements
     of that vector.

     An object can...

     USE help resize FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="restoredefaultpath" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  restoredefaultpath (...)
     Restore Octave's path to its initial state at startup.

     See also: path, addpath, rmpath, genpath, pathdef, savepath,
     pathsep


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="rethrow" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  rethrow (ERR)
     Reissue a previous error as defined by ERR.  ERR is a structure
     that must contain at least the 'message' and 'identifier' fields.
     ERR can also contain a field 'stack' that gives information on the
     assumed location of the error.  Typically ERR is returned from
     'lasterror'.

     See also: lasterror, lasterr, error


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="rgb2hsv" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: HSV_MAP = rgb2hsv (RGB)
     Transform a colormap or image from the RGB space to the HSV space.

     A color in the RGB space consists of the red, green and blue
     intensities.

     In the HSV space each color is represented by their hue, saturation
     and value (brightness).  Value gives the amount of light in the
     color.  Hue describes the dominant wavelength.  Saturation is the
     amount of hue mixed into the color.

     See also: hsv2rgb


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="rgb2ind" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [X, MAP] = rgb2ind (RGB)
 -- Function File: [X, MAP] = rgb2ind (R, G, B)
     Convert an RGB image to an Octave indexed image.

     See also: ind2rgb, rgb2ntsc


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="rgb2ntsc" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  rgb2ntsc (RGB)
     Transform a colormap or image from RGB to NTSC.

     See also: ntsc2rgb


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="ribbon" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  ribbon (X, Y, WIDTH)
 -- Function File:  ribbon (Y)
 -- Function File: H = ribbon (...)
     Plot a ribbon plot for the columns of Y vs.  X.  The optional
     parameter WIDTH specifies the width of a single ribbon (default is
     0.75).  If X is omitted, a vector containing the row numbers is
     assumed (1:rows(Y)).

     The optional return value H is a vector of graphics handles to the
     surface objects representing each ribbon.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="rindex" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  rindex (S, T)
     Return the position of the last occurrence of the character string
     T in the character string S, or 0 if no occurrence is found.  S
     may also be a string array or cell array of strings.

     For example:

          rindex ('Teststring', 't')
               => 6

     The 'rindex' function is equivalent to 'index' with DIRECTION set
     to &quot;last&quot;.

     See also: find, index


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="rlocus" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: rlocus (SYS)
 -- Function File: [RLDATA, K] = rlocus (SYS, INCREMENT, MIN_K, MAX_K)
     Display root locus plot of the specified SISO system.

     *Inputs*
    SYS
          LTI model.  Must be a single-input and single-output (SISO)
          system.

    MIN_K
          Minimum value of K.

    MAX_K
          Maximum value of K.

    INCREMENT
          The increment used in computing gain values.

     *Outputs*
    RLDATA
          Data points plotted: in column 1 real values, in column 2 the
          imaginary values.

    K
          Gains for real axis break points.

     *Block Diagram*
           u    +         +---+      +------+             y
          ------>(+)----->| k |----->| SISO |-------+------->
                  ^ -     +---+      +------+       |
                  |                                 |
                  +---------------------------------+

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="rmappdata" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  rmappdata (H, NAME)
     Delete the named application data for the object(s) with handle(s)
     H.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="rmdir" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: [STATUS, MSG, MSGID] = rmdir (DIR)
 -- Built-in Function: [STATUS, MSG, MSGID] = rmdir (DIR, 's')
     Remove the directory named DIR.

     If successful, STATUS is 1, with MSG and MSGID empty character
     strings.  Otherwise, STATUS is 0, MSG contains a system-dependent
     error message, and MSGID contains a unique message identifier.

     If the optional second parameter is supplied with value &quot;s&quot;,
     recursively remove all subdirectories as well.

     See also: mkdir, confirm_recursive_rmdir


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="rmfield" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  rmfield (S, F)
     Return a copy of the structure (array) S with the field F removed.
     If F is a cell array of strings or a character array, remove the
     named fields.

     See also: cellstr, iscellstr, setfield


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="rmpath" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  rmpath (DIR1, ...)
     Remove DIR1, ... from the current function search path.

     In addition to accepting individual directory arguments, lists of
     directory names separated by 'pathsep' are also accepted.  For
     example:

          rmpath ('dir1:/dir2:~/dir3');

     See also: path, addpath, genpath, pathdef, savepath, pathsep


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="rmpref" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  rmpref (GROUP, PREF)
     Remove the named preference PREF from the preference group GROUP.

     The named preference group must be a character string.

     The preference PREF may be a character string or a cell array of
     character strings.

     If PREF is not specified, remove the preference group GROUP.

     It is an error to remove a nonexistent preference or group.

     See also: addpref, ispref, setpref, getpref


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="roots" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  roots (V)
     For a vector V with N components, return the roots of the
     polynomial

          v(1) * z^(N-1) + ... + v(N-1) * z + v(N)

     As an example, the following code finds the roots of the quadratic
     polynomial

          p(x) = x^2 - 5.

          c = [1, 0, -5];
          roots (c)
          =>  2.2361
          => -2.2361

     Note that the true result is +/- sqrt(5) which is roughly +/-
     2.2361.

     See also: poly, compan, fzero


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="rose" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  rose (TH, R)
 -- Function File:  rose (H, ...)
 -- Function File: H = rose (...)
 -- Function File: [R, TH] = rose (...)
     Plot an angular histogram.  With one vector argument TH, plots the
     histogram with 20 angular bins.  If TH is a matrix, then each
     column of TH produces a separate histogram.

     If R is given and is a scalar, then the histogram is produced with
     R bins.  If R is a vector, then the center of each bin are defined
     by the values of R.

     The optional return value H is a vector of graphics handles to the
     line objects representing each histogram.

     If two output arguments are requested then, rather than plotting
     the histogram, the polar vectors necessary to plot the histogram
     are returned.

          [r, t] = rose ([2*randn(1e5,1), pi + 2*randn(1e5,1)]);
          polar (r, t);

     See also: polar, compass, hist


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="rosser" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  rosser ()
     Return the Rosser matrix.  This is a difficult test case used to
     evaluate eigenvalue algorithms.

     See also: wilkinson, eig


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="rot90" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  rot90 (A)
 -- Function File:  rot90 (A, K)
     Return a copy of A with the elements rotated counterclockwise in
     90-degree increments.  The second argument is optional, and
     specifies how many 90-degree rotations are to be applied (the
     default value is 1).  Negative values of K rotate the matrix in a
     clockwise direction.  For example,

          rot90 ([1, 2; 3, 4], -1)
              =>  3  1
                  4  2

     rotates the given matrix clockwise by 90 degrees.  The following
     are all equivalent statements:

          rot90 ([1, 2; 3, 4], -1)
          rot90 ([1, 2; 3, 4], 3)
          rot90 ([1, 2; 3, 4], 7)

     Note that 'rot90' only works with 2-D arrays.  To rotate N-D arrays
     use 'rotdim' instead.

     See also: rotdim, flipud, fliplr, flipdim


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="rotdim" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  rotdim (X)
 -- Function File:  rotdim (X, N)
 -- Function File:  rotdim (X, N, PLANE)
     Return a copy of X with the elements rotated counterclockwise in
     90-degree increments.  The second argument N is optional, and
     specifies how many 90-degree rotations are to be applied (the
     default value is 1).  The third argument is also optional and
     defines the plane of the rotation.  If present, PLANE is a two
     element vector containing two different valid dimensions of the
     matrix.  When PLANE is not given the first two non-singleton
     dimensions are used.

     Negative values of N rotate the matrix in a clockwise direction.
     For example,

          rotdim ([1, 2; 3, 4], -1, [1, 2])
               =>  3  1
                   4  2

     rotates the given matrix clockwise by 90 degrees.  The following
     are all equivalent statements:

          rotdim ([1, 2; 3, 4], -1, [1, 2])
          rotdim ([1, 2; 3, 4], 3, [1, 2])
          rotdim ...

     USE help rotdim FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="round" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  round (X)
     Return the integer nearest to X.  If X is complex, return 'round
     (real (X)) + round (imag (X)) * I'.  If there are two nearest
     integers, return the one further away from zero.

          round ([-2.7, 2.7])
              => -3   3

     See also: ceil, floor, fix, roundb


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="roundb" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  roundb (X)
     Return the integer nearest to X.  If there are two nearest
     integers, return the even one (banker's rounding).  If X is
     complex, return 'roundb (real (X)) + roundb (imag (X)) * I'.

     See also: round


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="rows" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  rows (A)
     Return the number of rows of A.

     See also: columns, size, length, numel, isscalar, isvector,
     ismatrix


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="rref" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  rref (A)
 -- Function File:  rref (A, TOL)
 -- Function File: [R, K] = rref (...)
     Return the reduced row echelon form of A.  TOL defaults to 'eps *
     max (size (A)) * norm (A, inf)'.

     Called with two return arguments, K returns the vector of 'bound
     variables', which are those columns on which elimination has been
     performed.


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="rsf2csf" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [U, T] = rsf2csf (UR, TR)
     Convert a real, upper quasi-triangular Schur form TR to a complex,
     upper triangular Schur form T.

     Note that the following relations hold:

     UR * TR * UR' = U * T * U' and 'U' * U' is the identity matrix I.

     Note also that U and T are not unique.

     See also: schur


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="run" func="yes">
            <Overload retVal="">
                <Param name="
 -- Command:  run SCRIPT
 -- Function File:  run (SCRIPT)
     Run scripts in the current workspace that are not necessarily on
     the path.  If SCRIPT is the script to run, including its path, then
     'run' changes the directory to the directory where SCRIPT is
     found.  'run' then executes the script, and returns to the original
     directory.

     See also: system


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="run_count" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  run_count (X, N)
 -- Function File:  run_count (X, N, DIM)
     Count the upward runs along the first non-singleton dimension of X
     of length 1, 2, ..., N-1 and greater than or equal to N.

     If the optional argument DIM is given then operate along this
     dimension.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="run_history" func="yes">
            <Overload retVal="">
                <Param name="
 -- Command:  run_history [FIRST] [LAST]
     Similar to 'edit_history', except that the editor is not invoked,
     and the commands are simply executed as they appear in the history
     list.

     See also: edit_history


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="run_test" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [PVAL, CHISQ] = run_test (X)
     Perform a chi-square test with 6 degrees of freedom based on the
     upward runs in the columns of X.  Can be used to test whether X
     contains independent data.

     The p-value of the test is returned in PVAL.

     If no output argument is given, the p-value is displayed.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="rundemos" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  rundemos ()
 -- Function File:  rundemos (DIRECTORY)
     Execute built-in demos for all function files in the specified
     directory.  If no directory is specified, operate on all
     directories in Octave's search path for functions.

     See also: runtests, path


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="runlength" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [count, value] = runlength (X)
     Find the lengths of all sequences of common values.  Return the
     vector of lengths and the value that was repeated.

          runlength ([2, 2, 0, 4, 4, 4, 0, 1, 1, 1, 1])
          =>  [2, 1, 3, 1, 4]

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="runtests" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  runtests ()
 -- Function File:  runtests (DIRECTORY)
     Execute built-in tests for all function files in the specified
     directory.  If no directory is specified, operate on all
     directories in Octave's search path for functions.

     See also: rundemos, path


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="S_ISBLK" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  S_ISBLK (MODE)
     Return true if MODE corresponds to a block device.  The value of
     MODE is assumed to be returned from a call to 'stat'.

     See also: stat, lstat


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="S_ISCHR" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  S_ISCHR (MODE)
     Return true if MODE corresponds to a character device.  The value
     of MODE is assumed to be returned from a call to 'stat'.

     See also: stat, lstat


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="S_ISDIR" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  S_ISDIR (MODE)
     Return true if MODE corresponds to a directory.  The value of MODE
     is assumed to be returned from a call to 'stat'.

     See also: stat, lstat


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="S_ISFIFO" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  S_ISFIFO (MODE)
     Return true if MODE corresponds to a fifo.  The value of MODE is
     assumed to be returned from a call to 'stat'.

     See also: stat, lstat


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="S_ISLNK" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  S_ISLNK (MODE)
     Return true if MODE corresponds to a symbolic link.  The value of
     MODE is assumed to be returned from a call to 'stat'.

     See also: stat, lstat


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="S_ISREG" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  S_ISREG (MODE)
     Return true if MODE corresponds to a regular file.  The value of
     MODE is assumed to be returned from a call to 'stat'.

     See also: stat, lstat


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="S_ISSOCK" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  S_ISSOCK (MODE)
     Return true if MODE corresponds to a socket.  The value of MODE is
     assumed to be returned from a call to 'stat'.

     See also: stat, lstat


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="save" func="yes">
            <Overload retVal="">
                <Param name="
 -- Command:  save file
 -- Command:  save options file
 -- Command:  save options file V1 V2 ...
 -- Command:  save options file -struct STRUCT F1 F2 ...
     Save the named variables V1, V2, ..., in the file FILE.  The
     special filename '-' may be used to write output to the terminal.
     If no variable names are listed, Octave saves all the variables in
     the current scope.  Otherwise, full variable names or pattern
     syntax can be used to specify the variables to save.  If the
     '-struct' modifier is used, fields F1 F2 ...  of the scalar
     structure STRUCT are saved as if they were variables with
     corresponding names.  Valid options for the 'save' command are
     listed in the following table.  Options that modify the output
     format override the format specified by 'default_save_options'.

     If save is invoked using the functional form

          save ('-option1', ..., 'file', 'v1', ...)

     then the OPTIONS, FILE, and variable name arguments (V1, ......

     USE help save FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="save_header_format_string" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: VAL = save_header_format_string ()
 -- Built-in Function: OLD_VAL = save_header_format_string (NEW_VAL)
 -- Built-in Function:  save_header_format_string (NEW_VAL, 'local')
     Query or set the internal variable that specifies the format
     string used for the comment line written at the beginning of
     text-format data files saved by Octave.  The format string is
     passed to 'strftime' and should begin with the character '#' and
     contain no newline characters.  If the value of
     'save_header_format_string' is the empty string, the header
     comment is omitted from text-format data files.  The default value
     is

          '# Created by Octave VERSION, %a %b %d %H:%M:%S %Y %Z &lt;USER@HOST&gt;'

     When called from inside a function with the 'local' option, the
     variable is changed locally for the function and any subroutines
     it calls.  The original variable value is restored when exiting
     the function.

     See also: strftime, save
...

     USE help save_header_format_string FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="save_precision" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: VAL = save_precision ()
 -- Built-in Function: OLD_VAL = save_precision (NEW_VAL)
 -- Built-in Function:  save_precision (NEW_VAL, 'local')
     Query or set the internal variable that specifies the number of
     digits to keep when saving data in text format.

     When called from inside a function with the 'local' option, the
     variable is changed locally for the function and any subroutines
     it calls.  The original variable value is restored when exiting
     the function.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="saveas" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  saveas (H, FILENAME)
 -- Function File:  saveas (H, FILENAME, FMT)
     Save graphic object H to the file FILENAME in graphic format FMT.

     FMT should be one of the following formats:

    'ps'
          Postscript

    'eps'
          Encapsulated Postscript

    'jpg'
          JPEG Image

    'png'
          PNG Image

    'emf'
          Enhanced Meta File

    'pdf'
          Portable Document Format

     All device formats specified in 'print' may also be used.  If FMT
     is omitted it is extracted from the extension of FILENAME.  The
     default format is &quot;pdf&quot;.

          clf ();
          surf (peaks);
          saveas (1, 'figure1.png');

     See also: print


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="saveaudio" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  saveaudio (NAME, X, EXT, BPS)
     Save a vector X of audio data to the file 'NAME.EXT'.  The
     optional parameters EXT and BPS determine the encoding and the
     number of bits per sample used in the audio file (see
     'loadaudio'); defaults are 'lin' and 8, respectively.

     See also: lin2mu, mu2lin, loadaudio, playaudio, setaudio, record


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="saveobj" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: B = saveobj (A)
     Method of a class to manipulate an object prior to saving it to a
     file.  The function 'saveobj' is called when the object A is saved
     using the 'save' function.  An example of the use of 'saveobj'
     might be to remove fields of the object that don't make sense to
     be saved or it might be used to ensure that certain fields of the
     object are initialized before the object is saved.  For example:

          function b = saveobj (a)
            b = a;
            if (isempty (b.field))
               b.field = initfield (b);
            endif
          endfunction

     See also: loadobj, class


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="savepath" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  savepath (FILE)
     Save the portion of the current function search path, that is not
     set during Octave's initialization process, to FILE.  If FILE is
     omitted, '~/.octaverc' is used.  If successful, 'savepath' returns
     0.

     See also: path, addpath, rmpath, genpath, pathdef, pathsep


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="saving_history" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: VAL = saving_history ()
 -- Built-in Function: OLD_VAL = saving_history (NEW_VAL)
 -- Built-in Function:  saving_history (NEW_VAL, 'local')
     Query or set the internal variable that controls whether commands
     entered on the command line are saved in the history file.

     When called from inside a function with the 'local' option, the
     variable is changed locally for the function and any subroutines
     it calls.  The original variable value is restored when exiting
     the function.

     See also: history_control, history_file, history_size,
     history_timestamp_format_string


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="scanf" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: [VAL, COUNT, ERRMSG] = scanf (TEMPLATE, SIZE)
 -- Built-in Function: [V1, V2, ..., COUNT, ERRMSG]] = scanf (TEMPLATE,
          'C')
     This is equivalent to calling 'fscanf' with FID = 'stdin'.

     It is currently not useful to call 'scanf' in interactive programs.

     See also: fscanf, sscanf, printf


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="scatter" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  scatter (X, Y)
 -- Function File:  scatter (X, Y, S)
 -- Function File:  scatter (X, Y, C)
 -- Function File:  scatter (X, Y, S, C)
 -- Function File:  scatter (X, Y, S, C, STYLE)
 -- Function File:  scatter (X, Y, S, C, PROP, VAL)
 -- Function File:  scatter (..., 'filled')
 -- Function File:  scatter (H, ...)
 -- Function File: H = scatter (...)
     Plot a scatter plot of the data.  A marker is plotted at each point
     defined by the points in the vectors X and Y.  The size of the
     markers used is determined by the S, which can be a scalar, a
     vector of the same length of X and Y.  If S is not given or is an
     empty matrix, then the default value of 8 points is used.

     The color of the markers is determined by C, which can be a string
     defining a fixed color; a 3-element vector giving the red,
     green,and blue components of the color; a vector of the same
     length as X that gives a scaled index into the current colormap;
     or a N-by-...

     USE help scatter FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="scatter3" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  scatter3 (X, Y, Z, S, C)
 -- Function File:  scatter3 (..., 'filled')
 -- Function File:  scatter3 (..., STYLE)
 -- Function File:  scatter3 (..., PROP, VAL)
 -- Function File:  scatter3 (H, ...)
 -- Function File: H = scatter3 (...)
     Plot a scatter plot of the data in 3D.  A marker is plotted at
     each point defined by the points in the vectors X, Y and Z.  The
     size of the markers used is determined by S, which can be a scalar
     or a vector of the same length of X, Y and Z.  If S is not given
     or is an empty matrix, then the default value of 8 points is used.

     The color of the markers is determined by C, which can be a string
     defining a fixed color; a 3-element vector giving the red, green,
     and blue components of the color; a vector of the same length as X
     that gives a scaled index into the current colormap; or a N-by-3
     matrix defining the colors of each of the markers individually.

     The marker to use can be changed ...

     USE help scatter3 FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="schur" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: S = schur (A)
 -- Loadable Function: S = schur (A, 'real')
 -- Loadable Function: S = schur (A, 'complex')
 -- Loadable Function: S = schur (A, OPT)
 -- Loadable Function: [U, S] = schur (A, ...)
     Compute the Schur decomposition of A

          'S = U' * A * U'

     where U is a unitary matrix ('U'* U' is identity) and S is upper
     triangular.  The eigenvalues of A (and S) are the diagonal
     elements of S.  If the matrix A is real, then the real
     Schur decomposition is computed, in which the matrix U is
     orthogonal and S is block upper triangular with blocks of size at
     most '2 x 2' along the diagonal.  The diagonal elements of S (or
     the eigenvalues of the '2 x 2' blocks, when appropriate) are the
     eigenvalues of A and S.

     The default for real matrices is a real Schur decomposition.  A
     complex decomposition may be forced by passing the flag 'complex'.

     The eigenvalues are optionally ordered along the diagonal
     ac...

     USE help schur FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="sec" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  sec (X)
     Compute the secant for each element of X in radians.

     See also: asec, secd, sech


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="secd" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  secd (X)
     Compute the secant for each element of X in degrees.

     See also: asecd, sec


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="sech" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  sech (X)
     Compute the hyperbolic secant of each element of X.

     See also: asech


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="SEEK_SET" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  SEEK_SET ()
 -- Built-in Function:  SEEK_CUR ()
 -- Built-in Function:  SEEK_END ()
     Return the numerical value to pass to 'fseek' to perform one of
     the following actions:
    'SEEK_SET'
          Position file relative to the beginning.

    'SEEK_CUR'
          Position file relative to the current position.

    'SEEK_END'
          Position file relative to the end.

     See also: fseek


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="semilogx" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  semilogx (Y)
 -- Function File:  semilogx (X, Y)
 -- Function File:  semilogx (X, Y, PROPERTY, VALUE, ...)
 -- Function File:  semilogx (X, Y, FMT)
 -- Function File:  semilogx (H, ...)
 -- Function File: H = semilogx (...)
     Produce a two-dimensional plot using a logarithmic scale for the X
     axis.  See the documentation of 'plot' for a description of the
     arguments that 'semilogx' will accept.

     The optional return value H is a graphics handle to the created
     plot.

     See also: plot, semilogy, loglog


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="semilogxerr" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  semilogxerr (ARGS)
     Produce two-dimensional plots using a logarithmic scale for the X
     axis and errorbars at each data point.  Many different
     combinations of arguments are possible.  The most used form is

          semilogxerr (X, Y, EY, FMT)

     which produces a semi-logarithmic plot of Y versus X with errors
     in the Y-scale defined by EY and the plot format defined by FMT.
     See 'errorbar' for available formats and additional information.

     See also: errorbar, loglogerr, semilogyerr


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="semilogy" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  semilogy (Y)
 -- Function File:  semilogy (X, Y)
 -- Function File:  semilogy (X, Y, PROPERTY, VALUE, ...)
 -- Function File:  semilogy (X, Y, FMT)
 -- Function File:  semilogy (H, ...)
 -- Function File: H = semilogy (...)
     Produce a two-dimensional plot using a logarithmic scale for the Y
     axis.  See the documentation of 'plot' for a description of the
     arguments that 'semilogy' will accept.

     The optional return value H is a graphics handle to the created
     plot.

     See also: plot, semilogx, loglog


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="semilogyerr" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  semilogyerr (ARGS)
     Produce two-dimensional plots using a logarithmic scale for the Y
     axis and errorbars at each data point.  Many different
     combinations of arguments are possible.  The most used form is

          semilogyerr (X, Y, EY, FMT)

     which produces a semi-logarithmic plot of Y versus X with errors
     in the Y-scale defined by EY and the plot format defined by FMT.
     See 'errorbar' for available formats and additional information.

     See also: errorbar, loglogerr, semilogxerr


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="set" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  set (H, PROPERTY, VALUE, ...)
 -- Built-in Function:  set (H, PROPERTIES, VALUES)
 -- Built-in Function:  set (H, PV)
     Set named property values for the graphics handle (or vector of
     graphics handles) H.  There are three ways how to give the
     property names and values:

        * as a comma separated list of PROPERTY, VALUE pairs

          Here, each PROPERTY is a string containing the property name,
          each VALUE is a value of the appropriate type for the
          property.

        * as a cell array of strings PROPERTIES containing property
          names and a cell array VALUES containing property values.

          In this case, the number of columns of VALUES must match the
          number of elements in PROPERTIES.  The first column of VALUES
          contains values for the first entry in PROPERTIES, etc.  The
          number of rows of VALUES must be 1 or match the number of
          elements of H.  In the first case, each hand...

     USE help set FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="setappdata" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  setappdata (H, NAME, VALUE)
     Set the named application data to VALUE for the object(s) with
     handle(s) H.  If the application data with the specified name does
     not exist, it is created.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="setaudio" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  setaudio ()
 -- Function File:  setaudio (W_TYPE)
 -- Function File:  setaudio (W_TYPE, VALUE)
     Execute the shell command 'mixer', possibly with optional
     arguments W_TYPE and VALUE.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="setdiff" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  setdiff (A, B)
 -- Function File:  setdiff (A, B, 'rows')
 -- Function File: [C, I] = setdiff (A, B)
     Return the elements in A that are not in B, sorted in ascending
     order.  If A and B are both column vectors return a column vector,
     otherwise return a row vector.  A, B may be cell arrays of
     string(s).

     Given the optional third argument &quot;rows&quot;, return the rows in A
     that are not in B, sorted in ascending order by rows.

     If requested, return I such that 'c = a(i)'.

     See also: unique, union, intersect, setxor, ismember


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="setfield" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [K1, ..., V1] = setfield (S, K1, V1, ...)
     Set a field member in a (nested) structure array.  For example:

          oo(1,1).f0 = 1;
          oo = setfield (oo, {1,2}, 'fd', {3}, 'b', 6);
          oo(1,2).fd(3).b == 6
               => ans = 1

     Note that the same result as in the above example could be
     achieved by:

          i1 = {1,2}; i2 = 'fd'; i3 = {3}; i4 = 'b';
          oo(i1{:}).(i2)(i3{:}).(i4) == 6
               => ans = 1

     See also: getfield, rmfield, isfield, isstruct, fieldnames, struct


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="setgrent" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function:  setgrent ()
     Return the internal pointer to the beginning of the group database.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="setpref" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  setpref (GROUP, PREF, VAL)
     Set a preference PREF to the given VAL in the named preference
     group GROUP.

     The named preference group must be a character string.

     The preference PREF may be a character string or a cell array of
     character strings.  The corresponding value VAL may be any value,
     or, if PREF is a cell array of strings, VAL must be a cell array
     of values with the same size as PREF.

     If the named preference or group does not exist, it is added.

     See also: addpref, getpref, ispref, rmpref


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="setpwent" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function:  setpwent ()
     Return the internal pointer to the beginning of the password
     database.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="setxor" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  setxor (A, B)
 -- Function File:  setxor (A, B, 'rows')
 -- Function File: [C, IA, IB] = setxor (A, B)
     Return the elements exclusive to A or B, sorted in ascending
     order.  If A and B are both column vectors return a column vector,
     otherwise return a row vector.  A, B may be cell arrays of
     string(s).

     With three output arguments, return index vectors IA and IB such
     that 'a(ia)' and 'b(ib)' are disjoint sets whose union is C.

     See also: unique, union, intersect, setdiff, ismember


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="shading" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  shading (TYPE)
 -- Function File:  shading (AX, ...)
     Set the shading of surface or patch graphic objects.  Valid
     arguments for TYPE are

    'flat'
          Single colored patches with invisible edges.

    'faceted'
          Single colored patches with visible edges.

    'interp'
          Color between patch vertices are interpolated and the patch
          edges are invisible.

     If AX is given the shading is applied to axis AX instead of the
     current axis.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="shg" func="yes">
            <Overload retVal="">
                <Param name="
 -- Command:  shg
     Show the graph window.  Currently, this is the same as executing
     'drawnow'.

     See also: drawnow, figure


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="shift" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  shift (X, B)
 -- Function File:  shift (X, B, DIM)
     If X is a vector, perform a circular shift of length B of the
     elements of X.

     If X is a matrix, do the same for each column of X.  If the
     optional DIM argument is given, operate along this dimension.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="shiftdim" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: Y = shiftdim (X, N)
 -- Function File: [Y, NS] = shiftdim (X)
     Shift the dimensions of X by N, where N must be an integer scalar.
     When N is positive, the dimensions of X are shifted to the left,
     with the leading dimensions circulated to the end.  If N is
     negative, then the dimensions of X are shifted to the right, with
     N leading singleton dimensions added.

     Called with a single argument, 'shiftdim', removes the leading
     singleton dimensions, returning the number of dimensions removed
     in the second output argument NS.

     For example:

          x = ones (1, 2, 3);
          size (shiftdim (x, -1))
             => [1, 1, 2, 3]
          size (shiftdim (x, 1))
             => [2, 3]
          [b, ns] = shiftdim (x)
             => b = [1, 1, 1; 1, 1, 1]
             => ns = 1

     See also: reshape, permute, ipermute, circshift, squeeze


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="SIG" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  SIG ()
     Return a structure containing Unix signal names and their defined
     values.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="sighup_dumps_octave_core" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: VAL = sighup_dumps_octave_core ()
 -- Built-in Function: OLD_VAL = sighup_dumps_octave_core (NEW_VAL)
 -- Built-in Function:  sighup_dumps_octave_core (NEW_VAL, 'local')
     Query or set the internal variable that controls whether Octave
     tries to save all current variables to the file 'octave-core' if
     it receives a hangup signal.

     When called from inside a function with the 'local' option, the
     variable is changed locally for the function and any subroutines
     it calls.  The original variable value is restored when exiting
     the function.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="sigma" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [SV, W] = sigma (SYS)
 -- Function File: [SV, W] = sigma (SYS, W)
 -- Function File: [SV, W] = sigma (SYS, [], PTYPE)
 -- Function File: [SV, W] = sigma (SYS, W, PTYPE)
     Singular values of frequency response.  If no output arguments are
     given, the singular value plot is printed on the screen;

     *Inputs*
    SYS
          LTI system.  Multiple inputs and/or outputs (MIMO systems)
          make practical sense.

    W
          Optional vector of frequency values.  If W is not specified,
          it is calculated by the zeros and poles of the system.
          Alternatively, the cell '{wmin, wmax}' specifies a frequency
          range, where WMIN and WMAX denote minimum and maximum
          frequencies in rad/s.

    PTYPE = 0
          Singular values of the frequency response H of system SYS.
          Default Value.

    PTYPE = 1
          Singular values of the frequency response 'inv(H)'; i.e.
          inversed system.

    PTYPE = 2
          S...

     USE help sigma FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="sign" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  sign (X)
     Compute the 'signum' function, which is defined as

                    -1, x &lt; 0;
          sign (x) =  0, x = 0;
                     1, x &gt; 0.

     For complex arguments, 'sign' returns 'x ./ abs (X)'.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="sign_test" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [PVAL, B, N] = sign_test (X, Y, ALT)
     For two matched-pair samples X and Y, perform a sign test of the
     null hypothesis PROB (X &gt; Y) == PROB (X &lt; Y) == 1/2.  Under the
     null, the test statistic B roughly follows a binomial distribution
     with parameters 'N = sum (X != Y)' and P = 1/2.

     With the optional argument 'alt', the alternative of interest can
     be selected.  If ALT is &quot;!=&quot; or &quot;&lt;%gt;&quot;, the null hypothesis is
     tested against the two-sided alternative PROB (X &lt; Y) != 1/2.  If
     ALT is &quot;&gt;&quot;, the one-sided alternative PROB (X &gt; Y) &gt; 1/2 ('x is
     stochastically greater than y') is considered.  Similarly for
     &quot;&lt;&quot;, the one-sided alternative PROB (X &gt; Y) &lt; 1/2 ('x is
     stochastically less than y') is considered.  The default is the
     two-sided case.

     The p-value of the test is returned in PVAL.

     If no output argument is given, the p-value of the test is
     displayed.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="sigterm_dumps_octave_core" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: VAL = sigterm_dumps_octave_core ()
 -- Built-in Function: OLD_VAL = sigterm_dumps_octave_core (NEW_VAL)
 -- Built-in Function:  sigterm_dumps_octave_core (NEW_VAL, 'local')
     Query or set the internal variable that controls whether Octave
     tries to save all current variables to the file 'octave-core' if
     it receives a terminate signal.

     When called from inside a function with the 'local' option, the
     variable is changed locally for the function and any subroutines
     it calls.  The original variable value is restored when exiting
     the function.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="silent_functions" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: VAL = silent_functions ()
 -- Built-in Function: OLD_VAL = silent_functions (NEW_VAL)
 -- Built-in Function:  silent_functions (NEW_VAL, 'local')
     Query or set the internal variable that controls whether internal
     output from a function is suppressed.  If this option is disabled,
     Octave will display the results produced by evaluating expressions
     within a function body that are not terminated with a semicolon.

     When called from inside a function with the 'local' option, the
     variable is changed locally for the function and any subroutines
     it calls.  The original variable value is restored when exiting
     the function.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="sin" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  sin (X)
     Compute the sine for each element of X in radians.

     See also: asin, sind, sinh


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="sinc" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  sinc (X)
     Return  sin(pi*x)/(pi*x).

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="sind" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  sind (X)
     Compute the sine for each element of X in degrees.  Returns zero
     for elements where 'X/180' is an integer.

     See also: asind, sin


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="sinetone" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  sinetone (FREQ, RATE, SEC, AMPL)
     Return a sinetone of frequency FREQ with length of SEC seconds at
     sampling rate RATE and with amplitude AMPL.  The arguments FREQ
     and AMPL may be vectors of common size.

     Defaults are RATE = 8000, SEC = 1 and AMPL = 64.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="sinewave" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  sinewave (M, N, D)
     Return an M-element vector with I-th element given by 'sin (2 * pi
     * (I+D-1) / N)'.

     The default value for D is 0 and the default value for N is M.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="single" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  single (X)
     Convert X to single precision type.

     See also: double


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="sinh" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  sinh (X)
     Compute the hyperbolic sine for each element of X.

     See also: asinh, cosh, tanh


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="size" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  size (A)
 -- Built-in Function:  size (A, DIM)
     Return the number of rows and columns of A.

     With one input argument and one output argument, the result is
     returned in a row vector.  If there are multiple output arguments,
     the number of rows is assigned to the first, and the number of
     columns to the second, etc.  For example:

          size ([1, 2; 3, 4; 5, 6])
              => [ 3, 2 ]

          [nr, nc] = size ([1, 2; 3, 4; 5, 6])
              => nr = 3
              => nc = 2

     If given a second argument, 'size' will return the size of the
     corresponding dimension.  For example,

          size ([1, 2; 3, 4; 5, 6], 2)
              => 2

     returns the number of columns in the given matrix.

     See also: numel


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="size_equal" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  size_equal (A, B, ...)
     Return true if the dimensions of all arguments agree.  Trailing
     singleton dimensions are ignored.  Called with a single or no
     argument, size_equal returns true.

     See also: size, numel


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="sizemax" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  sizemax ()
     Return the largest value allowed for the size of an array.  If
     Octave is compiled with 64-bit indexing, the result is of class
     int64, otherwise it is of class int32.  The maximum array size is
     slightly smaller than the maximum value allowable for the relevant
     class as reported by 'intmax'.

     See also: intmax


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="sizeof" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  sizeof (VAL)
     Return the size of VAL in bytes.

     See also: whos


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="skewness" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  skewness (X)
 -- Function File:  skewness (X, DIM)
     Compute the skewness of the elements of the vector X.

          skewness (x) = 1/N std(x)^(-3) sum ((x - mean(x)).^3)

     If X is a matrix, return the skewness along the first
     non-singleton dimension of the matrix.  If the optional DIM
     argument is given, operate along this dimension.

     See also: var, kurtosis, moment


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="sleep" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  sleep (SECONDS)
     Suspend the execution of the program for the given number of
     seconds.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="slice" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  slice (X, Y, Z, V, SX, SY, SZ)
 -- Function File:  slice (X, Y, Z, V, XI, YI, ZI)
 -- Function File:  slice (V, SX, SY, SZ)
 -- Function File:  slice (V, XI, YI, ZI)
 -- Function File: H = slice (...)
 -- Function File: H = slice (..., METHOD)
     Plot slices of 3-D data/scalar fields.  Each element of the
     3-dimensional array V represents a scalar value at a location
     given by the parameters X, Y, and Z.  The parameters X, X, and Z
     are either 3-dimensional arrays of the same size as the array V in
     the 'meshgrid' format or vectors.  The parameters XI, etc. respect
     a similar format to X, etc., and they represent the points at
     which the array VI is interpolated using interp3.  The vectors SX,
     SY, and SZ contain points of orthogonal slices of the respective
     axes.

     If X, Y, Z are omitted, they are assumed to be 'x = 1:size (V,
     2)', 'y = 1:size (V, 1)' and 'z = 1:size (V, 3)'.

     METHOD is one of:

    'nearest'
       ...

     USE help slice FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="sombrero" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  sombrero (N)
     Produce the familiar three-dimensional sombrero plot using N grid
     lines.  If N is omitted, a value of 41 is assumed.

     The function plotted is

          z = sin (sqrt (x^2 + y^2)) / (sqrt (x^2 + y^2))

     See also: surf, meshgrid, mesh


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="sort" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: [S, I] = sort (X)
 -- Loadable Function: [S, I] = sort (X, DIM)
 -- Loadable Function: [S, I] = sort (X, MODE)
 -- Loadable Function: [S, I] = sort (X, DIM, MODE)
     Return a copy of X with the elements arranged in increasing order.
     For matrices, 'sort' orders the elements within columns

     For example:

          sort ([1, 2; 2, 3; 3, 1])
              =>  1  1
                  2  2
                  3  3

     If the optional argument DIM is given, then the matrix is sorted
     along the dimension defined by DIM.  The optional argument 'mode'
     defines the order in which the values will be sorted.  Valid
     values of 'mode' are 'ascend' or 'descend'.

     The 'sort' function may also be used to produce a matrix
     containing the original row indices of the elements in the sorted
     matrix.  For example:

          [s, i] = sort ([1, 2; 2, 3; 3, 1])
              => s = 1  1
                     2  2
                     3  3
              ...

     USE help sort FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="sortrows" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [S, I] = sortrows (A)
 -- Function File: [S, I] = sortrows (A, C)
     Sort the rows of the matrix A according to the order of the
     columns specified in C.  If C is omitted, a lexicographical sort
     is used.  By default ascending order is used however if elements
     of C are negative then the corresponding column is sorted in
     descending order.

     See also: sort


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="source" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  source (FILE)
     Parse and execute the contents of FILE.  This is equivalent to
     executing commands from a script file, but without requiring the
     file to be named 'FILE.m'.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="spaconred" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [KR, INFO] = spaconred (G, K, ...)
 -- Function File: [KR, INFO] = spaconred (G, K, NCR, ...)
 -- Function File: [KR, INFO] = spaconred (G, K, OPT, ...)
 -- Function File: [KR, INFO] = spaconred (G, K, NCR, OPT, ...)
     Controller reduction by frequency-weighted Singular Perturbation
     Approximation (SPA).  Given a plant G and a stabilizing controller
     K, determine a reduced order controller KR such that the
     closed-loop system is stable and closed-loop performance is
     retained.

     The algorithm tries to minimize the frequency-weighted error
          ||V (K-Kr) W||    = min
                        inf
     where V and W denote output and input weightings.

     *Inputs*
    G
          LTI model of the plant.  It has m inputs, p outputs and n
          states.

    K
          LTI model of the controller.  It has p inputs, m outputs and
          nc states.

    NCR
          The desired order of the resulting reduced order controller
          K...

     USE help spaconred FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="spalloc" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: S = spalloc (M, N, NZ)
     Create an M-by-N sparse matrix with pre-allocated space for at
     most NZ nonzero elements.  This is useful for building the matrix
     incrementally by a sequence of indexed assignments.  Subsequent
     indexed assignments will reuse the pre-allocated memory, provided
     they are of one of the simple forms

        * 'S(I:J) = X'

        * 'S(:,I:J) = X'

        * 'S(K:L,I:J) = X'

     and that the following conditions are met:

        * the assignment does not decrease nnz(S).

        * after the assignment, nnz(S) does not exceed NZ.

        * no index is out of bounds.

     Partial movement of data may still occur, but in general the
     assignment will be more memory and time-efficient under these
     circumstances.  In particular, it is possible to efficiently build
     a pre-allocated sparse matrix from contiguous block of columns.

     The amount of pre-allocated memory for a given matrix may be
     queried us...

     USE help spalloc FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="spamodred" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [GR, INFO] = spamodred (G, ...)
 -- Function File: [GR, INFO] = spamodred (G, NR, ...)
 -- Function File: [GR, INFO] = spamodred (G, OPT, ...)
 -- Function File: [GR, INFO] = spamodred (G, NR, OPT, ...)
     Model order reduction by frequency weighted Singular Perturbation
     Approximation (SPA).  The aim of model reduction is to find an LTI
     system GR of order NR (nr &lt; n) such that the input-output
     behaviour of GR approximates the one from original system G.

     SPA is an absolute error method which tries to minimize
          ||G-Gr||    = min
                  inf

          ||V (G-Gr) W||    = min
                        inf
     where V and W denote output and input weightings.

     *Inputs*
    G
          LTI model to be reduced.

    NR
          The desired order of the resulting reduced order system GR.
          If not specified, NR is chosen automatically according to the
          description of key 'ORDER'.

    ...
          Optional pair...

     USE help spamodred FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="sparse" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: S = sparse (A)
 -- Loadable Function: S = sparse (I, J, SV, M, N, NZMAX)
 -- Loadable Function: S = sparse (I, J, SV)
 -- Loadable Function: S = sparse (I, J, S, M, N, 'unique')
 -- Loadable Function: S = sparse (M, N)
     Create a sparse matrix from the full matrix or row, column, value
     triplets.  If A is a full matrix, convert it to a sparse matrix
     representation, removing all zero values in the process.

     Given the integer index vectors I and J, a 1-by-'nnz' vector of
     real of complex values SV, overall dimensions M and N of the
     sparse matrix.  The argument 'nzmax' is ignored but accepted for
     compatibility with MATLAB.  If M or N are not specified their
     values are derived from the maximum index in the vectors I and J
     as given by 'M = max (I)', 'N = max (J)'.

     *Note*: if multiple values are specified with the same I, J
     indices, the corresponding values in S will be added.

     The following are all equivalent:

...

     USE help sparse FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="sparse_auto_mutate" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: VAL = sparse_auto_mutate ()
 -- Built-in Function: OLD_VAL = sparse_auto_mutate (NEW_VAL)
 -- Built-in Function:  sparse_auto_mutate (NEW_VAL, 'local')
     Query or set the internal variable that controls whether Octave
     will automatically mutate sparse matrices to full matrices to save
     memory.  For example:

          s = speye (3);
          sparse_auto_mutate (false)
          s(:, 1) = 1;
          typeinfo (s)
          => sparse matrix
          sparse_auto_mutate (true)
          s(1, :) = 1;
          typeinfo (s)
          => matrix

     When called from inside a function with the 'local' option, the
     variable is changed locally for the function and any subroutines
     it calls.  The original variable value is restored when exiting
     the function.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="spaugment" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: S = spaugment (A, C)
     Create the augmented matrix of A.  This is given by

          [C * eye(M, M), A;
                      A', zeros(N, N)]

     This is related to the least squares solution of 'A \ B', by

          S * [ R / C; x] = [ B, zeros(N, columns(B)) ]

     where R is the residual error

          R = B - A * X

     As the matrix S is symmetric indefinite it can be factorized with
     'lu', and the minimum norm solution can therefore be found without
     the need for a 'qr' factorization.  As the residual error will be
     'zeros (M, M)' for under determined problems, and example can be

          m = 11; n = 10; mn = max (m, n);
          A = spdiags ([ones(mn,1), 10*ones(mn,1), -ones(mn,1)],
                       [-1, 0, 1], m, n);
          x0 = A \ ones (m,1);
          s = spaugment (A);
          [L, U, P, Q] = lu (s);
          x1 = Q * (U \ (L \ (P  * [ones(m,1); zeros(n,1)])));
          x1 = x1(end - n + 1 : end);

     To find the s...

     USE help spaugment FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="spconvert" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: X = spconvert (M)
     This function converts for a simple sparse matrix format easily
     produced by other programs into Octave's internal sparse format.
     The input X is either a 3 or 4 column real matrix, containing the
     row, column, real and imaginary parts of the elements of the
     sparse matrix.  An element with a zero real and imaginary part can
     be used to force a particular matrix size.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="spdiags" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [B, C] = spdiags (A)
 -- Function File: B = spdiags (A, C)
 -- Function File: B = spdiags (V, C, A)
 -- Function File: B = spdiags (V, C, M, N)
     A generalization of the function 'diag'.  Called with a single
     input argument, the non-zero diagonals C of A are extracted.  With
     two arguments the diagonals to extract are given by the vector C.

     The other two forms of 'spdiags' modify the input matrix by
     replacing the diagonals.  They use the columns of V to replace the
     columns represented by the vector C.  If the sparse matrix A is
     defined then the diagonals of this matrix are replaced.  Otherwise
     a matrix of M by N is created with the diagonals given by V.

     Negative values of C represent diagonals below the main diagonal,
     and positive values of C diagonals above the main diagonal.

     For example:

          spdiags (reshape (1:12, 4, 3), [-1 0 1], 5, 4)
             => 5 10  0  0
                1  6 11  0
             ...

     USE help spdiags FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="spearman" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  spearman (X)
 -- Function File:  spearman (X, Y)
     Compute Spearman's rank correlation coefficient RHO.

     For two data vectors X and Y, Spearman's RHO is the correlation
     coefficient of the ranks of X and Y.

     If X and Y are drawn from independent distributions, RHO has zero
     mean and variance '1 / (n - 1)', and is asymptotically normally
     distributed.

     'spearman (X)' is equivalent to 'spearman (X, X)'.

     See also: ranks, kendall


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="spectral_adf" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  spectral_adf (C, WIN, B)
     Return the spectral density estimator given a vector of
     autocovariances C, window name WIN, and bandwidth, B.

     The window name, e.g., &quot;triangle&quot; or &quot;rectangle&quot; is used to
     search for a function called 'WIN_sw'.

     If WIN is omitted, the triangle window is used.  If B is omitted,
     '1 / sqrt (length (X))' is used.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="spectral_xdf" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  spectral_xdf (X, WIN, B)
     Return the spectral density estimator given a data vector X,
     window name WIN, and bandwidth, B.

     The window name, e.g., &quot;triangle&quot; or &quot;rectangle&quot; is used to
     search for a function called 'WIN_sw'.

     If WIN is omitted, the triangle window is used.  If B is omitted,
     '1 / sqrt (length (X))' is used.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="specular" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  specular (SX, SY, SZ, LV, VV)
 -- Function File:  specular (SX, SY, SZ, LV, VV, SE)
     Calculate specular reflection strength of a surface defined by the
     normal vector elements SX, SY, SZ using Phong's approximation.
     The light and view vectors can be specified using parameter LV and
     VV respectively.  Both can be given as 2-element vectors [azimuth,
     elevation] in degrees or as 3-element vector [x, y, z].  An
     optional 6th argument describes the specular exponent (spread) SE.

     See also: surfl, diffuse


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="speed" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  speed (F, INIT, MAX_N, F2, TOL)
 -- Function File: [ORDER, N, T_F, T_F2] = speed (...)
     Determine the execution time of an expression (F) for various input
     values (N).  The N are log-spaced from 1 to MAX_N.  For each N, an
     initialization expression (INIT) is computed to create any data
     needed for the test.  If a second expression (F2) is given then
     the execution times of the two expressions are compared.  When
     called without output arguments the results are printed to stdout
     and displayed graphically.

    'F'
          The code expression to evaluate.

    'MAX_N'
          The maximum test length to run.  The default value is 100.
          Alternatively, use '[min_n, max_n]' or specify the N exactly
          with '[n1, n2, ..., nk]'.

    'INIT'
          Initialization expression for function argument values.  Use K
          for the test number and N for the size of the test.  This
          should compute values for all varia...

     USE help speed FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="spencer" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  spencer (X)
     Return Spencer's 15 point moving average of each column of X.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="speye" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: Y = speye (M)
 -- Function File: Y = speye (M, N)
 -- Function File: Y = speye (SZ)
     Return a sparse identity matrix.  This is significantly more
     efficient than 'sparse (eye (M))' as the full matrix is not
     constructed.

     Called with a single argument a square matrix of size M by M is
     created.  Otherwise a matrix of M by N is created.  If called with
     a single vector argument, this argument is taken to be the size of
     the matrix to create.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="spfun" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: Y = spfun (F, S)
     Compute 'f(S)' for the non-zero values of S.  This results in a
     sparse matrix with the same structure as S.  The function F can be
     passed as a string, a function handle, or an inline function.

     See also: arrayfun, cellfun, structfun


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="sph2cart" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [X, Y, Z] = sph2cart (THETA, PHI, R)
 -- Function File: [X, Y, Z] = sph2cart (S)
 -- Function File: C = sph2cart (...)
     Transform spherical to Cartesian coordinates.

     THETA describes the angle relative to the positive x-axis.  PHI is
     the angle relative to the xy-plane.  R is the distance to the
     origin (0, 0, 0).  THETA, PHI, and R must be the same shape, or
     scalar.  If called with a single matrix argument then each row of S
     represents the spherical coordinate (THETA, PHI, R).

     If only a single return argument is requested then return a matrix
     C where each row represents one Cartesian coordinate (X, Y, Z).

     See also: cart2sph, pol2cart, cart2pol


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="sphere" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [X, Y, Z] = sphere (N)
 -- Function File:  sphere (H, ...)
     Generate three matrices in 'meshgrid' format, such that 'surf (X,
     Y, Z)' generates a unit sphere.  The matrices of 'N+1'-by-'N+1'.
     If N is omitted then a default value of 20 is assumed.

     Called with no return arguments, 'sphere' call directly 'surf (X,
     Y, Z)'.  If an axes handle is passed as the first argument, the
     surface is plotted to this set of axes.

     See also: peaks


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="spinmap" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  spinmap (T, INC)
     Cycle the colormap for T seconds with an increment of INC.  Both
     parameters are optional.  The default cycle time is 5 seconds and
     the default increment is 2.

     A higher value of INC causes a faster cycle through the colormap.

     See also: gca, colorbar


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="spline" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: PP = spline (X, Y)
 -- Function File: YI = spline (X, Y, XI)
     Return the cubic spline interpolant of points X and Y.

     When called with two arguments, return the piecewise polynomial PP
     that may be used with 'ppval' to evaluate the polynomial at
     specific points.  When called with a third input argument,
     'spline' evaluates the spline at the points XI.  The third calling
     form 'spline (X, Y, XI)' is equivalent to 'ppval (spline (X, Y),
     XI)'.

     The variable X must be a vector of length N.  Y can be either a
     vector or array.  If Y is a vector it must have a length of either
     N or 'N + 2'.  If the length of Y is N, then the 'not-a-knot' end
     condition is used.  If the length of Y is 'N + 2', then the first
     and last values of the vector Y are the values of the first
     derivative of the cubic spline at the endpoints.

     If Y is an array, then the size of Y must have the form '[S1, S2,
     ..., SK, N]' or '[S1, S2,...

     USE help spline FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="split_long_rows" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: VAL = split_long_rows ()
 -- Built-in Function: OLD_VAL = split_long_rows (NEW_VAL)
 -- Built-in Function:  split_long_rows (NEW_VAL, 'local')
     Query or set the internal variable that controls whether rows of a
     matrix may be split when displayed to a terminal window.  If the
     rows are split, Octave will display the matrix in a series of
     smaller pieces, each of which can fit within the limits of your
     terminal width and each set of rows is labeled so that you can
     easily see which columns are currently being displayed.  For
     example:

          octave:13> rand (2,10)
          ans =

          Columns 1 through 6:

           0.75883  0.93290  0.40064  0.43818  0.94958  0.16467
           0.75697  0.51942  0.40031  0.61784  0.92309  0.40201

          Columns 7 through 10:

           0.90174  0.11854  0.72313  0.73326
           0.44672  0.94303  0.56564  0.82150

     When called from inside a function with the 'local' option, the
 ...

     USE help split_long_rows FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="spones" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: R = spones (S)
     Replace the non-zero entries of S with ones.  This creates a
     sparse matrix with the same structure as S.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="spparms" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function:   spparms ()
 -- Loadable Function: VALS = spparms ()
 -- Loadable Function: [KEYS, VALS] = spparms ()
 -- Loadable Function: VAL = spparms (KEY)
 -- Loadable Function:   spparms (VALS)
 -- Loadable Function:   spparms ('defaults')
 -- Loadable Function:   spparms ('tight')
 -- Loadable Function:   spparms (KEY, VAL)
     Query or set the parameters used by the sparse solvers and
     factorization functions.  The first four calls above get
     information about the current settings, while the others change
     the current settings.  The parameters are stored as pairs of keys
     and values, where the values are all floats and the keys are one
     of the following strings:

    'spumoni'
          Printing level of debugging information of the solvers
          (default 0)

    'ths_rel'
          Included for compatibility.  Not used.  (default 1)

    'ths_abs'
          Included for compatibility.  Not used.  (default 1)

    'exact_d'
          Included f...

     USE help spparms FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="sprand" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  sprand (M, N, D)
 -- Function File:  sprand (S)
     Generate a random sparse matrix.  The size of the matrix will be M
     by N, with a density of values given by D.  D should be between 0
     and 1.  Values will be uniformly distributed between 0 and 1.

     If called with a single matrix argument, a random sparse matrix is
     generated wherever the matrix S is non-zero.

     See also: sprandn, sprandsym


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="sprandn" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  sprandn (M, N, D)
 -- Function File:  sprandn (S)
     Generate a random sparse matrix.  The size of the matrix will be M
     by N, with a density of values given by D.  D should be between 0
     and 1. Values will be normally distributed with mean of zero and
     variance 1.

     If called with a single matrix argument, a random sparse matrix is
     generated wherever the matrix S is non-zero.

     See also: sprand, sprandsym


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="sprandsym" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  sprandsym (N, D)
 -- Function File:  sprandsym (S)
     Generate a symmetric random sparse matrix.  The size of the matrix
     will be N by N, with a density of values given by D.  D should be
     between 0 and 1. Values will be normally distributed with mean of
     zero and variance 1.

     If called with a single matrix argument, a random sparse matrix is
     generated wherever the matrix S is non-zero in its lower
     triangular part.

     See also: sprand, sprandn


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="sprank" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: P = sprank (S)
     Calculate the structural rank of the sparse matrix S.  Note that
     only the structure of the matrix is used in this calculation based
     on a Dulmage-Mendelsohn permutation to block triangular form.  As
     such the numerical rank of the matrix S is bounded by 'sprank (S)
     &gt;= rank (S)'.  Ignoring floating point errors 'sprank (S) == rank
     (S)'.

     See also: dmperm


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="spring" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: MAP = spring ()
 -- Function File: MAP = spring (N)
     Create color colormap.  This colormap varies from magenta to
     yellow.  The argument N must be a scalar.  If unspecified, the
     length of the current colormap, or 64, is used.

     See also: colormap


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="sprintf" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  sprintf (TEMPLATE, ...)
     This is like 'printf', except that the output is returned as a
     string.  Unlike the C library function, which requires you to
     provide a suitably sized string as an argument, Octave's 'sprintf'
     function returns the string, automatically sized to hold all of
     the items converted.

     See also: printf, fprintf, sscanf


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="spstats" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [COUNT, MEAN, VAR] = spstats (S)
 -- Function File: [COUNT, MEAN, VAR] = spstats (S, J)
     Return the stats for the non-zero elements of the sparse matrix S.
     COUNT is the number of non-zeros in each column, MEAN is the mean
     of the non-zeros in each column, and VAR is the variance of the
     non-zeros in each column.

     Called with two input arguments, if S is the data and J is the bin
     number for the data, compute the stats for each bin.  In this
     case, bins can contain data values of zero, whereas with 'spstats
     (S)' the zeros may disappear.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="spy" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  spy (X)
 -- Function File:  spy (..., MARKERSIZE)
 -- Function File:  spy (..., LINE_SPEC)
     Plot the sparsity pattern of the sparse matrix X.  If the argument
     MARKERSIZE is given as a scalar value, it is used to determine the
     point size in the plot.  If the string LINE_SPEC is given it is
     passed to 'plot' and determines the appearance of the plot.

     See also: plot


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="sqp" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [X, OBJ, INFO, ITER, NF, LAMBDA] = sqp (X0, PHI)
 -- Function File: [...] = sqp (X0, PHI, G)
 -- Function File: [...] = sqp (X0, PHI, G, H)
 -- Function File: [...] = sqp (X0, PHI, G, H, LB, UB)
 -- Function File: [...] = sqp (X0, PHI, G, H, LB, UB, MAXITER)
 -- Function File: [...] = sqp (X0, PHI, G, H, LB, UB, MAXITER, TOL)
     Solve the nonlinear program

          min phi (x)
           x

     subject to

          g(x)  = 0
          h(x) &gt;= 0
          lb &lt;= x &lt;= ub

     using a sequential quadratic programming method.

     The first argument is the initial guess for the vector X0.

     The second argument is a function handle pointing to the objective
     function PHI.  The objective function must accept one vector
     argument and return a scalar.

     The second argument may also be a 2- or 3-element cell array of
     function handles.  The first element should point to the objective
     function, the second should point to a function that computes...

     USE help sqp FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="sqrt" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  sqrt (X)
     Compute the square root of each element of X.  If X is negative, a
     complex result is returned.  To compute the matrix square root, see
     *note Linear Algebra::.

     See also: realsqrt, nthroot


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="sqrtm" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: S = sqrtm (A)
 -- Loadable Function: [S, ERROR_ESTIMATE] = sqrtm (A)
     Compute the matrix square root of the square matrix A.

     Ref: N.J. Higham.  'A New sqrtm for MATLAB'.  Numerical Analysis
     Report No. 336, Manchester Centre for Computational Mathematics,
     Manchester, England, January 1999.

     See also: expm, logm


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="squeeze" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  squeeze (X)
     Remove singleton dimensions from X and return the result.  Note
     that for compatibility with MATLAB, all objects have a minimum of
     two dimensions and row vectors are left unchanged.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="ss" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: SYS = ss (SYS)
 -- Function File: SYS = ss (D)
 -- Function File: SYS = ss (A, B)
 -- Function File: SYS = ss (A, B, C)
 -- Function File: SYS = ss (A, B, C, D, ...)
 -- Function File: SYS = ss (A, B, C, D, TSAM, ...)
     Create or convert to state-space model.

     *Inputs*
    SYS
          LTI model to be converted to state-space.

    A
          State transition matrix (n-by-n).

    B
          Input matrix (n-by-m).

    C
          Measurement matrix (p-by-n).  If C is empty '[]' or not
          specified, an identity matrix is assumed.

    D
          Feedthrough matrix (p-by-m).  If D is empty '[]' or not
          specified, a zero matrix is assumed.

    TSAM
          Sampling time in seconds.  If TSAM is not specified, a
          continuous-time model is assumed.

    ...
          Optional pairs of properties and values.  Type 'set (ss)' for
          more information.

     *Outputs*
    SYS
          State-space model.

     *Example*
          ...

     USE help ss FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="sscanf" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: [VAL, COUNT, ERRMSG, POS] = sscanf (STRING,
          TEMPLATE, SIZE)
 -- Built-in Function: [V1, V2, ..., COUNT, ERRMSG] = sscanf (STRING,
          TEMPLATE, 'C')
     This is like 'fscanf', except that the characters are taken from
     the string STRING instead of from a stream.  Reaching the end of
     the string is treated as an end-of-file condition.  In addition to
     the values returned by 'fscanf', the index of the next character
     to be read is returned in POS.

     See also: fscanf, scanf, sprintf


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="stairs" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  stairs (Y)
 -- Function File:  stairs (X, Y)
 -- Function File:  stairs (..., STYLE)
 -- Function File:  stairs (..., PROP, VAL)
 -- Function File:  stairs (H, ...)
 -- Function File: H = stairs (...)
 -- Function File: [XSTEP, YSTEP] = stairs (...)
     Produce a stairstep plot.  The arguments may be vectors or
     matrices.

     If only one argument is given, it is taken as a vector of y-values
     and the x coordinates are taken to be the indices of the elements.

     If one output argument is requested, return a graphics handle to
     the plot.  If two output arguments are specified, the data are
     generated but not plotted.  For example,

          stairs (x, y);

     and

          [xs, ys] = stairs (x, y);
          plot (xs, ys);

     are equivalent.

     See also: plot, semilogx, semilogy, loglog, polar, mesh, contour,
     bar, xlabel, ylabel, title


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="stat" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: [INFO, ERR, MSG] = stat (FILE)
 -- Built-in Function: [INFO, ERR, MSG] = stat (FID)
 -- Built-in Function: [INFO, ERR, MSG] = lstat (FILE)
 -- Built-in Function: [INFO, ERR, MSG] = lstat (FID)
     Return a structure INFO containing the following information about
     FILE or file identifier FID.

    'dev'
          ID of device containing a directory entry for this file.

    'ino'
          File number of the file.

    'mode'
          File mode, as an integer.  Use the functions 'S_ISREG',
          'S_ISDIR', 'S_ISCHR', 'S_ISBLK', 'S_ISFIFO', 'S_ISLNK', or
          'S_ISSOCK' to extract information from this value.

    'modestr'
          File mode, as a string of ten letters or dashes as would be
          returned by 'ls -l'.

    'nlink'
          Number of links.

    'uid'
          User ID of file's owner.

    'gid'
          Group ID of file's group.

    'rdev'
          ID of device for block or character special files.

    'size'
          Si...

     USE help stat FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="statistics" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  statistics (X)
 -- Function File:  statistics (X, DIM)
     Return a vector with the minimum, first quartile, median, third
     quartile, maximum, mean, standard deviation, skewness, and
     kurtosis of the elements of the vector X.

     If X is a matrix, calculate statistics over the first
     non-singleton dimension.  If the optional argument DIM is given,
     operate along this dimension.

     See also: min, max, median, mean, std, skewness, kurtosis


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="std" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  std (X)
 -- Function File:  std (X, OPT)
 -- Function File:  std (X, OPT, DIM)
     Compute the standard deviation of the elements of the vector X.

          std (x) = sqrt ( 1/(N-1) SUM_i (x(i) - mean(x))^2 )

     where N is the number of elements.

     If X is a matrix, compute the standard deviation for each column
     and return them in a row vector.

     The argument OPT determines the type of normalization to use.
     Valid values are

    0:
          normalize with N-1, provides the square root of the best
          unbiased estimator of the variance [default]

    1:
          normalize with N, this provides the square root of the second
          moment around the mean

     If the optional argument DIM is given, operate along this
     dimension.

     See also: var, range, iqr, mean, median


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="stderr" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  stderr ()
     Return the numeric value corresponding to the standard error
     stream.  Even if paging is turned on, the standard error is not
     sent to the pager.  It is useful for error messages and prompts.

     See also: stdin, stdout


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="stdin" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  stdin ()
     Return the numeric value corresponding to the standard input
     stream.  When Octave is used interactively, this is filtered
     through the command line editing functions.

     See also: stdout, stderr


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="stdnormal_cdf" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  stdnormal_cdf (X)
     For each element of X, compute the cumulative distribution
     function (CDF) at X of the standard normal distribution (mean = 0,
     standard deviation = 1).

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="stdnormal_inv" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  stdnormal_inv (X)
     For each element of X, compute the quantile (the inverse of the
     CDF) at X of the standard normal distribution (mean = 0, standard
     deviation = 1).

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="stdnormal_pdf" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  stdnormal_pdf (X)
     For each element of X, compute the probability density function
     (PDF) at X of the standard normal distribution (mean = 0, standard
     deviation = 1).

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="stdnormal_rnd" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  stdnormal_rnd (R)
 -- Function File:  stdnormal_rnd (R, C, ...)
 -- Function File:  stdnormal_rnd ([SZ])
     Return a matrix of random samples from the standard normal
     distribution (mean = 0, standard deviation = 1).

     When called with a single size argument, return a square matrix
     with the dimension specified.  When called with more than one
     scalar argument the first two arguments are taken as the number of
     rows and columns and any further arguments specify additional
     matrix dimensions.  The size may also be specified with a vector
     of dimensions SZ.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="stdout" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  stdout ()
     Return the numeric value corresponding to the standard output
     stream.  Data written to the standard output is normally filtered
     through the pager.

     See also: stdin, stderr


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="stem" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  stem (X)
 -- Function File:  stem (X, Y)
 -- Function File:  stem (X, Y, LINESPEC)
 -- Function File:  stem (..., 'filled')
 -- Function File: H = stem (...)
     Plot a stem graph from two vectors of x-y data.  If only one
     argument is given, it is taken as the y-values and the x
     coordinates are taken from the indices of the elements.

     If Y is a matrix, then each column of the matrix is plotted as a
     separate stem graph.  In this case X can either be a vector, the
     same length as the number of rows in Y, or it can be a matrix of
     the same size as Y.

     The default color is &quot;b&quot; (blue).  The default line style is
     &quot;-&quot; and the default marker is &quot;o&quot;.  The line style can be
     altered by the 'linespec' argument in the same manner as the
     'plot' command.  For example,

          x = 1:10;
          y = 2*x;
          stem (x, y, 'r');

     plots 10 stems with heights from 2 to 20 in red;

     The optional return value H is a...

     USE help stem FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="stem3" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: H = stem3 (X, Y, Z, LINESPEC)
     Plot a three-dimensional stem graph and return the handles of the
     line and marker objects used to draw the stems as 'stem series'
     object.  The default color is &quot;r&quot; (red).  The default line style
     is &quot;-&quot; and the default marker is &quot;o&quot;.

     For example,

          theta = 0:0.2:6;
          stem3 (cos (theta), sin (theta), theta)

     plots 31 stems with heights from 0 to 6 lying on a circle.  Color
     definitions with RGB-triples are not valid!

     See also: bar, barh, stem, plot


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="step" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [Y, T, X] = step (SYS)
 -- Function File: [Y, T, X] = step (SYS, T)
 -- Function File: [Y, T, X] = step (SYS, TFINAL)
 -- Function File: [Y, T, X] = step (SYS, TFINAL, DT)
     Step response of LTI system.  If no output arguments are given,
     the response is printed on the screen.

     *Inputs*
    SYS
          LTI model.

    T
          Time vector.  Should be evenly spaced.  If not specified, it
          is calculated by the poles of the system to reflect
          adequately the response transients.

    TFINAL
          Optional simulation horizon.  If not specified, it is
          calculated by the poles of the system to reflect adequately
          the response transients.

    DT
          Optional sampling time.  Be sure to choose it small enough to
          capture transient phenomena.  If not specified, it is
          calculated by the poles of the system.

     *Outputs*
    Y
          Output response array.  Has as many rows as time samples
   ...

     USE help step FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="stft" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [Y, C] = stft (X, WIN_SIZE, INC, NUM_COEF, WIN_TYPE)
     Compute the short-time Fourier transform of the vector X with
     NUM_COEF coefficients by applying a window of WIN_SIZE data points
     and an increment of INC points.

     Before computing the Fourier transform, one of the following
     windows is applied:

    hanning
          win_type = 1

    hamming
          win_type = 2

    rectangle
          win_type = 3

     The window names can be passed as strings or by the WIN_TYPE
     number.

     If not all arguments are specified, the following defaults are
     used: WIN_SIZE = 80, INC = 24, NUM_COEF = 64, and WIN_TYPE = 1.

     'Y = stft (X, ...)' returns the absolute values of the Fourier
     coefficients according to the NUM_COEF positive frequencies.

     '[Y, C] = stft ('x', ...)' returns the entire STFT-matrix Y and a
     3-element vector C containing the window size, increment, and
     window type, which is needed by the synthesis functio...

     USE help stft FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="str2double" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  str2double (S)
     Convert a string to a real or complex number.

     The string must be in one of the following formats where a and b
     are real numbers and the complex unit is 'i' or 'j':

        * a + bi

        * a + b*i

        * a + i*b

        * bi + a

        * b*i + a

        * i*b + a

     If present, a and/or b are of the form [+-]d[,.]d[[eE][+-]d] where
     the brackets indicate optional arguments and 'd' indicates zero or
     more digits.  The special input values 'Inf', 'NaN', and 'NA' are
     also accepted.

     S may also be a character matrix, in which case the conversion is
     repeated for each row.  Or S may be a cell array of strings, in
     which case each element is converted and an array of the same
     dimensions is returned.

     'str2double' returns NaN for elements of S which cannot be
     converted.

     'str2double' can replace 'str2num', and it avoids the security
     risk of using 'eval' on unknown data.

  ...

     USE help str2double FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="str2func" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  str2func (FCN_NAME)
 -- Built-in Function:  str2func (FCN_NAME, 'global')
     Return a function handle constructed from the string FCN_NAME.  If
     the optional 'global' argument is passed, locally visible functions
     are ignored in the lookup.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="str2num" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: X = str2num (S)
 -- Function File: [X, STATE] = str2num (S)
     Convert the string (or character array) S to a number (or an
     array).  Examples:

          str2num ('3.141596')
                => 3.141596

          str2num (['1, 2, 3'; '4, 5, 6'])
                => 1  2  3
                   4  5  6

     The optional second output, STATE, is logically true when the
     conversion is successful.  If the conversion fails the numeric
     output, X, is empty and STATE is false.

     *Caution:* As 'str2num' uses the 'eval' function to do the
     conversion, 'str2num' will execute any code contained in the
     string S.  Use 'str2double' for a safer and faster conversion.

     For cell array of strings use 'str2double'.

     See also: str2double, eval


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="strcat" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  strcat (S1, S2, ...)
     Return a string containing all the arguments concatenated
     horizontally.  If the arguments are cells strings,  'strcat'
     returns a cell string with the individual cells concatenated.  For
     numerical input, each element is converted to the corresponding
     ASCII character.  Trailing white space is eliminated.  For example:

          s = [ 'ab'; 'cde' ];
          strcat (s, s, s)
              =>
                  'ab ab ab '
                  'cdecdecde'

          s = { 'ab'; 'cde' };
          strcat (s, s, s)
              =>
                  {
                    [1,1] = ababab
                    [2,1] = cdecdecde
                  }

     See also: cstrcat, char, strvcat


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="strchr" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: IDX = strchr (STR, CHARS)
 -- Function File: IDX = strchr (STR, CHARS, N)
 -- Function File: IDX = strchr (STR, CHARS, N, DIRECTION)
 -- Function File: [I, J] = strchr (...)
     Search for the string STR for occurrences of characters from the
     set CHARS.  The return value(s), as well as the N and DIRECTION
     arguments behave identically as in 'find'.

     This will be faster than using regexp in most cases.

     See also: find


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="strcmp" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  strcmp (S1, S2)
     Return 1 if the character strings S1 and S2 are the same, and 0
     otherwise.

     If either S1 or S2 is a cell array of strings, then an array of
     the same size is returned, containing the values described above
     for every member of the cell array.  The other argument may also
     be a cell array of strings (of the same size or with only one
     element), char matrix or character string.

     *Caution:* For compatibility with MATLAB, Octave's strcmp function
     returns 1 if the character strings are equal, and 0 otherwise.
     This is just the opposite of the corresponding C library function.

     See also: strcmpi, strncmp, strncmpi


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="strcmpi" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  strcmpi (S1, S2)
     Return 1 if the character strings S1 and S2 are the same,
     disregarding case of alphabetic characters, and 0 otherwise.

     If either S1 or S2 is a cell array of strings, then an array of
     the same size is returned, containing the values described above
     for every member of the cell array.  The other argument may also
     be a cell array of strings (of the same size or with only one
     element), char matrix or character string.

     *Caution:* For compatibility with MATLAB, Octave's strcmp function
     returns 1 if the character strings are equal, and 0 otherwise.
     This is just the opposite of the corresponding C library function.

     *Caution:* National alphabets are not supported.

     See also: strcmp, strncmp, strncmpi


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="strfind" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: IDX = strfind (STR, PATTERN)
 -- Loadable Function: IDX = strfind (CELLSTR, PATTERN)
     Search for PATTERN in the string STR and return the starting index
     of every such occurrence in the vector IDX.  If there is no such
     occurrence, or if PATTERN is longer than STR, then IDX is the
     empty array '[]'.

     If a cell array of strings CELLSTR is specified then IDX is a cell
     array of vectors, as specified above.  Examples:

          strfind ('abababa', 'aba')
              => [1, 3, 5]

          strfind ({'abababa', 'bebebe', 'ab'}, 'aba')
              => ans =
                 {
                   [1,1] =

                      1   3   5

                   [1,2] = [](1x0)
                   [1,3] = [](1x0)
                 }

     See also: findstr, strmatch, regexp, regexpi, find


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="strftime" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function:  strftime (FMT, TM_STRUCT)
     Format the time structure TM_STRUCT in a flexible way using the
     format string FMT that contains '%' substitutions similar to those
     in 'printf'.  Except where noted, substituted fields have a fixed
     size; numeric fields are padded if necessary.  Padding is with
     zeros by default; for fields that display a single number, padding
     can be changed or inhibited by following the '%' with one of the
     modifiers described below.  Unknown field specifiers are copied as
     normal characters.  All other characters are copied to the output
     without change.  For example:

          strftime ('%r (%Z) %A %e %B %Y', localtime (time ()))
              => '01:15:06 AM (CST) Monday 17 February 1997'

     Octave's 'strftime' function supports a superset of the ANSI C
     field specifiers.

     Literal character fields:

    '%%'
          % character.

    '%n'
          Newline character.

    '%t'
          Tab char...

     USE help strftime FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="string_fill_char" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: VAL = string_fill_char ()
 -- Built-in Function: OLD_VAL = string_fill_char (NEW_VAL)
 -- Built-in Function:  string_fill_char (NEW_VAL, 'local')
     Query or set the internal variable used to pad all rows of a
     character matrix to the same length.  It must be a single
     character.  The default value is &quot; &quot; (a single space).  For
     example:

          string_fill_char ('X');
          [ 'these'; 'are'; 'strings' ]
              => 'theseXX'
                 'areXXXX'
                 'strings'

     When called from inside a function with the 'local' option, the
     variable is changed locally for the function and any subroutines
     it calls.  The original variable value is restored when exiting
     the function.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="strjust" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  strjust (S)
 -- Function File:  strjust (S, POS)
     Return the text, S, justified according to POS, which may be
     &quot;left&quot;, &quot;center&quot;, or &quot;right&quot;.  If POS is omitted it defaults
     to &quot;right&quot;.

     Null characters are replaced by spaces.  All other character data
     are treated as non-white space.

     Example:

          strjust (['a'; 'ab'; 'abc'; 'abcd'])
               =>
                  '   a'
                  '  ab'
                  ' abc'
                  'abcd'

     See also: deblank, strrep, strtrim, untabify


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="strmatch" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  strmatch (S, A)
 -- Function File:  strmatch (S, A, 'exact')
     Return indices of entries of A which begin with the string S.  The
     second argument A must be a string, character matrix, or a cell
     array of strings.  If the third argument &quot;exact&quot; is not given,
     then S only needs to match A up to the length of S.  Trailing
     spaces and nulls in S and A are ignored when matching.  option.

     For example:

          strmatch ('apple', 'apple juice')
               => 1

          strmatch ('apple', ['apple  '; 'apple juice'; 'an apple'])
               => [1; 2]

          strmatch ('apple', ['apple  '; 'apple juice'; 'an apple'], 'exact')
               => [1]

     *Caution:* 'strmatch' is scheduled for deprecation.  Use 'strcmpi'
     or 'strncmpi' in all new code.

     See also: strfind, findstr, strcmp, strncmp, strcmpi, strncmpi,
     find


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="strncmp" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  strncmp (S1, S2, N)
     Return 1 if the first N characters of strings S1 and S2 are the
     same, and 0 otherwise.

          strncmp ('abce', 'abcd', 3)
              => 1

     If either S1 or S2 is a cell array of strings, then an array of
     the same size is returned, containing the values described above
     for every member of the cell array.  The other argument may also
     be a cell array of strings (of the same size or with only one
     element), char matrix or character string.

          strncmp ('abce', {'abcd', 'bca', 'abc'}, 3)
              => [1, 0, 1]

     *Caution:* For compatibility with MATLAB, Octave's strncmp
     function returns 1 if the character strings are equal, and 0
     otherwise.  This is just the opposite of the corresponding C
     library function.

     See also: strncmpi, strcmp, strcmpi


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="strncmpi" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  strncmpi (S1, S2, N)
     Return 1 if the first N character of S1 and S2 are the same,
     disregarding case of alphabetic characters, and 0 otherwise.

     If either S1 or S2 is a cell array of strings, then an array of
     the same size is returned, containing the values described above
     for every member of the cell array.  The other argument may also
     be a cell array of strings (of the same size or with only one
     element), char matrix or character string.

     *Caution:* For compatibility with MATLAB, Octave's strncmpi
     function returns 1 if the character strings are equal, and 0
     otherwise.  This is just the opposite of the corresponding C
     library function.

     *Caution:* National alphabets are not supported.

     See also: strncmp, strcmp, strcmpi


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="strptime" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: [TM_STRUCT, NCHARS] = strptime (STR, FMT)
     Convert the string STR to the time structure TM_STRUCT under the
     control of the format string FMT.

     If FMT fails to match, NCHARS is 0; otherwise, it is set to the
     position of last matched character plus 1. Always check for this
     unless you're absolutely sure the date string will be parsed
     correctly.

     See also: strftime, localtime, gmtime, mktime, time, now, date,
     clock, datenum, datestr, datevec, calendar, weekday


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="strread" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [A, ...] = strread (STR)
 -- Function File: [A, ...] = strread (STR, FORMAT)
 -- Function File: [A, ...] = strread (STR, FORMAT, FORMAT_REPEAT)
 -- Function File: [A, ...] = strread (STR, FORMAT, PROP1, VALUE1, ...)
 -- Function File: [A, ...] = strread (STR, FORMAT, FORMAT_REPEAT,
          PROP1, VALUE1, ...)
     Read data from a string.

     The string STR is split into words that are repeatedly matched to
     the specifiers in FORMAT.  The first word is matched to the first
     specifier, the second to the second specifier and so forth.  If
     there are more words than specifiers, the process is repeated
     until all words have been processed.

     The string FORMAT describes how the words in STR should be parsed.
     It may contain any combination of the following specifiers:

    '%s'
          The word is parsed as a string.

    '%f'
    '%n'
          The word is parsed as a number and converted to double.

    '%d'
    '%u'
          The word is p...

     USE help strread FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="strrep" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function:  strrep (S, PTN, REP)
 -- Loadable Function:  strrep (S, PTN, REP, 'overlaps', O)
     Replace all occurrences of the substring PTN in the string S with
     the string REP and return the result.  For example:

          strrep ('This is a test string', 'is', '&amp;%$')
              => 'Th&amp;%$ &amp;%$ a test string'

     S may also be a cell array of strings, in which case the
     replacement is done for each element and a cell array is returned.

     See also: regexprep, strfind, findstr


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="strseq" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: STRVEC = strseq (STR, IDX)
     Return a cell vector of indexed strings by appending the indices
     IDX to the string STR.

          strseq ('x', 1:3) = {'x1'; 'x2'; 'x3'}
          strseq ('u', [1, 2, 5]) = {'u1'; 'u2'; 'u5'}

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="strsplit" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [CSTR] = strsplit (S, SEP)
 -- Function File: [CSTR] = strsplit (S, SEP, STRIP_EMPTY)
     Split the string S using one or more separators SEP and return a
     cell array of strings.  Consecutive separators and separators at
     boundaries result in empty strings, unless STRIP_EMPTY is true.
     The default value of STRIP_EMPTY is false.

     2-D character arrays are split at separators and at the original
     column boundaries.

     Example:

          strsplit ('a,b,c', ',')
                =>
                    {
                      [1,1] = a
                      [1,2] = b
                      [1,3] = c
                    }

          strsplit (['a,b' ; 'cde'], ',')
                =>
                    {
                      [1,1] = a
                      [1,2] = b
                      [1,3] = cde
                    }

     See also: strtok


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="strtok" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [TOK, REM] = strtok (STR)
 -- Function File: [TOK, REM] = strtok (STR, DELIM)
     Find all characters in the string STR up to, but not including, the
     first character which is in the string DELIM.  If REM is
     requested, it contains the remainder of the string, starting at
     the first delimiter.  Leading delimiters are ignored.  If DELIM is
     not specified, whitespace is assumed.  STR may also be a cell
     array of strings in which case the function executes on every
     individual string and returns a cell array of tokens and
     remainders.

     Examples:

          strtok ('this is the life')
               => 'this'

          [tok, rem] = strtok ('14*27+31', '+-*/')
               =>
                  tok = 14
                  rem = *27+31

     See also: index, strsplit, strchr, isspace


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="strtrim" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  strtrim (S)
     Remove leading and trailing whitespace from S.  If S is a matrix,
     STRTRIM trims each row to the length of longest string.  If S is a
     cell array of strings, operate recursively on each string element.
     For example:

          strtrim ('    abc  ')
               =>  'abc'

          strtrim ([' abc   '; '   def   '])
               =>  ['abc  '  ; '  def']

     See also: deblank


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="strtrunc" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  strtrunc (S, N)
     Truncate the character string S to length N.  If S is a character
     matrix, then the number of columns is adjusted.  If S is a cell
     array of strings, then the operation is performed on each cell
     element and the new cell array is returned.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="struct" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  struct ('field', VALUE, 'field', VALUE, ...)
     Create a structure and initialize its value.

     If the values are cell arrays, create a structure array and
     initialize its values.  The dimensions of each cell array of
     values must match.  Singleton cells and non-cell values are
     repeated so that they fill the entire array.  If the cells are
     empty, create an empty structure array with the specified field
     names.

     If the argument is an object, return the underlying struct.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="struct_levels_to_print" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: VAL = struct_levels_to_print ()
 -- Built-in Function: OLD_VAL = struct_levels_to_print (NEW_VAL)
 -- Built-in Function:  struct_levels_to_print (NEW_VAL, 'local')
     Query or set the internal variable that specifies the number of
     structure levels to display.

     When called from inside a function with the 'local' option, the
     variable is changed locally for the function and any subroutines
     it calls.  The original variable value is restored when exiting
     the function.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="struct2cell" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  struct2cell (S)
     Create a new cell array from the objects stored in the struct
     object.  If F is the number of fields in the structure, the
     resulting cell array will have a dimension vector corresponding to
     '[F size(S)]'.  For example:

           s = struct('name', {'Peter', 'Hannah', 'Robert'},
                      'age', {23, 16, 3});
           c = struct2cell(s)
              => c = {1x1x3 Cell Array}
           c(1,1,:)(:)
              => ans =
                 {
                   [1,1] = Peter
                   [2,1] = Hannah
                   [3,1] = Robert
                 }
           c(2,1,:)(:)
              => ans =
                 {
                   [1,1] = 23
                   [2,1] = 16
                   [3,1] = 3
                 }

     See also: cell2struct, fieldnames


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="structfun" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  structfun (FUNC, S)
 -- Function File: [A, ...] = structfun (...)
 -- Function File:  structfun (..., 'ErrorHandler', ERRFUNC)
 -- Function File:  structfun (..., 'UniformOutput', VAL)
     Evaluate the function named NAME on the fields of the structure S.
     The fields of S are passed to the function FUNC individually.

     'structfun' accepts an arbitrary function FUNC in the form of an
     inline function, function handle, or the name of a function (in a
     character string).  In the case of a character string argument, the
     function must accept a single argument named X, and it must return
     a string value.  If the function returns more than one argument,
     they are returned as separate output variables.

     If the parameter 'UniformOutput' is set to true (the default),
     then the function must return a single element which will be
     concatenated into the return value.  If 'UniformOutput' is false,
     the outputs are placed into a struc...

     USE help structfun FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="strvcat" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  strvcat (X)
 -- Built-in Function:  strvcat (X, ...)
 -- Built-in Function:  strvcat (S1, S2, ...)
 -- Built-in Function:  strvcat (CELL_ARRAY)
     Create a character array from one or more numeric matrices,
     character matrices, or cell arrays.  Arguments are concatenated
     vertically.  The returned values are padded with blanks as needed
     to make each row of the string array have the same length.  Unlike
     'char', empty strings are removed and will not appear in the
     output.

     For numerical input, each element is converted to the
     corresponding ASCII character.  A range error results if an input
     is outside the ASCII range (0-255).

     For cell arrays, each element is concatenated separately.  Cell
     arrays converted through 'strvcat' can mostly be converted back
     with 'cellstr'.  For example:

          strvcat ([97, 98, 99], &quot;, {'98', '99', 100}, 'str1', ['ha', 'lf'])
              => ['abc    '
                  '98  ...

     USE help strvcat FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="sub2ind" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: IND = sub2ind (DIMS, I, J)
 -- Function File: IND = sub2ind (DIMS, S1, S2, ..., SN)
     Convert subscripts to a linear index.

     The following example shows how to convert the two-dimensional
     index '(2,3)' of a 3-by-3 matrix to a linear index.  The matrix is
     linearly indexed moving from one column to next, filling up all
     rows in each column.

          linear_index = sub2ind ([3, 3], 2, 3)
          => 8

     See also: ind2sub


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="subplot" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  subplot (ROWS, COLS, INDEX)
 -- Function File:  subplot (RCN)
     Set up a plot grid with ROWS by COLS subwindows and plot in
     location given by INDEX.

     If only one argument is supplied, then it must be a three digit
     value specifying the location in digits 1 (rows) and 2 (columns)
     and the plot index in digit 3.

     The plot index runs row-wise.  First all the columns in a row are
     filled and then the next row is filled.

     For example, a plot with 2 by 3 grid will have plot indices
     running as follows:

          +-----+-----+-----+
          |  1  |  2  |  3  |
          +-----+-----+-----+
          |  4  |  5  |  6  |
          +-----+-----+-----+

     INDEX may be a vector.  In which case, the new axis will enclose
     the grid locations specified.  The first demo illustrates an
     example:

          demo ('subplot', 1)

     See also: axes, plot


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="subsasgn" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  subsasgn (VAL, IDX, RHS)
     Perform the subscripted assignment operation according to the
     subscript specified by IDX.

     The subscript IDX is expected to be a structure array with fields
     'type' and 'subs'.  Valid values for 'type' are &quot;()&quot;, &quot;{}&quot;,
     and &quot;.&quot;.  The 'subs' field may be either &quot;:&quot; or a cell array
     of index values.

     The following example shows how to set the two first columns of a
     3-by-3 matrix to zero.

          val = magic(3);
          idx.type = '()';
          idx.subs = {':', 1:2};
          subsasgn (val, idx, 0)
              => [ 0   0   6
                   0   0   7
                   0   0   2 ]

     Note that this is the same as writing 'val(:,1:2) = 0'.

     If IDX is an empty structure array with fields 'type' and 'subs',
     return RHS.

     See also: subsref, substruct


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="subsindex" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: IDX = subsindex (A)
     Convert an object to an index vector.  When A is a class object
     defined with a class constructor, then 'subsindex' is the
     overloading method that allows the conversion of this class object
     to a valid indexing vector.  It is important to note that
     'subsindex' must return a zero-based real integer vector of the
     class 'double'.  For example, if the class constructor

          function b = myclass (a)
            b = class (struct ('a', a), 'myclass');
          endfunction

     then the 'subsindex' function

          function idx = subsindex (a)
            idx = double (a.a) - 1.0;
          endfunction

     can then be used as follows

          a = myclass (1:4);
          b = 1:10;
          b(a)
          => 1  2  3  4

     See also: class, subsref, subsasgn


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="subspace" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: ANGLE = subspace (A, B)
     Determine the largest principal angle between two subspaces
     spanned by the columns of matrices A and B.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="subsref" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  subsref (VAL, IDX)
     Perform the subscripted element selection operation according to
     the subscript specified by IDX.

     The subscript IDX is expected to be a structure array with fields
     'type' and 'subs'.  Valid values for 'type' are &quot;()&quot;, &quot;{}&quot;,
     and &quot;.&quot;.  The 'subs' field may be either &quot;:&quot; or a cell array
     of index values.

     The following example shows how to extract the two first columns of
     a matrix

          val = magic(3)
              => val = [ 8   1   6
                         3   5   7
                         4   9   2 ]
          idx.type = '()';
          idx.subs = {':', 1:2};
          subsref(val, idx)
              => [ 8   1
                   3   5
                   4   9 ]

     Note that this is the same as writing 'val(:,1:2)'.

     If IDX is an empty structure array with fields 'type' and 'subs',
     return VAL.

     See also: subsasgn, substruct


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="substr" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  substr (S, OFFSET)
 -- Function File:  substr (S, OFFSET, LEN)
     Return the substring of S which starts at character number OFFSET
     and is LEN characters long.

     Position numbering for offsets begins with 1.  If OFFSET is
     negative, extraction starts that far from the end of the string.

     If LEN is omitted, the substring extends to the end of S.  A
     negative value for LEN extracts to within LEN characters of the
     end of the string

     Examples:

          substr ('This is a test string', 6, 9)
               => 'is a test'
          substr ('This is a test string', -11)
               => 'test string'
          substr ('This is a test string', -11, -7)
               => 'test'

     This function is patterned after the equivalent function in Perl.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="substruct" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  substruct (TYPE, SUBS, ...)
     Create a subscript structure for use with 'subsref' or 'subsasgn'.
     For example:

          idx = substruct ('()', {3, ':'})
               =>
                 idx =
                 {
                   type = ()
                   subs =
                   {
                     [1,1] =  3
                     [1,2] = :
                   }
                 }
          x = [1, 2, 3; 4, 5, 6; 7, 8, 9];
          subsref (x, idx)
             => 7  8  9

     See also: subsref, subsasgn


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="sum" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  sum (X)
 -- Built-in Function:  sum (X, DIM)
 -- Built-in Function:  sum (..., 'native')
 -- Built-in Function:  sum (..., 'double')
 -- Built-in Function:  sum (..., 'extra')
     Sum of elements along dimension DIM.  If DIM is omitted, it
     defaults to the first non-singleton dimension.

     If the optional argument 'native' is given, then the sum is
     performed in the same type as the original argument, rather than
     in the default double type.  For example:

          sum ([true, true])
           => 2
          sum ([true, true], 'native')
           => true

     On the contrary, if 'double' is given, the sum is performed in
     double precision even for single precision inputs.

     For double precision inputs, 'extra' indicates that a more
     accurate algorithm than straightforward summation is to be used.
     For single precision inputs, 'extra' is the same as 'double'.
     Otherwise, 'extra' has no effect.

     See also: cumsum, sumsq,...

     USE help sum FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="summer" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: MAP = summer ()
 -- Function File: MAP = summer (N)
     Create color colormap.  This colormap varies from green to yellow.
     The argument N must be a scalar.  If unspecified, the length of
     the current colormap, or 64, is used.

     See also: colormap


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="sumsq" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  sumsq (X)
 -- Built-in Function:  sumsq (X, DIM)
     Sum of squares of elements along dimension DIM.  If DIM is
     omitted, it defaults to the first non-singleton dimension.

     This function is conceptually equivalent to computing

          sum (x .* conj (x), dim)

     but it uses less memory and avoids calling 'conj' if X is real.

     See also: sum


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="superiorto" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  superiorto (CLASS_NAME, ...)
     When called from a class constructor, mark the object currently
     constructed as having a higher precedence than CLASS_NAME.  More
     that one such class can be specified in a single call.  This
     function may only be called from a class constructor.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="suppress_verbose_help_message" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: VAL = suppress_verbose_help_message ()
 -- Built-in Function: OLD_VAL = suppress_verbose_help_message (NEW_VAL)
 -- Built-in Function:  suppress_verbose_help_message (NEW_VAL, 'local')
     Query or set the internal variable that controls whether Octave
     will add additional help information to the end of the output from
     the 'help' command and usage messages for built-in commands.

     When called from inside a function with the 'local' option, the
     variable is changed locally for the function and any subroutines
     it calls.  The original variable value is restored when exiting
     the function.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="surf" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  surf (X, Y, Z)
 -- Function File:  surf (Z)
 -- Function File:  surf (..., C)
 -- Function File:  surf (HAX, ...)
 -- Function File: H = surf (...)
     Plot a surface given matrices X, and Y from 'meshgrid' and a
     matrix Z corresponding to the X and Y coordinates of the mesh.  If
     X and Y are vectors, then a typical vertex is (X(j), Y(i),
     Z(i,j)).  Thus, columns of Z correspond to different X values and
     rows of Z correspond to different Y values.

     The color of the surface is derived from the 'colormap' and the
     value of Z.  Optionally the color of the surface can be specified
     independent of Z, by adding a fourth matrix, C.

     The optional return value H is a graphics handle to the created
     surface object.

     See also: colormap, contour, meshgrid, mesh


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="surface" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  surface (X, Y, Z, C)
 -- Function File:  surface (X, Y, Z)
 -- Function File:  surface (Z, C)
 -- Function File:  surface (Z)
 -- Function File:  surface (..., PROP, VAL)
 -- Function File:  surface (H, ...)
 -- Function File: H = surface (...)
     Plot a surface graphic object given matrices X, and Y from
     'meshgrid' and a matrix Z corresponding to the X and Y coordinates
     of the surface.  If X and Y are vectors, then a typical vertex is
     (X(j), Y(i), Z(i,j)).  Thus, columns of Z correspond to different
     X values and rows of Z correspond to different Y values.  If X and
     Y are missing, they are constructed from size of the matrix Z.

     Any additional properties passed are assigned to the surface.

     The optional return value H is a graphics handle to the created
     surface object.

     See also: surf, mesh, patch, line


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="surfc" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  surfc (X, Y, Z)
     Plot a surface and contour given matrices X, and Y from 'meshgrid'
     and a matrix Z corresponding to the X and Y coordinates of the
     mesh.  If X and Y are vectors, then a typical vertex is (X(j),
     Y(i), Z(i,j)).  Thus, columns of Z correspond to different X
     values and rows of Z correspond to different Y values.

     See also: meshgrid, surf, contour


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="surfl" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  surfl (X, Y, Z)
 -- Function File:  surfl (Z)
 -- Function File:  surfl (X, Y, Z, L)
 -- Function File:  surfl (X, Y, Z, L, P)
 -- Function File:  surfl (..., 'light')
     Plot a lighted surface given matrices X, and Y from 'meshgrid' and
     a matrix Z corresponding to the X and Y coordinates of the mesh.
     If X and Y are vectors, then a typical vertex is (X(j), Y(i),
     Z(i,j)).  Thus, columns of Z correspond to different X values and
     rows of Z correspond to different Y values.

     The light direction can be specified using L.  It can be given as
     2-element vector [azimuth, elevation] in degrees or as 3-element
     vector [lx, ly, lz].  The default value is rotated 45 degrees
     counter-clockwise from the current view.

     The material properties of the surface can specified using a
     4-element vector P = [AM D SP EXP] which defaults to P = [0.55 0.6
     0.4 10].
    'AM' strength of ambient light

    'D' strength of diffuse reflection

    '...

     USE help surfl FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="surfnorm" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  surfnorm (X, Y, Z)
 -- Function File:  surfnorm (Z)
 -- Function File: [NX, NY, NZ] = surfnorm (...)
 -- Function File:  surfnorm (H, ...)
     Find the vectors normal to a meshgridded surface.  The meshed
     gridded surface is defined by X, Y, and Z.  If X and Y are not
     defined, then it is assumed that they are given by

          [X, Y] = meshgrid (1:size (Z, 1),
                             1:size (Z, 2));

     If no return arguments are requested, a surface plot with the
     normal vectors to the surface is plotted.  Otherwise the
     components of the normal vectors at the mesh gridded points are
     returned in NX, NY, and NZ.

     The normal vectors are calculated by taking the cross product of
     the diagonals of each of the quadrilaterals in the meshgrid to
     find the normal vectors of the centers of these quadrilaterals.
     The four nearest normal vectors to the meshgrid points are then
     averaged to obtain the normal to the surface a...

     USE help surfnorm FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="svd" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: S = svd (A)
 -- Loadable Function: [U, S, V] = svd (A)
 -- Loadable Function: [U, S, V] = svd (A, ECON)
     Compute the singular value decomposition of A

          A = U*S*V'

     The function 'svd' normally returns only the vector of singular
     values.  When called with three return values, it computes U, S,
     and V.  For example,

          svd (hilb (3))

     returns

          ans =

           1.4083189
           0.1223271
           0.0026873

     and

          [u, s, v] = svd (hilb (3))

     returns

          u =

           -0.82704   0.54745   0.12766
           -0.45986  -0.52829  -0.71375
           -0.32330  -0.64901   0.68867

          s =

           1.40832  0.00000  0.00000
           0.00000  0.12233  0.00000
           0.00000  0.00000  0.00269

          v =

           -0.82704   0.54745   0.12766
           -0.45986  -0.52829  -0.71375
           -0.32330  -0.64901   0.68867

     If given a second argument, 'svd' returns an e...

     USE help svd FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="svd_driver" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: VAL = svd_driver ()
 -- Loadable Function: OLD_VAL = svd_driver (NEW_VAL)
 -- Loadable Function:  svd_driver (NEW_VAL, 'local')
     Query or set the underlying LAPACK driver used by 'svd'.
     Currently recognized values are 'gesvd' and 'gesdd'.  The default
     is 'gesvd'.

     When called from inside a function with the 'local' option, the
     variable is changed locally for the function and any subroutines
     it calls.  The original variable value is restored when exiting
     the function.

     See also: svd


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="svds" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: S = svds (A)
 -- Function File: S = svds (A, K)
 -- Function File: S = svds (A, K, SIGMA)
 -- Function File: S = svds (A, K, SIGMA, OPTS)
 -- Function File: [U, S, V] = svds (...)
 -- Function File: [U, S, V, FLAG] = svds (...)
     Find a few singular values of the matrix A.  The singular values
     are calculated using

          [M, N] = size (A);
          S = eigs ([sparse(M, M), A;
                               A', sparse(N, N)])

     The eigenvalues returned by 'eigs' correspond to the singular
     values of A.  The number of singular values to calculate is given
     by K and defaults to 6.

     The argument SIGMA specifies which singular values to find.  When
     SIGMA is the string 'L', the default, the largest singular values
     of A are found.  Otherwise, SIGMA must be a real scalar and the
     singular values closest to SIGMA are found.  As a corollary,
     'SIGMA = 0' finds the smallest singular values.  Note that for
     relatively small val...

     USE help svds FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="swapbytes" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  swapbytes (X)
     Swap the byte order on values, converting from little endian to big
     endian and vice versa.  For example:

          swapbytes (uint16 (1:4))
          => [   256   512   768  1024]

     See also: typecast, cast


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="syl" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: X = syl (A, B, C)
     Solve the Sylvester equation

          A X + X B + C = 0

     using standard LAPACK subroutines.  For example:

          syl ([1, 2; 3, 4], [5, 6; 7, 8], [9, 10; 11, 12])
              => [ -0.50000, -0.66667; -0.66667, -0.50000 ]

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="symamd" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: P = symamd (S)
 -- Loadable Function: P = symamd (S, KNOBS)
 -- Loadable Function: [P, STATS] = symamd (S)
 -- Loadable Function: [P, STATS] = symamd (S, KNOBS)
     For a symmetric positive definite matrix S, returns the permutation
     vector p such that 'S(P, P)' tends to have a sparser
     Cholesky factor than S.  Sometimes 'symamd' works well for
     symmetric indefinite matrices too.  The matrix S is assumed to be
     symmetric; only the strictly lower triangular part is referenced.
     S must be square.

     KNOBS is an optional one- to two-element input vector.  If S is
     n-by-n, then rows and columns with more than
     'max(16,KNOBS(1)*sqrt(n))' entries are removed prior to ordering,
     and ordered last in the output permutation P.  No rows/columns are
     removed if 'KNOBS(1) &lt; 0'.  If 'KNOBS (2)' is nonzero, 'stats' and
     KNOBS are printed.  The default is 'KNOBS = [10 0]'.  Note that
     KNOBS differs from earlier versions of symamd.
...

     USE help symamd FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="symbfact" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: [COUNT, H, PARENT, POST, R] = symbfact (S)
 -- Loadable Function: [...] = symbfact (S, TYP)
 -- Loadable Function: [...] = symbfact (S, TYP, MODE)
     Perform a symbolic factorization analysis on the sparse matrix S.
     Where

    S
          S is a complex or real sparse matrix.

    TYP
          Is the type of the factorization and can be one of

         'sym'
               Factorize S.  This is the default.

         'col'
               Factorize 'S' * S'.

         'row'
               Factorize S * S'.

         'lo'
               Factorize S'

    MODE
          The default is to return the Cholesky factorization for R,
          and if MODE is 'L', the conjugate transpose of the
          Cholesky factorization is returned.  The conjugate transpose
          version is faster and uses less memory, but returns the same
          values for COUNT, H, PARENT and POST outputs.

     The output variables are

    COUNT
          The row counts of the Ch...

     USE help symbfact FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="symlink" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: [ERR, MSG] = symlink (OLD, NEW)
     Create a symbolic link NEW which contains the string OLD.

     If successful, ERR is 0 and MSG is an empty string.  Otherwise,
     ERR is nonzero and MSG contains a system-dependent error message.

     See also: link, readlink


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="symrcm" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: P = symrcm (S)
     Return the symmetric reverse Cuthill-McKee permutation of S.  P is
     a permutation vector such that 'S(P, P)' tends to have its
     diagonal elements closer to the diagonal than S.  This is a good
     preordering for LU or Cholesky factorization of matrices that come
     from 'long, skinny' problems.  It works for both symmetric and
     asymmetric S.

     The algorithm represents a heuristic approach to the NP-complete
     bandwidth minimization problem.  The implementation is based in the
     descriptions found in

     E. Cuthill, J. McKee. 'Reducing the Bandwidth of Sparse Symmetric
     Matrices'. Proceedings of the 24th ACM National Conference, 157-172
     1969, Brandon Press, New Jersey.

     A. George, J.W.H. Liu. 'Computer Solution of Large Sparse Positive
     Definite Systems', Prentice Hall Series in Computational
     Mathematics, ISBN 0-13-165274-5, 1981.

     See also: colperm, colamd, symamd


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="symvar" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  symvar (S)
     Identify the argument names in the function defined by a string.
     Common constant names such as 'pi', 'NaN', 'Inf', 'eps', 'i' or
     'j' are ignored.  The arguments that are found are returned in a
     cell array of strings.  If no variables are found then the
     returned cell array is empty.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="synthesis" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  synthesis (Y, C)
     Compute a signal from its short-time Fourier transform Y and a
     3-element vector C specifying window size, increment, and window
     type.

     The values Y and C can be derived by

          [Y, C] = stft (X , ...)

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="system" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  system ('STRING')
 -- Built-in Function:  system ('STRING', RETURN_OUTPUT)
 -- Built-in Function:  system ('STRING', RETURN_OUTPUT, TYPE)
 -- Built-in Function: [STATUS, OUTPUT] = system (...)
     Execute a shell command specified by STRING.  If the optional
     argument TYPE is 'async', the process is started in the background
     and the process ID of the child process is returned immediately.
     Otherwise, the child process is started and Octave waits until it
     exits.  If the TYPE argument is omitted, it defaults to the value
     'sync'.

     If SYSTEM is called with one or more output arguments, or if the
     optional argument RETURN_OUTPUT is true and the subprocess is
     started synchronously, then the output from the command is
     returned as a variable.  Otherwise, if the subprocess is executed
     synchronously, its output is sent to the standard output.  To send
     the output of a command executed with 'system' through the pager,
   ...

     USE help system FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="t_test" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [PVAL, T, DF] = t_test (X, M, ALT)
     For a sample X from a normal distribution with unknown mean and
     variance, perform a t-test of the null hypothesis 'mean (X) == M'.
     Under the null, the test statistic T follows a Student
     distribution with 'DF = length (X) - 1' degrees of freedom.

     With the optional argument string ALT, the alternative of interest
     can be selected.  If ALT is &quot;!=&quot; or &quot;&lt;%gt;&quot;, the null is tested
     against the two-sided alternative 'mean (X) != M'.  If ALT is
     &quot;&gt;&quot;, the one-sided alternative 'mean (X) &gt; M' is considered.
     Similarly for '&lt;', the one-sided alternative 'mean (X) &lt; M' is
     considered.  The default is the two-sided case.

     The p-value of the test is returned in PVAL.

     If no output argument is given, the p-value of the test is
     displayed.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="t_test_2" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [PVAL, T, DF] = t_test_2 (X, Y, ALT)
     For two samples x and y from normal distributions with unknown
     means and unknown equal variances, perform a two-sample t-test of
     the null hypothesis of equal means.  Under the null, the test
     statistic T follows a Student distribution with DF degrees of
     freedom.

     With the optional argument string ALT, the alternative of interest
     can be selected.  If ALT is &quot;!=&quot; or &quot;&lt;%gt;&quot;, the null is tested
     against the two-sided alternative 'mean (X) != mean (Y)'.  If ALT
     is &quot;&gt;&quot;, the one-sided alternative 'mean (X) &gt; mean (Y)' is used.
     Similarly for &quot;&lt;&quot;, the one-sided alternative 'mean (X) &lt; mean
     (Y)' is used.  The default is the two-sided case.

     The p-value of the test is returned in PVAL.

     If no output argument is given, the p-value of the test is
     displayed.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="t_test_regression" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [PVAL, T, DF] = t_test_regression (Y, X, RR, R, ALT)
     Perform an t test for the null hypothesis 'RR * B = R' in a
     classical normal regression model 'Y = X * B + E'.  Under the
     null, the test statistic T follows a T distribution with DF
     degrees of freedom.

     If R is omitted, a value of 0 is assumed.

     With the optional argument string ALT, the alternative of interest
     can be selected.  If ALT is &quot;!=&quot; or &quot;&lt;%gt;&quot;, the null is tested
     against the two-sided alternative 'RR * B != R'.  If ALT is &quot;&gt;&quot;,
     the one-sided alternative 'RR * B &gt; R' is used.  Similarly for
     '&lt;', the one-sided alternative 'RR * B &lt; R' is used.  The default
     is the two-sided case.

     The p-value of the test is returned in PVAL.

     If no output argument is given, the p-value of the test is
     displayed.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="table" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [T, L_X] = table (X)
 -- Function File: [T, L_X, L_Y] = table (X, Y)
     Create a contingency table T from data vectors.  The L_X and L_Y
     vectors are the corresponding levels.

     Currently, only 1- and 2-dimensional tables are supported.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="tan" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  tan (Z)
     Compute the tangent for each element of X in radians.

     See also: atan, tand, tanh


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="tand" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  tand (X)
     Compute the tangent for each element of X in degrees.  Returns zero
     for elements where 'X/180' is an integer and 'Inf' for elements
     where '(X-90)/180' is an integer.

     See also: atand, tan


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="tanh" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  tanh (X)
     Compute hyperbolic tangent for each element of X.

     See also: atanh, sinh, cosh


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="tar" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: ENTRIES = tar (TARFILE, FILES)
 -- Function File: ENTRIES = tar (TARFILE, FILES, ROOT)
     Pack FILES FILES into the TAR archive TARFILE.  The list of files
     must be a string or a cell array of strings.

     The optional argument ROOT changes the relative path of FILES from
     the current directory.

     If an output argument is requested the entries in the archive are
     returned in a cell array.

     See also: untar, bzip2, gzip, zip


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="tcdf" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  tcdf (X, N)
     For each element of X, compute the cumulative distribution
     function (CDF) at X of the t (Student) distribution with N degrees
     of freedom, i.e., PROB (t(N) &lt;= X).

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="tempdir" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: DIR = tempdir ()
     Return the name of the system's directory for temporary files.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="tempname" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  tempname ()
 -- Function File:  tempname (DIR)
 -- Function File:  tempname (DIR, PREFIX)
     This function is an alias for 'tmpnam'.

     See also: tmpnam


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="terminal_size" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  terminal_size ()
     Return a two-element row vector containing the current size of the
     terminal window in characters (rows and columns).

     See also: list_in_columns


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="test" func="yes">
            <Overload retVal="">
                <Param name="
 -- Command:  test NAME
 -- Command:  test NAME quiet|normal|verbose
 -- Function File:  test ('NAME', 'quiet|normal|verbose', FID)
 -- Function File:  test ([], 'explain', FID)
 -- Function File: SUCCESS = test (...)
 -- Function File: [N, MAX] = test (...)
 -- Function File: [CODE, IDX] = test ('NAME', 'grabdemo')
     Perform tests from the first file in the loadpath matching NAME.
     'test' can be called as a command or as a function.  Called with a
     single argument NAME, the tests are run interactively and stop
     after the first error is encountered.

     With a second argument the tests which are performed and the
     amount of output is selected.

    'quiet'
          Don't report all the tests as they happen, just the errors.

    'normal'
          Report all tests as they happen, but don't do tests which
          require user interaction.

    'verbose'
          Do tests which require user interaction.

     The argument FID can be used to allow batch processing...

     USE help test FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="test_control" func="yes">
            <Overload retVal="">
                <Param name="
 -- Script File:  test_control
     Execute all available tests at once.  The Octave control package
     is based on the SLICOT (http://www.slicot.org) library.  SLICOT
     needs a LAPACK library which is also a prerequisite for Octave
     itself.  In case of failing test, it is highly recommended to use
     Netlib's reference LAPACK (http://www.netlib.org/lapack/) for
     building Octave.  Using ATLAS may lead to sign changes in some
     entries in the state-space matrices.  In general, these sign
     changes are not 'wrong' and can be regarded as the result of state
     transformations.  Such state transformations (but not input/output
     transformations) have no influence on the input-output behaviour
     of the system.  For better numerics, the control package uses such
     transformations by default when calculating the frequency
     responses and a few other things.  However, arguments like the
     Hankel singular Values (HSV) must not change.  Differing HSVs and
  ...

     USE help test_control FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="text" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  text (X, Y, LABEL)
 -- Function File:  text (X, Y, Z, LABEL)
 -- Function File:  text (X, Y, LABEL, P1, V1, ...)
 -- Function File:  text (X, Y, Z, LABEL, P1, V1, ...)
 -- Function File: H = text (...)
     Create a text object with text LABEL at position X, Y, Z on the
     current axes.  Property-value pairs following LABEL may be used to
     specify the appearance of the text.

     The optional return value H is a graphics handle to the created
     text object.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="textread" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [A, ...] = textread (FILENAME)
 -- Function File: [A, ...] = textread (FILENAME, FORMAT)
 -- Function File: [A, ...] = textread (FILENAME, FORMAT, N)
 -- Function File: [A, ...] = textread (FILENAME, FORMAT, PROP1,
          VALUE1, ...)
 -- Function File: [A, ...] = textread (FILENAME, FORMAT, N, PROP1,
          VALUE1, ...)
     Read data from a text file.

     The file FILENAME is read and parsed according to FORMAT.  The
     function behaves like 'strread' except it works by parsing a file
     instead of a string.  See the documentation of 'strread' for
     details.

     In addition to the options supported by 'strread', this function
     supports two more:

        * 'headerlines': The first VALUE number of lines of FILENAME
          are skipped.

        * 'endofline': Specify a single character or '\r\n'.  If no
          value is given, it will be inferred from the file.  If set to
          &quot; (empty string) EOLs are ignored as delimiters.

     The ...

     USE help textread FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="textscan" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: C = textscan (FID, FORMAT)
 -- Function File: C = textscan (FID, FORMAT, N)
 -- Function File: C = textscan (FID, FORMAT, PARAM, VALUE, ...)
 -- Function File: C = textscan (FID, FORMAT, N, PARAM, VALUE, ...)
 -- Function File: C = textscan (STR, ...)
 -- Function File: [C, POSITION] = textscan (FID, ...)
     Read data from a text file or string.

     The file associated with FID is read and parsed according to
     FORMAT.  The function behaves like 'strread' except it works by
     parsing a file instead of a string.  See the documentation of
     'strread' for details.

     In addition to the options supported by 'strread', this function
     supports a few more:

        * 'collectoutput': A value of 1 or true instructs textscan to
          concatenate consecutive columns of the same class in the
          output cell array.  A value of 0 or false (default) leaves
          output in distinct columns.

        * 'endofline': Specify '\r', '\n' or '\r\n' (for ...

     USE help textscan FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="tf" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: S = tf ('S')
 -- Function File: Z = tf ('Z', TSAM)
 -- Function File: SYS = tf (SYS)
 -- Function File: SYS = tf (NUM, DEN, ...)
 -- Function File: SYS = tf (NUM, DEN, TSAM, ...)
     Create or convert to transfer function model.

     *Inputs*
    SYS
          LTI model to be converted to transfer function.

    NUM
          Numerator or cell of numerators.  Each numerator must be a
          row vector containing the coefficients of the polynomial in
          descending powers of the transfer function variable.
          num{i,j} contains the numerator polynomial from input j to
          output i.  In the SISO case, a single vector is accepted as
          well.

    DEN
          Denominator or cell of denominators.  Each denominator must
          be a row vector containing the coefficients of the polynomial
          in descending powers of the transfer function variable.
          den{i,j} contains the denominator polynomial from input j to
          output...

     USE help tf FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="tic" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  tic ()
 -- Built-in Function:  toc ()
     Set or check a wall-clock timer.  Calling 'tic' without an output
     argument sets the timer.  Subsequent calls to 'toc' return the
     number of seconds since the timer was set.  For example,

          tic ();
          # many computations later...
          elapsed_time = toc ();

     will set the variable 'elapsed_time' to the number of seconds since
     the most recent call to the function 'tic'.

     If called with one output argument then this function returns a
     scalar of type 'uint64' and the wall-clock timer is not started.

          t = tic; sleep (5); (double (tic ()) - double (t)) * 1e-6
              => 5

     Nested timing with 'tic' and 'toc' is not supported.  Therefore
     'toc' will always return the elapsed time from the most recent
     call to 'tic'.

     If you are more interested in the CPU time that your process used,
     you should use the 'cputime' function instead.  The 'tic' a...

     USE help tic FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="tilde_expand" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  tilde_expand (STRING)
     Perform tilde expansion on STRING.  If STRING begins with a tilde
     character, ('~'), all of the characters preceding the first slash
     (or all characters, if there is no slash) are treated as a
     possible user name, and the tilde and the following characters up
     to the slash are replaced by the home directory of the named user.
     If the tilde is followed immediately by a slash, the tilde is
     replaced by the home directory of the user running Octave.  For
     example:

          tilde_expand ('~joeuser/bin')
              => '/home/joeuser/bin'
          tilde_expand ('~/bin')
              => '/home/jwe/bin'

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="time" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: SECONDS = time ()
     Return the current time as the number of seconds since the epoch.
     The epoch is referenced to 00:00:00 CUT (Coordinated Universal
     Time) 1 Jan 1970.  For example, on Monday February 17, 1997 at
     07:15:06 CUT, the value returned by 'time' was 856163706.

     See also: strftime, strptime, localtime, gmtime, mktime, now,
     date, clock, datenum, datestr, datevec, calendar, weekday


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="times" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  times (X, Y)
 -- Built-in Function:  times (X1, X2, ...)
     Return the element-by-element multiplication product of inputs.
     This function and x .* y are equivalent.  If more arguments are
     given, the multiplication is applied cumulatively from left to
     right:

           (...((x1 .* x2) .* x3) .* ...)

     At least one argument is required.

     See also: mtimes


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="tinv" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  tinv (X, N)
     For each element of X, compute the quantile (the inverse of the
     CDF) at X of the t (Student) distribution with N degrees of
     freedom.  This function is analogous to looking in a table for the
     t-value of a single-tailed distribution.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="title" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  title (STRING)
 -- Function File:  title (STRING, P1, V1, ...)
 -- Function File:  title (H, ...)
 -- Function File: H = title (...)
     Create a title object for a plot.

     The optional return value H is a graphics handle to the created
     object.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="tmpfile" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: [FID, MSG] = tmpfile ()
     Return the file ID corresponding to a new temporary file with a
     unique name.  The file is opened in binary read/write (&quot;w+b&quot;)
     mode.  The file will be deleted automatically when it is closed or
     when Octave exits.

     If successful, FID is a valid file ID and MSG is an empty string.
     Otherwise, FID is -1 and MSG contains a system-dependent error
     message.

     See also: tmpnam, mkstemp, P_tmpdir


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="tmpnam" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  tmpnam ()
 -- Built-in Function:  tmpnam (DIR)
 -- Built-in Function:  tmpnam (DIR, PREFIX)
     Return a unique temporary file name as a string.

     If PREFIX is omitted, a value of &quot;oct-&quot; is used.  If DIR is also
     omitted, the default directory for temporary files is used.  If
     DIR is provided, it must exist, otherwise the default directory
     for temporary files is used.  Since the named file is not opened,
     by 'tmpnam', it is possible (though relatively unlikely) that it
     will not be available by the time your program attempts to open it.

     See also: tmpfile, mkstemp, P_tmpdir


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="toascii" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  toascii (S)
     Return ASCII representation of S in a matrix.  For example:

          toascii ('ASCII')
              => [ 65, 83, 67, 73, 73 ]


     See also: char


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="toeplitz" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  toeplitz (C)
 -- Function File:  toeplitz (C, R)
     Return the Toeplitz matrix constructed from the first column C,
     and (optionally) the first row R.  If the first element of R is
     not the same as the first element of C, the first element of C is
     used.  If the second argument is omitted, the first row is taken
     to be the same as the first column.

     A square Toeplitz matrix has the form:

          c(0)  r(1)   r(2)  ...  r(n)
          c(1)  c(0)   r(1)  ... r(n-1)
          c(2)  c(1)   c(0)  ... r(n-2)
           .     .      .   .      .
           .     .      .     .    .
           .     .      .       .  .
          c(n) c(n-1) c(n-2) ...  c(0)

     See also: hankel


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="tolower" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  tolower (S)
 -- Mapping Function:  lower (S)
     Return a copy of the string or cell string S, with each uppercase
     character replaced by the corresponding lowercase one;
     non-alphabetic characters are left unchanged.  For example:

          tolower ('MiXeD cAsE 123')
              => 'mixed case 123'

     See also: toupper


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="toupper" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function:  toupper (S)
 -- Mapping Function:  upper (S)
     Return a copy of the string or cell string S, with each lowercase
     character replaced by the corresponding uppercase one;
     non-alphabetic characters are left unchanged.  For example:

          toupper ('MiXeD cAsE 123')
              => 'MIXED CASE 123'

     See also: tolower


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="tpdf" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  tpdf (X, N)
     For each element of X, compute the probability density function
     (PDF) at X of the T (Student) distribution with N degrees of
     freedom.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="trace" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  trace (A)
     Compute the trace of A, 'sum (diag (A))'.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="transpose" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  transpose (X)
     Return the transpose of X.  This function and x.' are equivalent.

     See also: ctranspose


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="trapz" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: Q = trapz (Y)
 -- Function File: Q = trapz (X, Y)
 -- Function File: Q = trapz (..., DIM)
     Numerically evaluate the integral of points Y using the trapezoidal
     method.  'trapz (Y)' computes the integral of Y along the first
     non-singleton dimension.  When the argument X is omitted an
     equally spaced X vector with unit spacing (1) is assumed.  'trapz
     (X, Y)' evaluates the integral with respect to the spacing in X
     and the values in Y.  This is useful if the points in Y have been
     sampled unevenly.  If the optional DIM argument is given, operate
     along this dimension.

     If X is not specified then unit spacing will be used.  To scale
     the integral to the correct value you must multiply by the actual
     spacing value (deltaX).  As an example, the integral of x^3 over
     the range [0, 1] is x^4/4 or 0.25.  The following code uses
     'trapz' to calculate the integral in three different ways.

          x = 0:0.1:1;
          y...

     USE help trapz FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="treelayout" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  treelayout (TREE)
 -- Function File:  treelayout (TREE, PERMUTATION)
     treelayout lays out a tree or a forest.  The first argument TREE
     is a vector of predecessors, optional parameter PERMUTATION is an
     optional postorder permutation.  The complexity of the algorithm
     is O(n) in terms of time and memory requirements.

     See also: etreeplot, gplot, treeplot


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="treeplot" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  treeplot (TREE)
 -- Function File:  treeplot (TREE, NODE_STYLE, EDGE_STYLE)
     Produce a graph of tree or forest.  The first argument is vector of
     predecessors, optional parameters NODE_STYLE and EDGE_STYLE define
     the output style.  The complexity of the algorithm is O(n) in
     terms of is time and memory requirements.

     See also: etreeplot, gplot


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="tril" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  tril (A)
 -- Function File:  tril (A, K)
 -- Function File:  tril (A, K, PACK)
 -- Function File:  triu (A)
 -- Function File:  triu (A, K)
 -- Function File:  triu (A, K, PACK)
     Return a new matrix formed by extracting the lower ('tril') or
     upper ('triu') triangular part of the matrix A, and setting all
     other elements to zero.  The second argument is optional, and
     specifies how many diagonals above or below the main diagonal
     should also be set to zero.

     The default value of K is zero, so that 'triu' and 'tril' normally
     include the main diagonal as part of the result.

     If the value of K is negative, additional elements above (for
     'tril') or below (for 'triu') the main diagonal are also selected.

     The absolute value of K must not be greater than the number of
     sub-diagonals or super-diagonals.

     For example:

          tril (ones (3), -1)
              =>  0  0  0
                  1  0  0
                  1  ...

     USE help tril FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="trimesh" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  trimesh (TRI, X, Y, Z)
 -- Function File: H = trimesh (...)
     Plot a triangular mesh in 3D.  The variable TRI is the triangular
     meshing of the points '(X, Y)' which is returned from 'delaunay'.
     The variable Z is value at the point '(X, Y)'.

     The optional return value H is a graphics handle to the created
     plot.

     See also: triplot, trisurf, delaunay3


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="triplequad" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  triplequad (F, XA, XB, YA, YB, ZA, ZB)
 -- Function File:  triplequad (F, XA, XB, YA, YB, ZA, ZB, TOL)
 -- Function File:  triplequad (F, XA, XB, YA, YB, ZA, ZB, TOL, QUADF)
 -- Function File:  triplequad (F, XA, XB, YA, YB, ZA, ZB, TOL, QUADF,
          ...)
     Numerically evaluate the triple integral of F.  F is a function
     handle, inline function, or string containing the name of the
     function to evaluate.  The function F must have the form w =
     f(x,y,z) where either X or Y is a vector and the remaining inputs
     are scalars.  It should return a vector of the same length and
     orientation as X or Y.

     XA, YA, ZA and XB, YB, ZB are the lower and upper limits of
     integration for x, y, and z respectively.  The underlying
     integrator determines whether infinite bounds are accepted.

     The optional argument TOL defines the absolute tolerance used to
     integrate each sub-integral.  The default value is 1e^-6.

     The optional argu...

     USE help triplequad FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="triplot" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  triplot (TRI, X, Y)
 -- Function File:  triplot (TRI, X, Y, LINESPEC)
 -- Function File: H = triplot (...)
     Plot a triangular mesh in 2D.  The variable TRI is the triangular
     meshing of the points '(X, Y)' which is returned from 'delaunay'.
     If given, LINESPEC determines the properties to use for the lines.

     The optional return value H is a graphics handle to the created
     plot.

     See also: plot, trimesh, trisurf, delaunay


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="trisurf" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  trisurf (TRI, X, Y, Z)
 -- Function File: H = trisurf (...)
     Plot a triangular surface in 3D.  The variable TRI is the
     triangular meshing of the points '(X, Y)' which is returned from
     'delaunay'.  The variable Z is value at the point '(X, Y)'.

     The optional return value H is a graphics handle to the created
     plot.

     See also: triplot, trimesh, delaunay3


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="trnd" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  trnd (N)
 -- Function File:  trnd (N, R)
 -- Function File:  trnd (N, R, C, ...)
 -- Function File:  trnd (N, [SZ])
     Return a matrix of random samples from the t (Student)
     distribution with N degrees of freedom.

     When called with a single size argument, return a square matrix
     with the dimension specified.  When called with more than one
     scalar argument the first two arguments are taken as the number of
     rows and columns and any further arguments specify additional
     matrix dimensions.  The size may also be specified with a vector
     of dimensions SZ.

     If no size arguments are given then the result matrix is the size
     of N.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="true" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  true (X)
 -- Built-in Function:  true (N, M)
 -- Built-in Function:  true (N, M, K, ...)
     Return a matrix or N-dimensional array whose elements are all
     logical 1.  If invoked with a single scalar integer argument,
     return a square matrix of the specified size.  If invoked with two
     or more scalar integer arguments, or a vector of integer values,
     return an array with given dimensions.

     See also: false


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="tsearch" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: IDX = tsearch (X, Y, T, XI, YI)
     Search for the enclosing Delaunay convex hull.  For 'T = delaunay
     (X, Y)', finds the index in T containing the points '(XI, YI)'.
     For points outside the convex hull, IDX is NaN.

     See also: delaunay, delaunayn


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="tsearchn" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [IDX, P] = tsearchn (X, T, XI)
     Search for the enclosing Delaunay convex hull.  For 'T = delaunayn
     (X)', finds the index in T containing the points XI.  For points
     outside the convex hull, IDX is NaN.  If requested 'tsearchn' also
     returns the Barycentric coordinates P of the enclosing triangles.

     See also: delaunay, delaunayn


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="type" func="yes">
            <Overload retVal="">
                <Param name="
 -- Command:  type NAME ...
 -- Command:  type -q NAME ...
 -- Function File: dfns = type ('NAME', ...)
     Display the definition of each NAME that refers to a function.

     Normally also displays whether each NAME is user-defined or
     built-in; the '-q' option suppresses this behavior.

     If an output argument is requested nothing is displayed.  Instead,
     a cell array of strings is returned, where each element
     corresponds to the definition of each requested function.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="typecast" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function:  typecast (X, CLASS)
     Return a new array Y resulting from interpreting the data of X in
     memory as data of the numeric class CLASS.  Both the class of X
     and CLASS must be one of the built-in numeric classes:

           'logical'
           'char'
           'int8'
           'int16'
           'int32'
           'int64'
           'uint8'
           'uint16'
           'uint32'
           'uint64'
           'double'
           'single'
           'double complex'
           'single complex'

     the last two are reserved for CLASS; they indicate that a
     complex-valued result is requested.  Complex arrays are stored in
     memory as consecutive pairs of real numbers.  The sizes of integer
     types are given by their bit counts.  Both logical and char are
     typically one byte wide; however, this is not guaranteed by C++.
     If your system is IEEE conformant, single and double should be 4
     bytes and 8 bytes wide, respectively.  'logic...

     USE help typecast FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="typeinfo" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  typeinfo ()
 -- Built-in Function:  typeinfo (EXPR)
     Return the type of the expression EXPR, as a string.  If EXPR is
     omitted, return an cell array of strings containing all the
     currently installed data types.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="u_test" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [PVAL, Z] = u_test (X, Y, ALT)
     For two samples X and Y, perform a Mann-Whitney U-test of the null
     hypothesis PROB (X &gt; Y) == 1/2 == PROB (X &lt; Y).  Under the null,
     the test statistic Z approximately follows a standard normal
     distribution.  Note that this test is equivalent to the Wilcoxon
     rank-sum test.

     With the optional argument string ALT, the alternative of interest
     can be selected.  If ALT is &quot;!=&quot; or &quot;&lt;%gt;&quot;, the null is tested
     against the two-sided alternative PROB (X &gt; Y) != 1/2.  If ALT is
     &quot;&gt;&quot;, the one-sided alternative PROB (X &gt; Y) &gt; 1/2 is considered.
     Similarly for &quot;&lt;&quot;, the one-sided alternative PROB (X &gt; Y) &lt; 1/2
     is considered.  The default is the two-sided case.

     The p-value of the test is returned in PVAL.

     If no output argument is given, the p-value of the test is
     displayed.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="uigetdir" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: DIRNAME = uigetdir ()
 -- Function File: DIRNAME = uigetdir (INIT_PATH)
 -- Function File: DIRNAME = uigetdir (INIT_PATH, DIALOG_NAME)
     Open a GUI dialog for selecting a directory.  If INIT_PATH is not
     given the current working directory is used.  DIALOG_NAME may be
     used to customize the dialog title.

     See also: uigetfile


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="uigetfile" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [FNAME, FPATH, FLTIDX] = uigetfile ()
 -- Function File: [...] = uigetfile (FLT)
 -- Function File: [...] = uigetfile (FLT, DIALOG_NAME)
 -- Function File: [...] = uigetfile (FLT, DIALOG_NAME, DEFAULT_FILE)
 -- Function File: [...] = uigetfile (..., 'Position', [PX PY])
 -- Function File: [...] = uigetfile (..., 'MultiSelect', MODE)
     Open a GUI dialog for selecting a file.  It returns the filename
     FNAME, the path to this file FPATH, and the filter index FLTIDX.
     FLT contains a (list of) file filter string(s) in one of the
     following formats:

    '/path/to/filename.ext'
          If a filename is given then the file extension is extracted
          and used as filter.  In addition, the path is selected as
          current path and the filename is selected as default file.
          Example: 'uigetfile ('myfun.m')'

    A single file extension '*.ext'
          Example: 'uigetfile ('*.ext')'

    A 2-column cell array
          containing a file exte...

     USE help uigetfile FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="uimenu" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  uimenu (PROPERTY, VALUE, ...)
 -- Function File:  uimenu (H, PROPERTY, VALUE, ...)
     Create a uimenu object and return a handle to it.  If H is ommited
     then a top-level menu for the current figure is created.  If H is
     given then a submenu relative to H is created.

     uimenu objects have the following specific properties:

    'accelerator'
          A string containing the key combination together with CTRL to
          execute this menu entry (e.g., 'x' for CTRL+x).

    'callback'
          Is the function called when this menu entry is executed.  It
          can be either a function string (e.g., 'myfun'), a function
          handle (e.g., @myfun) or a cell array containing the function
          handle and arguments for the callback function (e.g.,
          {@myfun, arg1, arg2}).

    'checked'
          Can be set 'on' or 'off'.  Sets a mark at this menu entry.

    'enable'
          Can be set 'on' or 'off'.  If disabled the menu entry cann...

     USE help uimenu FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="uint16" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  uint16 (X)
     Convert X to unsigned 16-bit integer type.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="uint32" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  uint32 (X)
     Convert X to unsigned 32-bit integer type.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="uint64" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  uint64 (X)
     Convert X to unsigned 64-bit integer type.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="uint8" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  uint8 (X)
     Convert X to unsigned 8-bit integer type.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="uiputfile" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [FNAME, FPATH, FLTIDX] = uiputfile ()
 -- Function File: [FNAME, FPATH, FLTIDX] = uiputfile (FLT)
 -- Function File: [FNAME, FPATH, FLTIDX] = uiputfile (FLT, DIALOG_NAME)
 -- Function File: [FNAME, FPATH, FLTIDX] = uiputfile (FLT,
          DIALOG_NAME, DEFAULT_FILE)
     Open a GUI dialog for selecting a file.  FLT contains a (list of)
     file filter string(s) in one of the following formats:

    &quot;/path/to/filename.ext&quot;
          If a filename is given the file extension is extracted and
          used as filter.  In addition the path is selected as current
          path and the filename is selected as default file.  Example:
          uiputfile('myfun.m');

    &quot;*.ext&quot;
          A single file extension.  Example: uiputfile('*.ext');

    '{'*.ext','My Description'}'
          A 2-column cell array containing the file extension in the
          1st column and a brief description in the 2nd column.
          Example: uiputfile({'*.ext','My
          Descripti...

     USE help uiputfile FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="uiresume" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  uiresume (H)
     Resume program execution suspended with 'uiwait'.  The handle H
     must be the same as the on specified in 'uiwait'.  If the handle
     is invalid or there is no 'uiwait' call pending for the figure
     with handle H, this function does nothing.

     See also: uiwait


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="uiwait" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  uiwait
 -- Function File:  uiwait (H)
 -- Function File:  uiwait (H, TIMEOUT)
     Suspend program execution until the figure with handle H is
     deleted or 'uiresume' is called.  When no figure handle is
     specified, this function uses the current figure.

     If the figure handle is invalid or there is no current figure, this
     functions returns immediately.

     When specified, TIMEOUT defines the number of seconds to wait for
     the figure deletion or the 'uiresume' call.  The timeout value
     must be at least 1. If a smaller value is specified, a warning is
     issued and a timeout value of 1 is used instead.  If a non-integer
     value is specified, it is truncated towards 0. If TIMEOUT is not
     specified, the program execution is suspended indefinitely.

     See also: uiresume, waitfor


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="umask" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  umask (MASK)
     Set the permission mask for file creation.  The parameter MASK is
     an integer, interpreted as an octal number.  If successful,
     returns the previous value of the mask (as an integer to be
     interpreted as an octal number); otherwise an error message is
     printed.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="uminus" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  uminus (X)
     This function and - x are equivalent.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="uname" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: [UTS, ERR, MSG] = uname ()
     Return system information in the structure.  For example:

          uname ()
              => {
                    sysname = x86_64
                    nodename = segfault
                    release = 2.6.15-1-amd64-k8-smp
                    version = Linux
                    machine = #2 SMP Thu Feb 23 04:57:49 UTC 2006
                  }

     If successful, ERR is 0 and MSG is an empty string.  Otherwise,
     ERR is nonzero and MSG contains a system-dependent error message.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="undo_string_escapes" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  undo_string_escapes (S)
     Convert special characters in strings back to their escaped forms.
     For example, the expression

          bell = '\a';

     assigns the value of the alert character (control-g, ASCII code 7)
     to the string variable 'bell'.  If this string is printed, the
     system will ring the terminal bell (if it is possible).  This is
     normally the desired outcome.  However, sometimes it is useful to
     be able to print the original representation of the string, with
     the special characters replaced by their escape sequences.  For
     example,

          octave:13> undo_string_escapes (bell)
          ans = \a

     replaces the unprintable alert character with its printable
     representation.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="unidcdf" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  unidcdf (X, N)
     For each element of X, compute the cumulative distribution
     function (CDF) at X of a discrete uniform distribution which
     assumes the integer values 1-N with equal probability.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="unidinv" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  unidinv (X, N)
     For each element of X, compute the quantile (the inverse of the
     CDF) at X of the discrete uniform distribution which assumes the
     integer values 1-N with equal probability.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="unidpdf" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  unidpdf (X, N)
     For each element of X, compute the probability density function
     (PDF) at X of a discrete uniform distribution which assumes the
     integer values 1-N with equal probability.

     Warning: The underlying implementation uses the double class and
     will only be accurate for N &lt;= 'bitmax' (2^53 - 1 on IEEE-754
     compatible systems).

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="unidrnd" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  unidrnd (N)
 -- Function File:  unidrnd (N, R)
 -- Function File:  unidrnd (N, R, C, ...)
 -- Function File:  unidrnd (N, [SZ])
     Return a matrix of random samples from the discrete uniform
     distribution which assumes the integer values 1-N with equal
     probability.  N may be a scalar or a multi-dimensional array.

     When called with a single size argument, return a square matrix
     with the dimension specified.  When called with more than one
     scalar argument the first two arguments are taken as the number of
     rows and columns and any further arguments specify additional
     matrix dimensions.  The size may also be specified with a vector
     of dimensions SZ.

     If no size arguments are given then the result matrix is the size
     of N.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="unifcdf" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  unifcdf (X)
 -- Function File:  unifcdf (X, A, B)
     For each element of X, compute the cumulative distribution
     function (CDF) at X of the uniform distribution on the interval
     [A, B].

     Default values are A = 0, B = 1.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="unifinv" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  unifinv (X)
 -- Function File:  unifinv (X, A, B)
     For each element of X, compute the quantile (the inverse of the
     CDF) at X of the uniform distribution on the interval [A, B].

     Default values are A = 0, B = 1.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="unifpdf" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  unifpdf (X)
 -- Function File:  unifpdf (X, A, B)
     For each element of X, compute the probability density function
     (PDF) at X of the uniform distribution on the interval [A, B].

     Default values are A = 0, B = 1.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="unifrnd" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  unifrnd (A, B)
 -- Function File:  unifrnd (A, B, R)
 -- Function File:  unifrnd (A, B, R, C, ...)
 -- Function File:  unifrnd (A, B, [SZ])
     Return a matrix of random samples from the uniform distribution on
     [A, B].

     When called with a single size argument, return a square matrix
     with the dimension specified.  When called with more than one
     scalar argument the first two arguments are taken as the number of
     rows and columns and any further arguments specify additional
     matrix dimensions.  The size may also be specified with a vector
     of dimensions SZ.

     If no size arguments are given then the result matrix is the
     common size of A and B.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="union" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  union (A, B)
 -- Function File:  union (A, B, 'rows')
     Return the set of elements that are in either of the sets A and B.
     A, B may be cell arrays of string(s).  For example:

          union ([1, 2, 4], [2, 3, 5])
              => [1, 2, 3, 4, 5]

     If the optional third input argument is the string 'rows' each row
     of the matrices A and B will be considered an element of sets.
     For example:

          union ([1, 2; 2, 3], [1, 2; 3, 4], 'rows')
             =>  1   2
                 2   3
                 3   4

 -- Function File: [C, IA, IB] = union (A, B)
     Return index vectors IA and IB such that 'a(ia)' and 'b(ib)' are
     disjoint sets whose union is C.

     See also: intersect, setdiff, unique


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="unique" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  unique (X)
 -- Function File:  unique (X, 'rows')
 -- Function File:  unique (..., 'first')
 -- Function File:  unique (..., 'last')
 -- Function File: [Y, I, J] = unique (...)
     Return the unique elements of X, sorted in ascending order.  If
     the input X is a vector then the output is also a vector with the
     same orientation (row or column) as the input.  For a matrix input
     the output is always a column vector.  X may also be a cell array
     of strings.

     If the optional argument &quot;rows&quot; is supplied, return the unique
     rows of X, sorted in ascending order.

     If requested, return index vectors I and J such that 'x(i)==y' and
     'y(j)==x'.

     Additionally, if I is a requested output then one of &quot;first&quot; or
     &quot;last&quot; may be given as an input.  If &quot;last&quot; is specified,
     return the highest possible indices in I, otherwise, if &quot;first&quot;
     is specified, return the lowest.  The default is &quot;last&quot;.

     See also: union, int...

     USE help unique FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="unix" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  unix ('COMMAND')
 -- Function File: STATUS = unix ('COMMAND')
 -- Function File: [STATUS, TEXT] = unix ('COMMAND')
 -- Function File: [...] = unix ('COMMAND', '-echo')
     Execute a system command if running under a Unix-like operating
     system, otherwise do nothing.  Return the exit status of the
     program in STATUS and any output from the command in TEXT.  When
     called with no output argument, or the '-echo' argument is given,
     then TEXT is also sent to standard output.

     See also: dos, system, isunix, ispc


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="unlink" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: [ERR, MSG] = unlink (FILE)
     Delete the file named FILE.

     If successful, ERR is 0 and MSG is an empty string.  Otherwise,
     ERR is nonzero and MSG contains a system-dependent error message.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="unmkpp" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [X, P, N, K, D] = unmkpp (PP)
     Extract the components of a piecewise polynomial structure PP.
     The components are:

    X
          Sample points.

    P
          Polynomial coefficients for points in sample interval.  'P
          (I, :)' contains the coefficients for the polynomial over
          interval I ordered from highest to lowest.  If 'D &gt; 1', 'P
          (R, I, :)' contains the coefficients for the r-th polynomial
          defined on interval I.

    N
          Number of polynomial pieces.

    K
          Order of the polynomial plus 1.

    D
          Number of polynomials defined for each interval.

     See also: mkpp, ppval, spline, pchip


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="unpack" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: FILES = unpack (FILE)
 -- Function File: FILES = unpack (FILE, DIR)
 -- Function File: FILES = unpack (FILE, DIR, FILETYPE)
     Unpack the archive FILE based on its extension to the directory
     DIR.  If FILE is a list of strings, then each file is unpacked
     individually.  If DIR is not specified, it defaults to the current
     directory.  If a directory is in the file list, then the FILETYPE
     must also be specified.

     The optional return value is a list of FILES unpacked.

     See also: bzip2, gzip, zip, tar


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="untabify" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  untabify (T)
 -- Function File:  untabify (T, TW)
 -- Function File:  untabify (T, TW, DEBLANK)
     Replace TAB characters in T, with spaces.  The tab width is
     specified by TW, or defaults to eight.  The input, T, may be
     either a 2-D character array, or a cell array of character
     strings.  The output is the same class as the input.

     If the optional argument DEBLANK is true, then the spaces will be
     removed from the end of the character data.

     The following example reads a file and writes an untabified version
     of the same file with trailing spaces stripped.

          fid = fopen ('tabbed_script.m');
          text = char (fread (fid, 'uchar')');
          fclose (fid);
          fid = fopen ('untabified_script.m', 'w');
          text = untabify (strsplit (text, '\n'), 8, true);
          fprintf (fid, '%s\n', text{:});
          fclose (fid);

     See also: strjust, strsplit, deblank


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="untar" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  untar (TARFILE)
 -- Function File:  untar (TARFILE, DIR)
     Unpack the TAR archive TARFILE to the directory DIR.  If DIR is
     not specified, it defaults to the current directory.

     See also: tar, unpack, bunzip2, gunzip, unzip


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="unwrap" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: B = unwrap (X)
 -- Function File: B = unwrap (X, TOL)
 -- Function File: B = unwrap (X, TOL, DIM)
     Unwrap radian phases by adding multiples of 2*pi as appropriate to
     remove jumps greater than TOL.  TOL defaults to pi.

     Unwrap will work along the dimension DIM.  If DIM is unspecified
     it defaults to the first non-singleton dimension.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="unzip" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  unzip (ZIPFILE)
 -- Function File:  unzip (ZIPFILE, DIR)
     Unpack the ZIP archive ZIPFILE to the directory DIR.  If DIR is
     not specified, it defaults to the current directory.

     See also: zip, unpack, bunzip2, gunzip, untar


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="uplus" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  uplus (X)
     This function and + x are equivalent.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="urlread" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function: S = urlread (URL)
 -- Loadable Function: [S, SUCCESS] = urlread (URL)
 -- Loadable Function: [S, SUCCESS, MESSAGE] = urlread (URL)
 -- Loadable Function: [...] = urlread (URL, METHOD, PARAM)
     Download a remote file specified by its URL and return its content
     in string S.  For example:

          s = urlread ('ftp://ftp.octave.org/pub/octave/README');

     The variable SUCCESS is 1 if the download was successful,
     otherwise it is 0 in which case MESSAGE contains an error message.
     If no output argument is specified and an error occurs, then the
     error is signaled through Octave's error handling mechanism.

     This function uses libcurl.  Curl supports, among others, the HTTP,
     FTP and FILE protocols.  Username and password may be specified in
     the URL.  For example:

          s = urlread ('http://user:password@example.com/file.txt');

     GET and POST requests can be specified by METHOD and PARAM.  The
     parameter METHOD is eit...

     USE help urlread FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="urlwrite" func="yes">
            <Overload retVal="">
                <Param name="
 -- Loadable Function:  urlwrite (URL, LOCALFILE)
 -- Loadable Function: F = urlwrite (URL, LOCALFILE)
 -- Loadable Function: [F, SUCCESS] = urlwrite (URL, LOCALFILE)
 -- Loadable Function: [F, SUCCESS, MESSAGE] = urlwrite (URL, LOCALFILE)
     Download a remote file specified by its URL and save it as
     LOCALFILE.  For example:

          urlwrite ('ftp://ftp.octave.org/pub/octave/README',
                   'README.txt');

     The full path of the downloaded file is returned in F.  The
     variable SUCCESS is 1 if the download was successful, otherwise it
     is 0 in which case MESSAGE contains an error message.  If no
     output argument is specified and an error occurs, then the error
     is signaled through Octave's error handling mechanism.

     This function uses libcurl.  Curl supports, among others, the HTTP,
     FTP and FILE protocols.  Username and password may be specified in
     the URL, for example:

          urlwrite ('http://username:password@example.com/fil...

     USE help urlwrite FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="usage" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  usage (MSG)
     Print the message MSG, prefixed by the string 'usage: ', and set
     Octave's internal error state such that control will return to the
     top level without evaluating any more commands.  This is useful for
     aborting from functions.

     After 'usage' is evaluated, Octave will print a traceback of all
     the function calls leading to the usage message.

     You should use this function for reporting problems errors that
     result from an improper call to a function, such as calling a
     function with an incorrect number of arguments, or with arguments
     of the wrong type.  For example, most functions distributed with
     Octave begin with code like this

          if (nargin != 2)
           usage ('foo (a, b)');
          endif

     to check for the proper number of arguments.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="usejava" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  usejava (FEATURE)
     Return true if the specific Sun Java element FEATURE is available.

     Possible features are:

    'awt'
          Abstract Window Toolkit for GUIs.

    'desktop'
          Interactive desktop is running.

    'jvm'
          Java Virtual Machine.

    'swing'
          Swing components for lightweight GUIs.

     This function is provided for compatibility with MATLAB scripts
     which may alter their behavior based on the availability of Java.
     Octave does not implement an interface to Java and this function
     always returns 'false'.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="usleep" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  usleep (MICROSECONDS)
     Suspend the execution of the program for the given number of
     microseconds.  On systems where it is not possible to sleep for
     periods of time less than one second, 'usleep' will pause the
     execution for 'round (MICROSECONDS / 1e6)' seconds.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="validatestring" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: VALIDSTR = validatestring (STR, STRARRAY)
 -- Function File: VALIDSTR = validatestring (STR, STRARRAY, FUNCNAME)
 -- Function File: VALIDSTR = validatestring (STR, STRARRAY, FUNCNAME,
          VARNAME)
 -- Function File: VALIDSTR = validatestring (..., POSITION)
     Verify that STR is an element, or substring of an element, in
     STRARRAY.

     When STR is a character string to be tested, and STRARRAY is a
     cellstr of valid values, then VALIDSTR will be the validated form
     of STR where validation is defined as STR being a member or
     substring of VALIDSTR.  This is useful for both verifying and
     expanding short options, such as 'r', to their longer forms, such
     as 'red'.  If STR is a substring of VALIDSTR, and there are
     multiple matches, the shortest match will be returned if all
     matches are substrings of each other.  Otherwise, an error will be
     raised because the expansion of STR is ambiguous.  All comparisons
     are case ins...

     USE help validatestring FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="vander" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  vander (C)
 -- Function File:  vander (C, N)
     Return the Vandermonde matrix whose next to last column is C.  If
     N is specified, it determines the number of columns; otherwise, N
     is taken to be equal to the length of C.

     A Vandermonde matrix has the form:

          c(1)^(n-1) ... c(1)^2  c(1)  1
          c(2)^(n-1) ... c(2)^2  c(2)  1
              .     .      .      .    .
              .       .    .      .    .
              .         .  .      .    .
          c(n)^(n-1) ... c(n)^2  c(n)  1

     See also: polyfit


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="var" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  var (X)
 -- Function File:  var (X, OPT)
 -- Function File:  var (X, OPT, DIM)
     Compute the variance of the elements of the vector X.

          var (x) = 1/(N-1) SUM_i (x(i) - mean(x))^2

     If X is a matrix, compute the variance for each column and return
     them in a row vector.

     The argument OPT determines the type of normalization to use.
     Valid values are

    0:
          normalize with N-1, provides the best unbiased estimator of
          the variance [default]

    1:
          normalizes with N, this provides the second moment around the
          mean

     If the optional argument DIM is given, operate along this
     dimension.

     See also: cov, std, skewness, kurtosis, moment


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="var_test" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [PVAL, F, DF_NUM, DF_DEN] = var_test (X, Y, ALT)
     For two samples X and Y from normal distributions with unknown
     means and unknown variances, perform an F-test of the null
     hypothesis of equal variances.  Under the null, the test statistic
     F follows an F-distribution with DF_NUM and DF_DEN degrees of
     freedom.

     With the optional argument string ALT, the alternative of interest
     can be selected.  If ALT is &quot;!=&quot; or &quot;&lt;%gt;&quot;, the null is tested
     against the two-sided alternative 'var (X) != var (Y)'.  If ALT is
     &quot;&gt;&quot;, the one-sided alternative 'var (X) &gt; var (Y)' is used.
     Similarly for '&lt;', the one-sided alternative 'var (X) &gt; var (Y)'
     is used.  The default is the two-sided case.

     The p-value of the test is returned in PVAL.

     If no output argument is given, the p-value of the test is
     displayed.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="vec" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: V = vec (X)
 -- Built-in Function: V = vec (X, DIM)
     Return the vector obtained by stacking the columns of the matrix X
     one above the other.  Without DIM this is equivalent to 'X(:)'.
     If DIM is supplied, the dimensions of V are set to DIM with all
     elements along the last dimension.  This is equivalent to
     'shiftdim (X(:), 1-DIM)'.

     See also: vech


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="vech" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  vech (X)
     Return the vector obtained by eliminating all supradiagonal
     elements of the square matrix X and stacking the result one column
     above the other.  This has uses in matrix calculus where the
     underlying matrix is symmetric and it would be pointless to keep
     values above the main diagonal.

     See also: vec


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="vectorize" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  vectorize (FUN)
     Create a vectorized version of the inline function FUN by
     replacing all occurrences of '*', '/', etc., with '.*', './', etc.

     This may be useful, for example, when using inline functions with
     numerical integration or optimization where a vector-valued
     function is expected.

          fcn = vectorize (inline ('x^2 - 1'))
            => fcn = f(x) = x.^2 - 1
          quadv (fcn, 0, 3)
            => 6

     See also: inline, formula, argnames


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="ver" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  ver ()
     Display a header containing the current Octave version number,
     license string and operating system, followed by the installed
     package names, versions, and installation directories.

 -- Function File: v = ver ()
     Return a vector of structures, respecting Octave and each
     installed package.  The structure includes the following fields.

    'Name'
          Package name.

    'Version'
          Version of the package.

    'Revision'
          Revision of the package.

    'Date'
          Date respecting the version/revision.

 -- Function File: v = ver ('Octave')
     Return version information for Octave only.

 -- Function File: v = ver (PACKAGE)
     Return version information for PACKAGE.

     See also: version, octave_config_info


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="version" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  version ()
     Return the version number of Octave, as a string.

     This is an alias for the function 'OCTAVE_VERSION' provided for
     compatibility

     See also: OCTAVE_VERSION .

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="vertcat" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  vertcat (ARRAY1, ARRAY2, ..., ARRAYN)
     Return the vertical concatenation of N-D array objects, ARRAY1,
     ARRAY2, ..., ARRAYN along dimension 1.

     Arrays may also be concatenated vertically using the syntax for
     creating new matrices.  For example:

          VCAT = [ ARRAY1; ARRAY2; ... ];

     See also: cat, horzcat


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="view" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [AZIMUTH, ELEVATION] = view ()
 -- Function File:  view (AZIMUTH, ELEVATION)
 -- Function File:  view ([AZIMUTH ELEVATION])
 -- Function File:  view ([X Y Z])
 -- Function File:  view (DIMS)
 -- Function File:  view (AX, ...)
     Query or set the viewpoint for the current axes.  The parameters
     AZIMUTH and ELEVATION can be given as two arguments or as
     2-element vector.  The viewpoint can also be given with Cartesian
     coordinates X, Y, and Z.  The call 'view (2)' sets the viewpoint
     to AZIMUTH = 0 and ELEVATION = 90, which is the default for 2-D
     graphs.  The call 'view (3)' sets the viewpoint to AZIMUTH = -37.5
     and ELEVATION = 30, which is the default for 3-D graphs.  If AX is
     given, the viewpoint is set for this axes, otherwise it is set for
     the current axes.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="voronoi" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  voronoi (X, Y)
 -- Function File:  voronoi (X, Y, OPTIONS)
 -- Function File:  voronoi (..., 'linespec')
 -- Function File:  voronoi (HAX, ...)
 -- Function File: H = voronoi (...)
 -- Function File: [VX, VY] = voronoi (...)
     Plot the Voronoi diagram of points '(X, Y)'.  The Voronoi facets
     with points at infinity are not drawn.

     If 'linespec' is given it is used to set the color and line style
     of the plot.  If an axis graphics handle HAX is supplied then the
     Voronoi diagram is drawn on the specified axis rather than in a
     new figure.

     The OPTIONS argument, which must be a string or cell array of
     strings, contains options passed to the underlying qhull command.
     See the documentation for the Qhull library for details
     'http://www.qhull.org/html/qh-quick.htm#options'.

     If a single output argument is requested then the Voronoi diagram
     will be plotted and a graphics handle H to the plot is returned.
     [VX, VY] =...

     USE help voronoi FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="voronoin" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [C, F] = voronoin (PTS)
 -- Function File: [C, F] = voronoin (PTS, OPTIONS)
     Compute N-dimensional Voronoi facets.  The input matrix PTS of
     size [n, dim] contains n points in a space of dimension dim.  C
     contains the points of the Voronoi facets.  The list F contains,
     for each facet, the indices of the Voronoi points.

     An optional second argument, which must be a string or cell array
     of strings, contains options passed to the underlying qhull
     command.  See the documentation for the Qhull library for details
     'http://www.qhull.org/html/qh-quick.htm#options'.

     See also: voronoi, convhulln, delaunayn


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="waitbar" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: H = waitbar (FRAC)
 -- Function File: H = waitbar (FRAC, MSG)
 -- Function File: H = waitbar (..., 'FigureProperty', 'Value', ...)
 -- Function File:  waitbar (FRAC)
 -- Function File:  waitbar (FRAC, HWBAR)
 -- Function File:  waitbar (FRAC, HWBAR, MSG)
     Return a handle H to a new waitbar object.  The waitbar is filled
     to fraction FRAC which must be in the range [0, 1].  The optional
     message MSG is centered and displayed above the waitbar.  The
     appearance of the waitbar figure window can be configured by
     passing property/value pairs to the function.

     When called with a single input the current waitbar, if it exists,
     is updated to the new value FRAC.  If there are multiple
     outstanding waitbars they can be updated individually by passing
     the handle HWBAR of the specific waitbar to modify.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="waitfor" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  waitfor (H)
 -- Built-in Function:  waitfor (H, PROP)
 -- Built-in Function:  waitfor (H, PROP, VALUE)
 -- Built-in Function:  waitfor (..., 'timeout', TIMEOUT)
     Suspend the execution of the current program until a condition is
     satisfied on the graphics handle H.  While the program is suspended
     graphics events are still being processed normally, allowing
     callbacks to modify the state of graphics objects.  This function
     is reentrant and can be called from a callback, while another
     'waitfor' call is pending at top-level.

     In the first form, program execution is suspended until the
     graphics object H is destroyed.  If the graphics handle is
     invalid, the function returns immediately.

     In the second form, execution is suspended until the graphics
     object is destroyed or the property named PROP is modified.  If
     the graphics handle is invalid or the property does not exist, the
     function returns immediately.
...

     USE help waitfor FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="waitforbuttonpress" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: B = waitforbuttonpress ()
     Wait for button or mouse press.over a figure window.  The value of
     B returns 0 if a mouse button was pressed or 1 is a key was
     pressed.

     See also: ginput


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="waitpid" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: [PID, STATUS, MSG] = waitpid (PID, OPTIONS)
     Wait for process PID to terminate.  The PID argument can be:

    -1
          Wait for any child process.

    0
          Wait for any child process whose process group ID is equal to
          that of the Octave interpreter process.

    &gt; 0
          Wait for termination of the child process with ID PID.

     The OPTIONS argument can be a bitwise OR of zero or more of the
     following constants:

    '0'
          Wait until signal is received or a child process exits (this
          is the default if the OPTIONS argument is missing).

    'WNOHANG'
          Do not hang if status is not immediately available.

    'WUNTRACED'
          Report the status of any child processes that are stopped,
          and whose status has not yet been reported since they stopped.

    'WCONTINUE'
          Return if a stopped child has been resumed by delivery of
          'SIGCONT'.  This value may not be meaningful on a...

     USE help waitpid FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="warning" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  warning (TEMPLATE, ...)
 -- Built-in Function:  warning (ID, TEMPLATE, ...)
 -- Built-in Function:  warning ('on', ID)
 -- Built-in Function:  warning ('off', ID)
 -- Built-in Function:  warning ('query', ID)
 -- Built-in Function:  warning ('error', ID)
     Format the optional arguments under the control of the template
     string TEMPLATE using the same rules as the 'printf' family of
     functions (*note Formatted Output::) and print the resulting
     message on the 'stderr' stream.  The message is prefixed by the
     character string 'warning: '.  You should use this function when
     you want to notify the user of an unusual condition, but only when
     it makes sense for your program to go on.

     The optional message identifier allows users to enable or disable
     warnings tagged by ID.  The special identifier &quot;all&quot; may be used
     to set the state of all warnings.

     If the first argument is &quot;on&quot; or &quot;off&quot;, set the state of a
     par...

     USE help warning FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="warning_ids" func="yes">
            <Overload retVal="">
                <Param name="

'Octave:abbreviated-property-match'
     By default, the 'Octave:abbreviated-property-match' warning is
     enabled.

'Octave:array-to-scalar'
     If the 'Octave:array-to-scalar' warning is enabled, Octave will
     warn when an implicit conversion from an array to a scalar value is
     attempted.  By default, the 'Octave:array-to-scalar' warning is
     disabled.

'Octave:array-to-vector'
     If the 'Octave:array-to-vector' warning is enabled, Octave will
     warn when an implicit conversion from an array to a vector value is
     attempted.  By default, the 'Octave:array-to-vector' warning is
     disabled.

'Octave:assign-as-truth-value'
     If the 'Octave:assign-as-truth-value' warning is enabled, a
     warning is issued for statements like

          if (s = t)
            ...

     since such statements are not common, and it is likely that the
     intent was to write

          if (s == t)
            ...

     instead.

     There are times when it is useful to write c...

     USE help warning_ids FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="warranty" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  warranty ()
     Describe the conditions for copying and distributing Octave.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="wavread" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: Y = wavread (FILENAME)
     Load the RIFF/WAVE sound file FILENAME, and return the samples in
     vector Y.  If the file contains multichannel data, then Y is a
     matrix with the channels represented as columns.

 -- Function File: [Y, FS, BPS] = wavread (FILENAME)
     Additionally return the sample rate (FS) in Hz and the number of
     bits per sample (BPS).

 -- Function File: [...] = wavread (FILENAME, N)
     Read only the first N samples from each channel.

 -- Function File: [...] = wavread (FILENAME, N1 N2)
     Read only samples N1 through N2 from each channel.

 -- Function File: [SAMPLES, CHANNELS] = wavread (FILENAME, 'size')
     Return the number of samples (N) and channels (CH) instead of the
     audio data.

     See also: wavwrite


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="wavwrite" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  wavwrite (Y, FILENAME)
 -- Function File:  wavwrite (Y, FS, FILENAME)
 -- Function File:  wavwrite (Y, FS, BPS, FILENAME)
     Write Y to the canonical RIFF/WAVE sound file FILENAME with sample
     rate FS and bits per sample BPS.  The default sample rate is 8000
     Hz with 16-bits per sample.  Each column of the data represents a
     separate channel.

     See also: wavread


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="wblcdf" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  wblcdf (X)
 -- Function File:  wblcdf (X, SCALE)
 -- Function File:  wblcdf (X, SCALE, SHAPE)
     Compute the cumulative distribution function (CDF) at X of the
     Weibull distribution with scale parameter SCALE and shape
     parameter SHAPE, which is

          1 - exp (-(x/scale)^shape)

     for X &gt;= 0.

     Default values are SCALE = 1, SHAPE = 1.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="wblinv" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  wblinv (X)
 -- Function File:  wblinv (X, SCALE)
 -- Function File:  wblinv (X, SCALE, SHAPE)
     Compute the quantile (the inverse of the CDF) at X of the Weibull
     distribution with scale parameter SCALE and shape parameter SHAPE.

     Default values are SCALE = 1, SHAPE = 1.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="wblpdf" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  wblpdf (X)
 -- Function File:  wblpdf (X, SCALE)
 -- Function File:  wblpdf (X, SCALE, SHAPE)
     Compute the probability density function (PDF) at X of the Weibull
     distribution with scale parameter SCALE and shape parameter SHAPE
     which is given by

          shape * scale^(-shape) * x^(shape-1) * exp (-(x/scale)^shape)

     for X &gt;= 0.

     Default values are SCALE = 1, SHAPE = 1.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="wblrnd" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  wblrnd (SCALE, SHAPE)
 -- Function File:  wblrnd (SCALE, SHAPE, R)
 -- Function File:  wblrnd (SCALE, SHAPE, R, C, ...)
 -- Function File:  wblrnd (SCALE, SHAPE, [SZ])
     Return a matrix of random samples from the Weibull distribution
     with parameters SCALE and SHAPE.

     When called with a single size argument, return a square matrix
     with the dimension specified.  When called with more than one
     scalar argument the first two arguments are taken as the number of
     rows and columns and any further arguments specify additional
     matrix dimensions.  The size may also be specified with a vector
     of dimensions SZ.

     If no size arguments are given then the result matrix is the
     common size of SCALE and SHAPE.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="WCONTINUE" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  WCONTINUE ()
     Return the numerical value of the option argument that may be
     passed to 'waitpid' to indicate that it should also return if a
     stopped child has been resumed by delivery of a 'SIGCONT' signal.

     See also: waitpid, WNOHANG, WUNTRACED


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="WCOREDUMP" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  WCOREDUMP (STATUS)
     Given STATUS from a call to 'waitpid', return true if the child
     produced a core dump.  This function should only be employed if
     'WIFSIGNALED' returned true.  The macro used to implement this
     function is not specified in POSIX.1-2001 and is not available on
     some Unix implementations (e.g., AIX, SunOS).

     See also: waitpid, WIFEXITED, WEXITSTATUS, WIFSIGNALED, WTERMSIG,
     WIFSTOPPED, WSTOPSIG, WIFCONTINUED


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="weekday" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [N, S] = weekday (D)
 -- Function File: [N, S] = weekday (D, FORMAT)
     Return the day of the week as a number in N and as a string in S.
     The days of the week are numbered 1-7 with the first day being
     Sunday.

     D is a serial date number or a date string.

     If the string FORMAT is not present or is equal to 'short' then S
     will contain the abbreviated name of the weekday.  If FORMAT is
     'long' then S will contain the full name.

     Table of return values based on FORMAT:

     N    'short'   'long'
     --------------------------- 
     1    Sun       Sunday
     2    Mon       Monday
     3    Tue       Tuesday
     4    Wed       Wednesday
     5    Thu       Thursday
     6    Fri       Friday
     7    Sat       Saturday

     See also: eomday, is_leap_year, calendar, datenum, datevec


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="welch_test" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [PVAL, T, DF] = welch_test (X, Y, ALT)
     For two samples X and Y from normal distributions with unknown
     means and unknown and not necessarily equal variances, perform a
     Welch test of the null hypothesis of equal means.  Under the null,
     the test statistic T approximately follows a Student distribution
     with DF degrees of freedom.

     With the optional argument string ALT, the alternative of interest
     can be selected.  If ALT is &quot;!=&quot; or &quot;&lt;%gt;&quot;, the null is tested
     against the two-sided alternative 'mean (X) != M'.  If ALT is
     &quot;&gt;&quot;, the one-sided alternative mean(x) &gt; M is considered.
     Similarly for &quot;&lt;&quot;, the one-sided alternative mean(x) &lt; M is
     considered.  The default is the two-sided case.

     The p-value of the test is returned in PVAL.

     If no output argument is given, the p-value of the test is
     displayed.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="WestlandLynx" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: SYS = WestlandLynx ()
     Model of the Westland Lynx Helicopter about hover.
          INPUTS
          main rotor collective
          longitudinal cyclic
          lateral cyclic
          tail rotor collective

          STATES
          pitch attitude           theta       [rad]
          roll attitude            phi         [rad]
          roll rate (body-axis)    p           [rad/s]
          pitch rate (body-axis)   q           [rad/s]
          yaw rate                 xi          [rad/s]
          forward velocity         v_x         [ft/s]
          lateral velocity         v_y         [ft/s]
          vertical velocity        v_z         [ft/s]

          OUTPUTS
          heave velocity           H_dot       [ft/s]
          pitch attitude           theta       [rad]
          roll attitude            phi         [rad]
          heading rate             psi_dot     [rad/s]
          roll rate                p           [rad/s]
          pitch rate       ...

     USE help WestlandLynx FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="WEXITSTATUS" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  WEXITSTATUS (STATUS)
     Given STATUS from a call to 'waitpid', return the exit status of
     the child.  This function should only be employed if 'WIFEXITED'
     returned true.

     See also: waitpid, WIFEXITED, WIFSIGNALED, WTERMSIG, WCOREDUMP,
     WIFSTOPPED, WSTOPSIG, WIFCONTINUED


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="what" func="yes">
            <Overload retVal="">
                <Param name="
 -- Command:  what
 -- Command:  what DIR
 -- Function File: w = what (DIR)
     List the Octave specific files in directory DIR.  If DIR is not
     specified then the current directory is used.  If a return
     argument is requested, the files found are returned in the
     structure W.

     See also: which


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="which" func="yes">
            <Overload retVal="">
                <Param name="
 -- Command:  which name ...
     Display the type of each NAME.  If NAME is defined from a function
     file, the full name of the file is also displayed.

     See also: help, lookfor


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="white" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: MAP = white ()
 -- Function File: MAP = white (N)
     Create color colormap.  This colormap is completely white.  The
     argument N should be a scalar.  If it is omitted, the length of
     the current colormap or 64 is assumed.

     See also: colormap


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="whitebg" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  whitebg ()
 -- Function File:  whitebg (COLOR)
 -- Function File:  whitebg ('none')
 -- Function File:  whitebg (FIG)
 -- Function File:  whitebg (FIG, COLOR)
 -- Function File:  whitebg (FIG, 'none')
     Invert the colors in the current color scheme.  The root
     properties are also inverted such that all subsequent plot use the
     new color scheme.

     If defined, FIG is the handle to the figure to be inverted.  In
     this case only the specified figure has its color properties
     changed.

     If the optional argument COLOR is present then the background color
     is set to COLOR rather than inverted.  COLOR may be a string
     representing one of the eight known colors or an RGB triplet.  The
     special string argument 'none' restores the plot to the default
     colors.

     See also: reset


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="who" func="yes">
            <Overload retVal="">
                <Param name="
 -- Command:  who
 -- Command:  who pattern ...
 -- Command:  who option pattern ...
 -- Command: C = who ('pattern', ...)
     List currently defined variables matching the given patterns.
     Valid pattern syntax is the same as described for the 'clear'
     command.  If no patterns are supplied, all variables are listed.
     By default, only variables visible in the local scope are
     displayed.

     The following are valid options but may not be combined.

    'global'
          List variables in the global scope rather than the current
          scope.

    '-regexp'
          The patterns are considered to be regular expressions when
          matching the variables to display.  The same pattern syntax
          accepted by the 'regexp' function is used.

    '-file'
          The next argument is treated as a filename.  All variables
          found within the specified file are listed.  No patterns are
          accepted when reading variables from a file.

     If called ...

     USE help who FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="whos" func="yes">
            <Overload retVal="">
                <Param name="
 -- Command:  whos
 -- Command:  whos pattern ...
 -- Command:  whos option pattern ...
 -- Command: S = whos ('pattern', ...)
     Provide detailed information on currently defined variables
     matching the given patterns.  Options and pattern syntax are the
     same as for the 'who' command.  Extended information about each
     variable is summarized in a table with the following default
     entries.

    Attr
          Attributes of the listed variable.  Possible attributes are:
         blank
               Variable in local scope

         'a'
               Automatic variable.  An automatic variable is one
               created by the interpreter, for example 'argn'.

         'c'
               Variable of complex type.

         'f'
               Formal parameter (function argument).

         'g'
               Variable with global scope.

         'p'
               Persistent variable.

    Name
          The name of the variable.

    Size
          The logical size ...

     USE help whos FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="whos_line_format" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function: VAL = whos_line_format ()
 -- Built-in Function: OLD_VAL = whos_line_format (NEW_VAL)
 -- Built-in Function:  whos_line_format (NEW_VAL, 'local')
     Query or set the format string used by the command 'whos'.

     A full format string is:

          %[modifier]&lt;command&gt;[:width[:left-min[:balance]]];

     The following command sequences are available:

    '%a'
          Prints attributes of variables (g=global, p=persistent,
          f=formal parameter, a=automatic variable).

    '%b'
          Prints number of bytes occupied by variables.

    '%c'
          Prints class names of variables.

    '%e'
          Prints elements held by variables.

    '%n'
          Prints variable names.

    '%s'
          Prints dimensions of variables.

    '%t'
          Prints type names of variables.

     Every command may also have an alignment modifier:

    'l'
          Left alignment.

    'r'
          Right alignment (default).

    'c'
          Column-aligned...

     USE help whos_line_format FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="wienrnd" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  wienrnd (T, D, N)
     Return a simulated realization of the D-dimensional Wiener Process
     on the interval [0, T].  If D is omitted, D = 1 is used.  The
     first column of the return matrix contains time, the remaining
     columns contain the Wiener process.

     The optional parameter N gives the number of summands used for
     simulating the process over an interval of length 1.  If N is
     omitted, N = 1000 is used.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="WIFCONTINUED" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  WIFCONTINUED (STATUS)
     Given STATUS from a call to 'waitpid', return true if the child
     process was resumed by delivery of 'SIGCONT'.

     See also: waitpid, WIFEXITED, WEXITSTATUS, WIFSIGNALED, WTERMSIG,
     WCOREDUMP, WIFSTOPPED, WSTOPSIG


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="WIFEXITED" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  WIFEXITED (STATUS)
     Given STATUS from a call to 'waitpid', return true if the child
     terminated normally.

     See also: waitpid, WEXITSTATUS, WIFSIGNALED, WTERMSIG, WCOREDUMP,
     WIFSTOPPED, WSTOPSIG, WIFCONTINUED


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="WIFSIGNALED" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  WIFSIGNALED (STATUS)
     Given STATUS from a call to 'waitpid', return true if the child
     process was terminated by a signal.

     See also: waitpid, WIFEXITED, WEXITSTATUS, WTERMSIG, WCOREDUMP,
     WIFSTOPPED, WSTOPSIG, WIFCONTINUED


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="WIFSTOPPED" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  WIFSTOPPED (STATUS)
     Given STATUS from a call to 'waitpid', return true if the child
     process was stopped by delivery of a signal; this is only possible
     if the call was done using 'WUNTRACED' or when the child is being
     traced (see ptrace(2)).

     See also: waitpid, WIFEXITED, WEXITSTATUS, WIFSIGNALED, WTERMSIG,
     WCOREDUMP, WSTOPSIG, WIFCONTINUED


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="wilcoxon_test" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [PVAL, Z] = wilcoxon_test (X, Y, ALT)
     For two matched-pair sample vectors X and Y, perform a Wilcoxon
     signed-rank test of the null hypothesis PROB (X &gt; Y) == 1/2.
     Under the null, the test statistic Z approximately follows a
     standard normal distribution when N &gt; 25.

     *Caution:* This function assumes a normal distribution for Z and
     thus is invalid for N &lt;= 25.

     With the optional argument string ALT, the alternative of interest
     can be selected.  If ALT is &quot;!=&quot; or &quot;&lt;%gt;&quot;, the null is tested
     against the two-sided alternative PROB (X &gt; Y) != 1/2.  If alt is
     &quot;&gt;&quot;, the one-sided alternative PROB (X &gt; Y) &gt; 1/2 is considered.
     Similarly for &quot;&lt;&quot;, the one-sided alternative PROB (X &gt; Y) &lt; 1/2
     is considered.  The default is the two-sided case.

     The p-value of the test is returned in PVAL.

     If no output argument is given, the p-value of the test is
     displayed.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="wilkinson" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  wilkinson (N)
     Return the Wilkinson matrix of order N.  Wilkinson matrices are
     symmetric and tridiagonal with pairs of nearly, but not exactly,
     equal eigenvalues.  They are useful in testing the behavior and
     performance of eigenvalue solvers.

     See also: rosser, eig


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="winter" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: MAP = winter ()
 -- Function File: MAP = winter (N)
     Create color colormap.  This colormap varies from blue to green.
     The argument N must be a scalar.  If unspecified, the length of
     the current colormap, or 64, is used.

     See also: colormap


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="WNOHANG" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  WNOHANG ()
     Return the numerical value of the option argument that may be
     passed to 'waitpid' to indicate that it should return its status
     immediately instead of waiting for a process to exit.

     See also: waitpid, WUNTRACED, WCONTINUE


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="WSTOPSIG" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  WSTOPSIG (STATUS)
     Given STATUS from a call to 'waitpid', return the number of the
     signal which caused the child to stop.  This function should only
     be employed if 'WIFSTOPPED' returned true.

     See also: waitpid, WIFEXITED, WEXITSTATUS, WIFSIGNALED, WTERMSIG,
     WCOREDUMP, WIFSTOPPED, WIFCONTINUED


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="WTERMSIG" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  WTERMSIG (STATUS)
     Given STATUS from a call to 'waitpid', return the number of the
     signal that caused the child process to terminate.  This function
     should only be employed if 'WIFSIGNALED' returned true.

     See also: waitpid, WIFEXITED, WEXITSTATUS, WIFSIGNALED, WCOREDUMP,
     WIFSTOPPED, WSTOPSIG, WIFCONTINUED


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="WUNTRACED" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  WUNTRACED ()
     Return the numerical value of the option argument that may be
     passed to 'waitpid' to indicate that it should also return if the
     child process has stopped but is not traced via the 'ptrace'
     system call

     See also: waitpid, WNOHANG, WCONTINUE


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="xlabel" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  xlabel (STRING)
 -- Function File:  xlabel (H, STRING)
 -- Function File: H = xlabel (...)
 -- Function File:  ylabel (...)
 -- Function File:  zlabel (...)
     Specify x-, y-, or z-axis labels for the current axis.  If H is
     specified then label the axis defined by H.

     The optional return value H is a graphics handle to the created
     object.

     See also: title, text


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="xlim" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: XL = xlim ()
 -- Function File:  xlim (XL)
 -- Function File: M = xlim ('mode')
 -- Function File:  xlim (M)
 -- Function File:  xlim (H, ...)
     Get or set the limits of the x-axis of the current plot.  Called
     without arguments 'xlim' returns the x-axis limits of the current
     plot.  If passed a two element vector XL, the limits of the x-axis
     are set to this value.

     The current mode for calculation of the x-axis can be returned
     with a call 'xlim ('mode')', and can be either 'auto' or 'manual'.
     The current plotting mode can be set by passing either 'auto' or
     'manual' as the argument.

     If passed a handle as the first argument, then operate on this
     handle rather than the current axes handle.

     See also: ylim, zlim, set, get, gca


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="xor" func="yes">
            <Overload retVal="">
                <Param name="
 -- Mapping Function: Z = xor (X, Y)
     Return the 'exclusive or' of the entries of X and Y.  For boolean
     expressions X and Y, 'xor (X, Y)' is true if and only if one of X
     or Y is true.  Otherwise, for X and Y both true or both false,
     'xor' returns false.

     The truth table for the xor operation is

                                   X  Y   Z  
                                   0  0   0  
                                   1  0   1  
                                   0  1   1  
                                   1  1   0  

     See also: and, or, not


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="yes_or_no" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  yes_or_no (PROMPT)
     Ask the user a yes-or-no question.  Return 1 if the answer is yes.
     Takes one argument, which is the string to display to ask the
     question.  It should end in a space; 'yes-or-no-p' adds '(yes or
     no) ' to it.  The user must confirm the answer with RET and can
     edit it until it has been confirmed.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="yulewalker" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [A, V] = yulewalker (C)
     Fit an AR (p)-model with Yule-Walker estimates given a vector C of
     autocovariances '[gamma_0, ..., gamma_p]'.

     Returns the AR coefficients, A, and the variance of white noise, V.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="z_test" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [PVAL, Z] = z_test (X, M, V, ALT)
     Perform a Z-test of the null hypothesis 'mean (X) == M' for a
     sample X from a normal distribution with unknown mean and known
     variance V.  Under the null, the test statistic Z follows a
     standard normal distribution.

     With the optional argument string ALT, the alternative of interest
     can be selected.  If ALT is &quot;!=&quot; or &quot;&lt;%gt;&quot;, the null is tested
     against the two-sided alternative 'mean (X) != M'.  If ALT is
     &quot;&gt;&quot;, the one-sided alternative 'mean (X) &gt; M' is considered.
     Similarly for &quot;&lt;&quot;, the one-sided alternative 'mean (X) &lt; M' is
     considered.  The default is the two-sided case.

     The p-value of the test is returned in PVAL.

     If no output argument is given, the p-value of the test is
     displayed along with some information.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="z_test_2" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: [PVAL, Z] = z_test_2 (X, Y, V_X, V_Y, ALT)
     For two samples X and Y from normal distributions with unknown
     means and known variances V_X and V_Y, perform a Z-test of the
     hypothesis of equal means.  Under the null, the test statistic Z
     follows a standard normal distribution.

     With the optional argument string ALT, the alternative of interest
     can be selected.  If ALT is &quot;!=&quot; or &quot;&lt;%gt;&quot;, the null is tested
     against the two-sided alternative 'mean (X) != mean (Y)'.  If alt
     is &quot;&gt;&quot;, the one-sided alternative 'mean (X) &gt; mean (Y)' is used.
     Similarly for &quot;&lt;&quot;, the one-sided alternative 'mean (X) &lt; mean
     (Y)' is used.  The default is the two-sided case.

     The p-value of the test is returned in PVAL.

     If no output argument is given, the p-value of the test is
     displayed along with some information.

                " />
            </Overload>
        </KeyWord>
        <KeyWord name="zeros" func="yes">
            <Overload retVal="">
                <Param name="
 -- Built-in Function:  zeros (N)
 -- Built-in Function:  zeros (M, N)
 -- Built-in Function:  zeros (M, N, K, ...)
 -- Built-in Function:  zeros ([M N ...])
 -- Built-in Function:  zeros (..., CLASS)
     Return a matrix or N-dimensional array whose elements are all 0.
     If invoked with a single scalar integer argument, return a square
     NxN matrix.  If invoked with two or more scalar integer arguments,
     or a vector of integer values, return an array with the given
     dimensions.

     The optional argument CLASS specifies the class of the return array
     and defaults to double.  For example:

          val = zeros (m,n, 'uint8')

     See also: ones


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="zip" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: ENTRIES = zip (ZIPFILE, FILES)
 -- Function File: ENTRIES = zip (ZIPFILE, FILES, ROOTDIR)
     Compress the list of files and/or directories specified in FILES
     into the archive ZIPFILE in the same directory.  If ROOTDIR is
     defined the FILES are located relative to ROOTDIR rather than the
     current directory.

     See also: unzip, bzip2, gzip, tar


                " />
            </Overload>
        </KeyWord>
        <KeyWord name="zpk" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File: S = zpk ('S')
 -- Function File: Z = zpk ('Z', TSAM)
 -- Function File: SYS = zpk (SYS)
 -- Function File: SYS = zpk (K)
 -- Function File: SYS = zpk (Z, P, K, ...)
 -- Function File: SYS = zpk (Z, P, K, TSAM, ...)
 -- Function File: SYS = zpk (Z, P, K, TSAM, ...)
     Create transfer function model from zero-pole-gain data.  This is
     just a stop-gap compatibility wrapper since zpk models are not yet
     implemented.

     *Inputs*
    SYS
          LTI model to be converted to transfer function.

    Z
          Cell of vectors containing the zeros for each channel.
          z{i,j} contains the zeros from input j to output i.  In the
          SISO case, a single vector is accepted as well.

    P
          Cell of vectors containing the poles for each channel.
          p{i,j} contains the poles from input j to output i.  In the
          SISO case, a single vector is accepted as well.

    K
          Matrix containing the gains for each channel.  k(i,j)
   ...

     USE help zpk FOR MORE DETAIL
                " />
            </Overload>
        </KeyWord>
        <KeyWord name="zscore" func="yes">
            <Overload retVal="">
                <Param name="
 -- Function File:  zscore (X)
 -- Function File:  zscore (X, DIM)
     If X is a vector, subtract its mean and divide by its standard
     deviation.

     If X is a matrix, do the above along the first non-singleton
     dimension.  If the optional argument DIM is given, operate along
     this dimension.

     See also: center


                " />
            </Overload>
        </KeyWord>
    </AutoComplete>
</NotepadPlus>